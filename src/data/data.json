[
  {
    "content": "This document contains information about where the data is from.\n- Data in folder `flare-docs` was downloaded from [https://github.com/flare-foundation/docs]\n- Data in `hub-docs` was downloaded from [https://github.com/flare-foundation/developer-hub]\n\nSome files were not seen as helpful for this project, so they were removed.",
    "meta_data": {
      "title": "Documentation sources"
    },
    "file_name": "sources.md",
    "type": "answer"
  },
  {
    "content": "Flare is the blockchain for data. It is a Layer 1, EVM smart contract platform designed to expand the utility of blockchain. Read more in [**What Is Flare?**](./tech/flare.md)\n\n#### For token holders\n\n<div class=\"flr-card has-background1\" markdown>\n\nFlare is the blockchain for data. It is a Layer 1, EVM smart contract platform designed to expand the utility of blockchain. Read more in [**What Is Flare?**](./tech/flare.md)\n\n#### For token holders\n\n<div class=\"flr-card has-background1\" markdown>\n\nFlare is the blockchain for data. It is a Layer 1, EVM smart contract platform designed to expand the utility of blockchain. Read more in [**What Is Flare?**](./tech/flare.md)\n\n#### For token holders\n\n<div class=\"flr-card has-background1\" markdown>\n\nFlare is the blockchain for data. It is a Layer 1, EVM smart contract platform designed to expand the utility of blockchain. Read more in [**What Is Flare?**](./tech/flare.md)\n\n#### For token holders\n\n<div class=\"flr-card has-background1\" markdown>\n\nFlare is the blockchain for data. It is a Layer 1, EVM smart contract platform designed to expand the utility of blockchain. Read more in [**What Is Flare?**](./tech/flare.md)\n\n#### For token holders\n\n<div class=\"flr-card has-background1\" markdown>",
    "file_name": "files/flare-docs/index.md",
    "meta_data": {
      "hide": [
        "toc"
      ],
      "title": "Welcome to the Flare Network Documentation"
    },
    "type": "answer"
  },
  {
    "content": "import ThemedImage from \"@theme/ThemedImage\";\nimport useBaseUrl from \"@docusaurus/useBaseUrl\";\n\n**Flare is the blockchain for data \u2600\ufe0f**, offering developers and users secure, decentralized access to high-integrity data from other chains and the internet. Flare's Layer-1 network uniquely supports enshrined data protocols at the network layer, making it the only EVM-compatible smart contract platform optimized for decentralized data acquisition, including price and time-series data, blockchain event and state data, and Web2 API data.\n\nBy providing broad data access at scale and minimal cost, Flare delivers a full-stack solution for building the next generation of secure, interoperable, and data-driven decentralized applications.\n\nimport ThemedImage from \"@theme/ThemedImage\";\nimport useBaseUrl from \"@docusaurus/useBaseUrl\";\n\n**Flare is the blockchain for data \u2600\ufe0f**, offering developers and users secure, decentralized access to high-integrity data from other chains and the internet. Flare's Layer-1 network uniquely supports enshrined data protocols at the network layer, making it the only EVM-compatible smart contract platform optimized for decentralized data acquisition, including price and time-series data, blockchain event and state data, and Web2 API data.\n\nBy providing broad data access at scale and minimal cost, Flare delivers a full-stack solution for building the next generation of secure, interoperable, and data-driven decentralized applications.\n\nimport ThemedImage from \"@theme/ThemedImage\";\nimport useBaseUrl from \"@docusaurus/useBaseUrl\";\n\n**Flare is the blockchain for data \u2600\ufe0f**, offering developers and users secure, decentralized access to high-integrity data from other chains and the internet. Flare's Layer-1 network uniquely supports enshrined data protocols at the network layer, making it the only EVM-compatible smart contract platform optimized for decentralized data acquisition, including price and time-series data, blockchain event and state data, and Web2 API data.\n\nBy providing broad data access at scale and minimal cost, Flare delivers a full-stack solution for building the next generation of secure, interoperable, and data-driven decentralized applications.\n\nimport ThemedImage from \"@theme/ThemedImage\";\nimport useBaseUrl from \"@docusaurus/useBaseUrl\";\n\n**Flare is the blockchain for data \u2600\ufe0f**, offering developers and users secure, decentralized access to high-integrity data from other chains and the internet. Flare's Layer-1 network uniquely supports enshrined data protocols at the network layer, making it the only EVM-compatible smart contract platform optimized for decentralized data acquisition, including price and time-series data, blockchain event and state data, and Web2 API data.\n\nBy providing broad data access at scale and minimal cost, Flare delivers a full-stack solution for building the next generation of secure, interoperable, and data-driven decentralized applications.",
    "file_name": "files/hub-docs/1-intro.mdx",
    "meta_data": {
      "sidebar_position": 1,
      "slug": "intro",
      "title": "Introduction",
      "description": "Introduction to Flare, the blockchain for data.",
      "keywords": [
        "flare-network",
        "blockchain",
        "data",
        "smart contracts",
        "flare-time-series-oracle",
        "flare-data-connector"
      ]
    },
    "type": "answer"
  },
  {
    "content": "import Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport DocCardList from \"@theme/DocCardList\";\nimport SolidityReference from \"@site/src/components/DataTables/SolidityReference\";\n\nimport Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport DocCardList from \"@theme/DocCardList\";\nimport SolidityReference from \"@site/src/components/DataTables/SolidityReference\";\n\nimport Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport DocCardList from \"@theme/DocCardList\";\nimport SolidityReference from \"@site/src/components/DataTables/SolidityReference\";",
    "file_name": "files/hub-docs/network/3-solidity-reference.mdx",
    "meta_data": {
      "title": "Network Reference",
      "description": "Solidity reference for Flare contracts.",
      "keywords": [
        "solidity",
        "reference",
        "ftso",
        "flare-network",
        "smart-contracts"
      ]
    },
    "type": "answer"
  },
  {
    "content": "import Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport DocCardList from \"@theme/DocCardList\";\nimport SolidityReference from \"@site/src/components/DataTables/SolidityReference\";\nimport ThemedImage from \"@theme/ThemedImage\";\nimport useBaseUrl from \"@docusaurus/useBaseUrl\";\n\nThe **F**lare **S**ystems **P**rotocol (**FSP**) is a foundational infrastructure designed to support Flare's enshrined protocols (technically referred to as sub-protocols).\nIts primary goal is to facilitate secure, efficient, and decentralized consensus mechanisms through weighted voting by a select group of entities known as voters.\nThese voters are off-chain participants who accrue vote power from the Flare community via delegations of wrapped FLR tokens (WFLR) or stakes.\n\nFSP ensures that agreements on off-chain data or calculations are reached securely and fairly, enabling the reliable operation of sub-protocols\nlike the [Flare Time Series Oracle](/ftso/overview) and the [Flare Data Connector](/fdc/overview).\n\n**Key FSP Features:**\n\n- **Decentralized Governance**: Through a weighted voting system involving a diverse set of voters.\n- **Efficient Data Management**: By offloading complex calculations off-chain and minimizing on-chain storage requirements.\n- **Robust Reward Mechanisms**: Incentivizing participation and penalizing delays or non-compliance to maintain network health.\n- **Extensibility**: Designed to support additional sub-protocols and future enhancements like C-chain staking.\n- **Security**: Implements mechanisms to prevent malicious behavior and ensures data integrity through Merkle proofs.\n\n<ThemedImage\n  alt=\"FSP Architecture\"\n  sources={{\n    light: useBaseUrl(\"img/fsp/fsp_light.svg\"),\n    dark: useBaseUrl(\"img/fsp/fsp_dark.svg\"),\n  }}\n/>\n\n<DocCardList />",
    "meta_data": {
      "slug": "fsp",
      "title": "Flare Systems Protocol",
      "description": "Foundational architecture supporting Flare's enshrined protocols.",
      "keywords": [
        "flare-network",
        "configuration",
        "blockchain",
        "data",
        "smart-contracts"
      ]
    },
    "file_name": "files/hub-docs/network/4-fsp.mdx",
    "type": "answer"
  },
  {
    "content": "import Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport IconExternalLink from \"@theme/Icon/ExternalLink\";\nimport IconCopy from \"@theme/Icon/Copy\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport BlockNumCostonJS from \"!!raw-loader!/examples/developer-hub-javascript/block_number_coston.js\";\nimport BlockNumFlareJS from \"!!raw-loader!/examples/developer-hub-javascript/block_number_flare.js\";\nimport BlockNumCoston2JS from \"!!raw-loader!/examples/developer-hub-javascript/block_number_coston2.js\";\nimport BlockNumSongbirdJS from \"!!raw-loader!/examples/developer-hub-javascript/block_number_songbird.js\";\nimport BlockNumCostonPy from \"!!raw-loader!/examples/developer-hub-python/block_number_coston.py\";\nimport BlockNumFlarePy from \"!!raw-loader!/examples/developer-hub-python/block_number_flare.py\";\nimport BlockNumCoston2Py from \"!!raw-loader!/examples/developer-hub-python/block_number_coston2.py\";\nimport BlockNumSongbirdPy from \"!!raw-loader!/examples/developer-hub-python/block_number_songbird.py\";\nimport BlockNumCostonRs from \"!!raw-loader!/examples/developer-hub-rust/src/bin/block_number_coston.rs\";\nimport BlockNumFlareRs from \"!!raw-loader!/examples/developer-hub-rust/src/bin/block_number_flare.rs\";\nimport BlockNumCoston2Rs from \"!!raw-loader!/examples/developer-hub-rust/src/bin/block_number_coston2.rs\";\nimport BlockNumSongbirdRs from \"!!raw-loader!/examples/developer-hub-rust/src/bin/block_number_songbird.rs\";\nimport BlockNumCostonGo from \"!!raw-loader!/examples/developer-hub-go/coston/block_number.go\";\nimport BlockNumFlareGo from \"!!raw-loader!/examples/developer-hub-go/flare/block_number.go\";\nimport BlockNumCoston2Go from \"!!raw-loader!/examples/developer-hub-go/coston2/block_number.go\";\nimport BlockNumSongbirdGo from \"!!raw-loader!/examples/developer-hub-go/songbird/block_number.go\";\n\nFlare has four networks, each serving different purposes, so choosing the right one is crucial. All of these networks operate on a permissionless basis and are EVM compatible:\n\n- **Flare Mainnet.** The production network where all the action happens. Transactions cost real money here.\n\n- **Flare Testnet Coston2.** Test your applications without spending real money. This should be your first choice when developing applications.\n\n- **Songbird Canary-Network.** Experimental proving ground for Flare.\n\n- **Songbird Testnet Coston.** The testnet for Songbird Canary-Network.\n\nThe most common development tracks are:\n\n- **Flare Testnet Coston2 \u2192 Flare Mainnet**: Recommended track for application developers.\n\n- **Songbird Testnet Coston \u2192 Songbird Canary-Network \u2192 Flare Testnet Coston2 \u2192 Flare Mainnet**: Required track for all protocol level changes.",
    "file_name": "files/hub-docs/network/0-overview.mdx",
    "meta_data": {
      "slug": "overview",
      "title": "Network",
      "description": "Learn about the different Flare networks, configuration, supported wallets, transaction format, smart contracts, consensus, and more.",
      "keywords": [
        "flare-network",
        "configuration",
        "blockchain",
        "data",
        "smart-contracts",
        "wallets"
      ]
    },
    "type": "answer"
  },
  {
    "content": "import Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport IconExternalLink from \"@theme/Icon/ExternalLink\";\nimport IconCopy from \"@theme/Icon/Copy\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport BlockNumCostonJS from \"!!raw-loader!/examples/developer-hub-javascript/block_number_coston.js\";\nimport BlockNumFlareJS from \"!!raw-loader!/examples/developer-hub-javascript/block_number_flare.js\";\nimport BlockNumCoston2JS from \"!!raw-loader!/examples/developer-hub-javascript/block_number_coston2.js\";\nimport BlockNumSongbirdJS from \"!!raw-loader!/examples/developer-hub-javascript/block_number_songbird.js\";\nimport BlockNumCostonPy from \"!!raw-loader!/examples/developer-hub-python/block_number_coston.py\";\nimport BlockNumFlarePy from \"!!raw-loader!/examples/developer-hub-python/block_number_flare.py\";\nimport BlockNumCoston2Py from \"!!raw-loader!/examples/developer-hub-python/block_number_coston2.py\";\nimport BlockNumSongbirdPy from \"!!raw-loader!/examples/developer-hub-python/block_number_songbird.py\";\nimport BlockNumCostonRs from \"!!raw-loader!/examples/developer-hub-rust/src/bin/block_number_coston.rs\";\nimport BlockNumFlareRs from \"!!raw-loader!/examples/developer-hub-rust/src/bin/block_number_flare.rs\";\nimport BlockNumCoston2Rs from \"!!raw-loader!/examples/developer-hub-rust/src/bin/block_number_coston2.rs\";\nimport BlockNumSongbirdRs from \"!!raw-loader!/examples/developer-hub-rust/src/bin/block_number_songbird.rs\";\nimport BlockNumCostonGo from \"!!raw-loader!/examples/developer-hub-go/coston/block_number.go\";\nimport BlockNumFlareGo from \"!!raw-loader!/examples/developer-hub-go/flare/block_number.go\";\nimport BlockNumCoston2Go from \"!!raw-loader!/examples/developer-hub-go/coston2/block_number.go\";\nimport BlockNumSongbirdGo from \"!!raw-loader!/examples/developer-hub-go/songbird/block_number.go\";\n\nFlare has four networks, each serving different purposes, so choosing the right one is crucial. All of these networks operate on a permissionless basis and are EVM compatible:\n\n- **Flare Mainnet.** The production network where all the action happens. Transactions cost real money here.\n\n- **Flare Testnet Coston2.** Test your applications without spending real money. This should be your first choice when developing applications.\n\n- **Songbird Canary-Network.** Experimental proving ground for Flare.\n\n- **Songbird Testnet Coston.** The testnet for Songbird Canary-Network.\n\nThe most common development tracks are:\n\n- **Flare Testnet Coston2 \u2192 Flare Mainnet**: Recommended track for application developers.\n\n- **Songbird Testnet Coston \u2192 Songbird Canary-Network \u2192 Flare Testnet Coston2 \u2192 Flare Mainnet**: Required track for all protocol level changes.",
    "file_name": "files/hub-docs/network/0-overview.mdx",
    "meta_data": {
      "slug": "overview",
      "title": "Network",
      "description": "Learn about the different Flare networks, configuration, supported wallets, transaction format, smart contracts, consensus, and more.",
      "keywords": [
        "flare-network",
        "configuration",
        "blockchain",
        "data",
        "smart-contracts",
        "wallets"
      ]
    },
    "type": "answer"
  },
  {
    "content": "import Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport IconExternalLink from \"@theme/Icon/ExternalLink\";\nimport IconCopy from \"@theme/Icon/Copy\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport BlockNumCostonJS from \"!!raw-loader!/examples/developer-hub-javascript/block_number_coston.js\";\nimport BlockNumFlareJS from \"!!raw-loader!/examples/developer-hub-javascript/block_number_flare.js\";\nimport BlockNumCoston2JS from \"!!raw-loader!/examples/developer-hub-javascript/block_number_coston2.js\";\nimport BlockNumSongbirdJS from \"!!raw-loader!/examples/developer-hub-javascript/block_number_songbird.js\";\nimport BlockNumCostonPy from \"!!raw-loader!/examples/developer-hub-python/block_number_coston.py\";\nimport BlockNumFlarePy from \"!!raw-loader!/examples/developer-hub-python/block_number_flare.py\";\nimport BlockNumCoston2Py from \"!!raw-loader!/examples/developer-hub-python/block_number_coston2.py\";\nimport BlockNumSongbirdPy from \"!!raw-loader!/examples/developer-hub-python/block_number_songbird.py\";\nimport BlockNumCostonRs from \"!!raw-loader!/examples/developer-hub-rust/src/bin/block_number_coston.rs\";\nimport BlockNumFlareRs from \"!!raw-loader!/examples/developer-hub-rust/src/bin/block_number_flare.rs\";\nimport BlockNumCoston2Rs from \"!!raw-loader!/examples/developer-hub-rust/src/bin/block_number_coston2.rs\";\nimport BlockNumSongbirdRs from \"!!raw-loader!/examples/developer-hub-rust/src/bin/block_number_songbird.rs\";\nimport BlockNumCostonGo from \"!!raw-loader!/examples/developer-hub-go/coston/block_number.go\";\nimport BlockNumFlareGo from \"!!raw-loader!/examples/developer-hub-go/flare/block_number.go\";\nimport BlockNumCoston2Go from \"!!raw-loader!/examples/developer-hub-go/coston2/block_number.go\";\nimport BlockNumSongbirdGo from \"!!raw-loader!/examples/developer-hub-go/songbird/block_number.go\";\n\nFlare has four networks, each serving different purposes, so choosing the right one is crucial. All of these networks operate on a permissionless basis and are EVM compatible:\n\n- **Flare Mainnet.** The production network where all the action happens. Transactions cost real money here.\n\n- **Flare Testnet Coston2.** Test your applications without spending real money. This should be your first choice when developing applications.\n\n- **Songbird Canary-Network.** Experimental proving ground for Flare.\n\n- **Songbird Testnet Coston.** The testnet for Songbird Canary-Network.\n\nThe most common development tracks are:\n\n- **Flare Testnet Coston2 \u2192 Flare Mainnet**: Recommended track for application developers.\n\n- **Songbird Testnet Coston \u2192 Songbird Canary-Network \u2192 Flare Testnet Coston2 \u2192 Flare Mainnet**: Required track for all protocol level changes.",
    "file_name": "files/hub-docs/network/0-overview.mdx",
    "meta_data": {
      "slug": "overview",
      "title": "Network",
      "description": "Learn about the different Flare networks, configuration, supported wallets, transaction format, smart contracts, consensus, and more.",
      "keywords": [
        "flare-network",
        "configuration",
        "blockchain",
        "data",
        "smart-contracts",
        "wallets"
      ]
    },
    "type": "answer"
  },
  {
    "content": "import Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport IconExternalLink from \"@theme/Icon/ExternalLink\";\nimport IconCopy from \"@theme/Icon/Copy\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport BlockNumCostonJS from \"!!raw-loader!/examples/developer-hub-javascript/block_number_coston.js\";\nimport BlockNumFlareJS from \"!!raw-loader!/examples/developer-hub-javascript/block_number_flare.js\";\nimport BlockNumCoston2JS from \"!!raw-loader!/examples/developer-hub-javascript/block_number_coston2.js\";\nimport BlockNumSongbirdJS from \"!!raw-loader!/examples/developer-hub-javascript/block_number_songbird.js\";\nimport BlockNumCostonPy from \"!!raw-loader!/examples/developer-hub-python/block_number_coston.py\";\nimport BlockNumFlarePy from \"!!raw-loader!/examples/developer-hub-python/block_number_flare.py\";\nimport BlockNumCoston2Py from \"!!raw-loader!/examples/developer-hub-python/block_number_coston2.py\";\nimport BlockNumSongbirdPy from \"!!raw-loader!/examples/developer-hub-python/block_number_songbird.py\";\nimport BlockNumCostonRs from \"!!raw-loader!/examples/developer-hub-rust/src/bin/block_number_coston.rs\";\nimport BlockNumFlareRs from \"!!raw-loader!/examples/developer-hub-rust/src/bin/block_number_flare.rs\";\nimport BlockNumCoston2Rs from \"!!raw-loader!/examples/developer-hub-rust/src/bin/block_number_coston2.rs\";\nimport BlockNumSongbirdRs from \"!!raw-loader!/examples/developer-hub-rust/src/bin/block_number_songbird.rs\";\nimport BlockNumCostonGo from \"!!raw-loader!/examples/developer-hub-go/coston/block_number.go\";\nimport BlockNumFlareGo from \"!!raw-loader!/examples/developer-hub-go/flare/block_number.go\";\nimport BlockNumCoston2Go from \"!!raw-loader!/examples/developer-hub-go/coston2/block_number.go\";\nimport BlockNumSongbirdGo from \"!!raw-loader!/examples/developer-hub-go/songbird/block_number.go\";\n\nFlare has four networks, each serving different purposes, so choosing the right one is crucial. All of these networks operate on a permissionless basis and are EVM compatible:\n\n- **Flare Mainnet.** The production network where all the action happens. Transactions cost real money here.\n\n- **Flare Testnet Coston2.** Test your applications without spending real money. This should be your first choice when developing applications.\n\n- **Songbird Canary-Network.** Experimental proving ground for Flare.\n\n- **Songbird Testnet Coston.** The testnet for Songbird Canary-Network.\n\nThe most common development tracks are:\n\n- **Flare Testnet Coston2 \u2192 Flare Mainnet**: Recommended track for application developers.\n\n- **Songbird Testnet Coston \u2192 Songbird Canary-Network \u2192 Flare Testnet Coston2 \u2192 Flare Mainnet**: Required track for all protocol level changes.",
    "file_name": "files/hub-docs/network/0-overview.mdx",
    "meta_data": {
      "slug": "overview",
      "title": "Network",
      "description": "Learn about the different Flare networks, configuration, supported wallets, transaction format, smart contracts, consensus, and more.",
      "keywords": [
        "flare-network",
        "configuration",
        "blockchain",
        "data",
        "smart-contracts",
        "wallets"
      ]
    },
    "type": "answer"
  },
  {
    "content": "import Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport IconExternalLink from \"@theme/Icon/ExternalLink\";\nimport IconCopy from \"@theme/Icon/Copy\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport BlockNumCostonJS from \"!!raw-loader!/examples/developer-hub-javascript/block_number_coston.js\";\nimport BlockNumFlareJS from \"!!raw-loader!/examples/developer-hub-javascript/block_number_flare.js\";\nimport BlockNumCoston2JS from \"!!raw-loader!/examples/developer-hub-javascript/block_number_coston2.js\";\nimport BlockNumSongbirdJS from \"!!raw-loader!/examples/developer-hub-javascript/block_number_songbird.js\";\nimport BlockNumCostonPy from \"!!raw-loader!/examples/developer-hub-python/block_number_coston.py\";\nimport BlockNumFlarePy from \"!!raw-loader!/examples/developer-hub-python/block_number_flare.py\";\nimport BlockNumCoston2Py from \"!!raw-loader!/examples/developer-hub-python/block_number_coston2.py\";\nimport BlockNumSongbirdPy from \"!!raw-loader!/examples/developer-hub-python/block_number_songbird.py\";\nimport BlockNumCostonRs from \"!!raw-loader!/examples/developer-hub-rust/src/bin/block_number_coston.rs\";\nimport BlockNumFlareRs from \"!!raw-loader!/examples/developer-hub-rust/src/bin/block_number_flare.rs\";\nimport BlockNumCoston2Rs from \"!!raw-loader!/examples/developer-hub-rust/src/bin/block_number_coston2.rs\";\nimport BlockNumSongbirdRs from \"!!raw-loader!/examples/developer-hub-rust/src/bin/block_number_songbird.rs\";\nimport BlockNumCostonGo from \"!!raw-loader!/examples/developer-hub-go/coston/block_number.go\";\nimport BlockNumFlareGo from \"!!raw-loader!/examples/developer-hub-go/flare/block_number.go\";\nimport BlockNumCoston2Go from \"!!raw-loader!/examples/developer-hub-go/coston2/block_number.go\";\nimport BlockNumSongbirdGo from \"!!raw-loader!/examples/developer-hub-go/songbird/block_number.go\";\n\nFlare has four networks, each serving different purposes, so choosing the right one is crucial. All of these networks operate on a permissionless basis and are EVM compatible:\n\n- **Flare Mainnet.** The production network where all the action happens. Transactions cost real money here.\n\n- **Flare Testnet Coston2.** Test your applications without spending real money. This should be your first choice when developing applications.\n\n- **Songbird Canary-Network.** Experimental proving ground for Flare.\n\n- **Songbird Testnet Coston.** The testnet for Songbird Canary-Network.\n\nThe most common development tracks are:\n\n- **Flare Testnet Coston2 \u2192 Flare Mainnet**: Recommended track for application developers.\n\n- **Songbird Testnet Coston \u2192 Songbird Canary-Network \u2192 Flare Testnet Coston2 \u2192 Flare Mainnet**: Required track for all protocol level changes.",
    "file_name": "files/hub-docs/network/0-overview.mdx",
    "meta_data": {
      "slug": "overview",
      "title": "Network",
      "description": "Learn about the different Flare networks, configuration, supported wallets, transaction format, smart contracts, consensus, and more.",
      "keywords": [
        "flare-network",
        "configuration",
        "blockchain",
        "data",
        "smart-contracts",
        "wallets"
      ]
    },
    "type": "answer"
  },
  {
    "content": "import Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport IconExternalLink from \"@theme/Icon/ExternalLink\";\nimport IconCopy from \"@theme/Icon/Copy\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport BlockNumCostonJS from \"!!raw-loader!/examples/developer-hub-javascript/block_number_coston.js\";\nimport BlockNumFlareJS from \"!!raw-loader!/examples/developer-hub-javascript/block_number_flare.js\";\nimport BlockNumCoston2JS from \"!!raw-loader!/examples/developer-hub-javascript/block_number_coston2.js\";\nimport BlockNumSongbirdJS from \"!!raw-loader!/examples/developer-hub-javascript/block_number_songbird.js\";\nimport BlockNumCostonPy from \"!!raw-loader!/examples/developer-hub-python/block_number_coston.py\";\nimport BlockNumFlarePy from \"!!raw-loader!/examples/developer-hub-python/block_number_flare.py\";\nimport BlockNumCoston2Py from \"!!raw-loader!/examples/developer-hub-python/block_number_coston2.py\";\nimport BlockNumSongbirdPy from \"!!raw-loader!/examples/developer-hub-python/block_number_songbird.py\";\nimport BlockNumCostonRs from \"!!raw-loader!/examples/developer-hub-rust/src/bin/block_number_coston.rs\";\nimport BlockNumFlareRs from \"!!raw-loader!/examples/developer-hub-rust/src/bin/block_number_flare.rs\";\nimport BlockNumCoston2Rs from \"!!raw-loader!/examples/developer-hub-rust/src/bin/block_number_coston2.rs\";\nimport BlockNumSongbirdRs from \"!!raw-loader!/examples/developer-hub-rust/src/bin/block_number_songbird.rs\";\nimport BlockNumCostonGo from \"!!raw-loader!/examples/developer-hub-go/coston/block_number.go\";\nimport BlockNumFlareGo from \"!!raw-loader!/examples/developer-hub-go/flare/block_number.go\";\nimport BlockNumCoston2Go from \"!!raw-loader!/examples/developer-hub-go/coston2/block_number.go\";\nimport BlockNumSongbirdGo from \"!!raw-loader!/examples/developer-hub-go/songbird/block_number.go\";\n\nFlare has four networks, each serving different purposes, so choosing the right one is crucial. All of these networks operate on a permissionless basis and are EVM compatible:\n\n- **Flare Mainnet.** The production network where all the action happens. Transactions cost real money here.\n\n- **Flare Testnet Coston2.** Test your applications without spending real money. This should be your first choice when developing applications.\n\n- **Songbird Canary-Network.** Experimental proving ground for Flare.\n\n- **Songbird Testnet Coston.** The testnet for Songbird Canary-Network.\n\nThe most common development tracks are:\n\n- **Flare Testnet Coston2 \u2192 Flare Mainnet**: Recommended track for application developers.\n\n- **Songbird Testnet Coston \u2192 Songbird Canary-Network \u2192 Flare Testnet Coston2 \u2192 Flare Mainnet**: Required track for all protocol level changes.",
    "file_name": "files/hub-docs/network/0-overview.mdx",
    "meta_data": {
      "slug": "overview",
      "title": "Network",
      "description": "Learn about the different Flare networks, configuration, supported wallets, transaction format, smart contracts, consensus, and more.",
      "keywords": [
        "flare-network",
        "configuration",
        "blockchain",
        "data",
        "smart-contracts",
        "wallets"
      ]
    },
    "type": "answer"
  },
  {
    "content": "import Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport IconExternalLink from \"@theme/Icon/ExternalLink\";\nimport IconCopy from \"@theme/Icon/Copy\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport BlockNumCostonJS from \"!!raw-loader!/examples/developer-hub-javascript/block_number_coston.js\";\nimport BlockNumFlareJS from \"!!raw-loader!/examples/developer-hub-javascript/block_number_flare.js\";\nimport BlockNumCoston2JS from \"!!raw-loader!/examples/developer-hub-javascript/block_number_coston2.js\";\nimport BlockNumSongbirdJS from \"!!raw-loader!/examples/developer-hub-javascript/block_number_songbird.js\";\nimport BlockNumCostonPy from \"!!raw-loader!/examples/developer-hub-python/block_number_coston.py\";\nimport BlockNumFlarePy from \"!!raw-loader!/examples/developer-hub-python/block_number_flare.py\";\nimport BlockNumCoston2Py from \"!!raw-loader!/examples/developer-hub-python/block_number_coston2.py\";\nimport BlockNumSongbirdPy from \"!!raw-loader!/examples/developer-hub-python/block_number_songbird.py\";\nimport BlockNumCostonRs from \"!!raw-loader!/examples/developer-hub-rust/src/bin/block_number_coston.rs\";\nimport BlockNumFlareRs from \"!!raw-loader!/examples/developer-hub-rust/src/bin/block_number_flare.rs\";\nimport BlockNumCoston2Rs from \"!!raw-loader!/examples/developer-hub-rust/src/bin/block_number_coston2.rs\";\nimport BlockNumSongbirdRs from \"!!raw-loader!/examples/developer-hub-rust/src/bin/block_number_songbird.rs\";\nimport BlockNumCostonGo from \"!!raw-loader!/examples/developer-hub-go/coston/block_number.go\";\nimport BlockNumFlareGo from \"!!raw-loader!/examples/developer-hub-go/flare/block_number.go\";\nimport BlockNumCoston2Go from \"!!raw-loader!/examples/developer-hub-go/coston2/block_number.go\";\nimport BlockNumSongbirdGo from \"!!raw-loader!/examples/developer-hub-go/songbird/block_number.go\";\n\nFlare has four networks, each serving different purposes, so choosing the right one is crucial. All of these networks operate on a permissionless basis and are EVM compatible:\n\n- **Flare Mainnet.** The production network where all the action happens. Transactions cost real money here.\n\n- **Flare Testnet Coston2.** Test your applications without spending real money. This should be your first choice when developing applications.\n\n- **Songbird Canary-Network.** Experimental proving ground for Flare.\n\n- **Songbird Testnet Coston.** The testnet for Songbird Canary-Network.\n\nThe most common development tracks are:\n\n- **Flare Testnet Coston2 \u2192 Flare Mainnet**: Recommended track for application developers.\n\n- **Songbird Testnet Coston \u2192 Songbird Canary-Network \u2192 Flare Testnet Coston2 \u2192 Flare Mainnet**: Required track for all protocol level changes.",
    "file_name": "files/hub-docs/network/0-overview.mdx",
    "meta_data": {
      "slug": "overview",
      "title": "Network",
      "description": "Learn about the different Flare networks, configuration, supported wallets, transaction format, smart contracts, consensus, and more.",
      "keywords": [
        "flare-network",
        "configuration",
        "blockchain",
        "data",
        "smart-contracts",
        "wallets"
      ]
    },
    "type": "answer"
  },
  {
    "content": "import Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport IconExternalLink from \"@theme/Icon/ExternalLink\";\nimport IconCopy from \"@theme/Icon/Copy\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport BlockNumCostonJS from \"!!raw-loader!/examples/developer-hub-javascript/block_number_coston.js\";\nimport BlockNumFlareJS from \"!!raw-loader!/examples/developer-hub-javascript/block_number_flare.js\";\nimport BlockNumCoston2JS from \"!!raw-loader!/examples/developer-hub-javascript/block_number_coston2.js\";\nimport BlockNumSongbirdJS from \"!!raw-loader!/examples/developer-hub-javascript/block_number_songbird.js\";\nimport BlockNumCostonPy from \"!!raw-loader!/examples/developer-hub-python/block_number_coston.py\";\nimport BlockNumFlarePy from \"!!raw-loader!/examples/developer-hub-python/block_number_flare.py\";\nimport BlockNumCoston2Py from \"!!raw-loader!/examples/developer-hub-python/block_number_coston2.py\";\nimport BlockNumSongbirdPy from \"!!raw-loader!/examples/developer-hub-python/block_number_songbird.py\";\nimport BlockNumCostonRs from \"!!raw-loader!/examples/developer-hub-rust/src/bin/block_number_coston.rs\";\nimport BlockNumFlareRs from \"!!raw-loader!/examples/developer-hub-rust/src/bin/block_number_flare.rs\";\nimport BlockNumCoston2Rs from \"!!raw-loader!/examples/developer-hub-rust/src/bin/block_number_coston2.rs\";\nimport BlockNumSongbirdRs from \"!!raw-loader!/examples/developer-hub-rust/src/bin/block_number_songbird.rs\";\nimport BlockNumCostonGo from \"!!raw-loader!/examples/developer-hub-go/coston/block_number.go\";\nimport BlockNumFlareGo from \"!!raw-loader!/examples/developer-hub-go/flare/block_number.go\";\nimport BlockNumCoston2Go from \"!!raw-loader!/examples/developer-hub-go/coston2/block_number.go\";\nimport BlockNumSongbirdGo from \"!!raw-loader!/examples/developer-hub-go/songbird/block_number.go\";\n\nFlare has four networks, each serving different purposes, so choosing the right one is crucial. All of these networks operate on a permissionless basis and are EVM compatible:\n\n- **Flare Mainnet.** The production network where all the action happens. Transactions cost real money here.\n\n- **Flare Testnet Coston2.** Test your applications without spending real money. This should be your first choice when developing applications.\n\n- **Songbird Canary-Network.** Experimental proving ground for Flare.\n\n- **Songbird Testnet Coston.** The testnet for Songbird Canary-Network.\n\nThe most common development tracks are:\n\n- **Flare Testnet Coston2 \u2192 Flare Mainnet**: Recommended track for application developers.\n\n- **Songbird Testnet Coston \u2192 Songbird Canary-Network \u2192 Flare Testnet Coston2 \u2192 Flare Mainnet**: Required track for all protocol level changes.",
    "file_name": "files/hub-docs/network/0-overview.mdx",
    "meta_data": {
      "slug": "overview",
      "title": "Network",
      "description": "Learn about the different Flare networks, configuration, supported wallets, transaction format, smart contracts, consensus, and more.",
      "keywords": [
        "flare-network",
        "configuration",
        "blockchain",
        "data",
        "smart-contracts",
        "wallets"
      ]
    },
    "type": "answer"
  },
  {
    "content": "import Remix from \"@site/src/components/remix\";\nimport YoutubeEmbed from \"@site/src/components/youtube\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport HelloWorld from \"!!raw-loader!/examples/developer-hub-solidity/HelloWorld.sol\";\nimport OpenMetamask from \"/static/img/deploy-first-contract/0-open-metamask.png\";\nimport AddCoston2 from \"/static/img/deploy-first-contract/1-add-coston2.png\";\nimport ApproveCoston2 from \"/static/img/deploy-first-contract/2-approve-coston2.png\";\nimport SwitchNetwork from \"/static/img/deploy-first-contract/3-switch-networks.png\";\nimport CopyAddress from \"/static/img/deploy-first-contract/4-copy-address.png\";\nimport PasteAddress from \"/static/img/deploy-first-contract/5-paste-address.png\";\nimport AfterFaucetConfirmation from \"/static/img/deploy-first-contract/6-after-faucet-confirmation.png\";\nimport OpenSolidityCompiler from \"/static/img/deploy-first-contract/7-open-solidity-compiler.png\";\nimport SetEvmVersion from \"/static/img/deploy-first-contract/8-set-evm-version.png\";\nimport CompileContract from \"/static/img/deploy-first-contract/9-compile-contract.png\";\nimport DeployAndRunTxs from \"/static/img/deploy-first-contract/10-deploy-and-run-transactions.png\";\nimport SetInjectedProvider from \"/static/img/deploy-first-contract/11-set-injected-provider.png\";\nimport ConnectToMetamask from \"/static/img/deploy-first-contract/12-connect-to-metamask.png\";\nimport ConfirmPermissions from \"/static/img/deploy-first-contract/13-confirm-permissions.png\";\nimport MessageWhenDeploying from \"/static/img/deploy-first-contract/14-message-when-deploying.png\";\nimport ConfirmDeployInMetamask from \"/static/img/deploy-first-contract/15-confirm-deploy-in-metamask.png\";\nimport ClickOnMessage from \"/static/img/deploy-first-contract/16-click-on-message.png\";\nimport UpdateMessage from \"/static/img/deploy-first-contract/17-update-message.png\";\nimport ConfirmMetamaskUpdateMessage from \"/static/img/deploy-first-contract/18-confirm-metamask-update-message.png\";\nimport QueryUpdatedMessage from \"/static/img/deploy-first-contract/19-query-updated-message.png\";\n\nYou can deploy your first smart contract and run it in your browser without prior knowledge of Flare. This guide demonstrates how easy it is to develop smart contracts using the [Solidity language](https://soliditylang.org/), a [MetaMask wallet](https://metamask.io/) and the [Remix Development Environment](https://remix.ethereum.org/). All these tools are accessible in your browser for free, without requiring any sign-up.",
    "file_name": "files/hub-docs/network/1-getting-started.mdx",
    "meta_data": {
      "slug": "getting-started",
      "title": "Getting Started",
      "description": "Deploy a smart contract on Flare using your browser.",
      "keywords": [
        "solidity",
        "smart-contract",
        "metamask",
        "remix",
        "flare-network",
        "blockchain"
      ]
    },
    "type": "answer"
  },
  {
    "content": "import Remix from \"@site/src/components/remix\";\nimport YoutubeEmbed from \"@site/src/components/youtube\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport HelloWorld from \"!!raw-loader!/examples/developer-hub-solidity/HelloWorld.sol\";\nimport OpenMetamask from \"/static/img/deploy-first-contract/0-open-metamask.png\";\nimport AddCoston2 from \"/static/img/deploy-first-contract/1-add-coston2.png\";\nimport ApproveCoston2 from \"/static/img/deploy-first-contract/2-approve-coston2.png\";\nimport SwitchNetwork from \"/static/img/deploy-first-contract/3-switch-networks.png\";\nimport CopyAddress from \"/static/img/deploy-first-contract/4-copy-address.png\";\nimport PasteAddress from \"/static/img/deploy-first-contract/5-paste-address.png\";\nimport AfterFaucetConfirmation from \"/static/img/deploy-first-contract/6-after-faucet-confirmation.png\";\nimport OpenSolidityCompiler from \"/static/img/deploy-first-contract/7-open-solidity-compiler.png\";\nimport SetEvmVersion from \"/static/img/deploy-first-contract/8-set-evm-version.png\";\nimport CompileContract from \"/static/img/deploy-first-contract/9-compile-contract.png\";\nimport DeployAndRunTxs from \"/static/img/deploy-first-contract/10-deploy-and-run-transactions.png\";\nimport SetInjectedProvider from \"/static/img/deploy-first-contract/11-set-injected-provider.png\";\nimport ConnectToMetamask from \"/static/img/deploy-first-contract/12-connect-to-metamask.png\";\nimport ConfirmPermissions from \"/static/img/deploy-first-contract/13-confirm-permissions.png\";\nimport MessageWhenDeploying from \"/static/img/deploy-first-contract/14-message-when-deploying.png\";\nimport ConfirmDeployInMetamask from \"/static/img/deploy-first-contract/15-confirm-deploy-in-metamask.png\";\nimport ClickOnMessage from \"/static/img/deploy-first-contract/16-click-on-message.png\";\nimport UpdateMessage from \"/static/img/deploy-first-contract/17-update-message.png\";\nimport ConfirmMetamaskUpdateMessage from \"/static/img/deploy-first-contract/18-confirm-metamask-update-message.png\";\nimport QueryUpdatedMessage from \"/static/img/deploy-first-contract/19-query-updated-message.png\";\n\nYou can deploy your first smart contract and run it in your browser without prior knowledge of Flare. This guide demonstrates how easy it is to develop smart contracts using the [Solidity language](https://soliditylang.org/), a [MetaMask wallet](https://metamask.io/) and the [Remix Development Environment](https://remix.ethereum.org/). All these tools are accessible in your browser for free, without requiring any sign-up.",
    "file_name": "files/hub-docs/network/1-getting-started.mdx",
    "meta_data": {
      "slug": "getting-started",
      "title": "Getting Started",
      "description": "Deploy a smart contract on Flare using your browser.",
      "keywords": [
        "solidity",
        "smart-contract",
        "metamask",
        "remix",
        "flare-network",
        "blockchain"
      ]
    },
    "type": "answer"
  },
  {
    "content": "import Remix from \"@site/src/components/remix\";\nimport YoutubeEmbed from \"@site/src/components/youtube\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport HelloWorld from \"!!raw-loader!/examples/developer-hub-solidity/HelloWorld.sol\";\nimport OpenMetamask from \"/static/img/deploy-first-contract/0-open-metamask.png\";\nimport AddCoston2 from \"/static/img/deploy-first-contract/1-add-coston2.png\";\nimport ApproveCoston2 from \"/static/img/deploy-first-contract/2-approve-coston2.png\";\nimport SwitchNetwork from \"/static/img/deploy-first-contract/3-switch-networks.png\";\nimport CopyAddress from \"/static/img/deploy-first-contract/4-copy-address.png\";\nimport PasteAddress from \"/static/img/deploy-first-contract/5-paste-address.png\";\nimport AfterFaucetConfirmation from \"/static/img/deploy-first-contract/6-after-faucet-confirmation.png\";\nimport OpenSolidityCompiler from \"/static/img/deploy-first-contract/7-open-solidity-compiler.png\";\nimport SetEvmVersion from \"/static/img/deploy-first-contract/8-set-evm-version.png\";\nimport CompileContract from \"/static/img/deploy-first-contract/9-compile-contract.png\";\nimport DeployAndRunTxs from \"/static/img/deploy-first-contract/10-deploy-and-run-transactions.png\";\nimport SetInjectedProvider from \"/static/img/deploy-first-contract/11-set-injected-provider.png\";\nimport ConnectToMetamask from \"/static/img/deploy-first-contract/12-connect-to-metamask.png\";\nimport ConfirmPermissions from \"/static/img/deploy-first-contract/13-confirm-permissions.png\";\nimport MessageWhenDeploying from \"/static/img/deploy-first-contract/14-message-when-deploying.png\";\nimport ConfirmDeployInMetamask from \"/static/img/deploy-first-contract/15-confirm-deploy-in-metamask.png\";\nimport ClickOnMessage from \"/static/img/deploy-first-contract/16-click-on-message.png\";\nimport UpdateMessage from \"/static/img/deploy-first-contract/17-update-message.png\";\nimport ConfirmMetamaskUpdateMessage from \"/static/img/deploy-first-contract/18-confirm-metamask-update-message.png\";\nimport QueryUpdatedMessage from \"/static/img/deploy-first-contract/19-query-updated-message.png\";\n\nYou can deploy your first smart contract and run it in your browser without prior knowledge of Flare. This guide demonstrates how easy it is to develop smart contracts using the [Solidity language](https://soliditylang.org/), a [MetaMask wallet](https://metamask.io/) and the [Remix Development Environment](https://remix.ethereum.org/). All these tools are accessible in your browser for free, without requiring any sign-up.",
    "file_name": "files/hub-docs/network/1-getting-started.mdx",
    "meta_data": {
      "slug": "getting-started",
      "title": "Getting Started",
      "description": "Deploy a smart contract on Flare using your browser.",
      "keywords": [
        "solidity",
        "smart-contract",
        "metamask",
        "remix",
        "flare-network",
        "blockchain"
      ]
    },
    "type": "answer"
  },
  {
    "content": "import Remix from \"@site/src/components/remix\";\nimport YoutubeEmbed from \"@site/src/components/youtube\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport HelloWorld from \"!!raw-loader!/examples/developer-hub-solidity/HelloWorld.sol\";\nimport OpenMetamask from \"/static/img/deploy-first-contract/0-open-metamask.png\";\nimport AddCoston2 from \"/static/img/deploy-first-contract/1-add-coston2.png\";\nimport ApproveCoston2 from \"/static/img/deploy-first-contract/2-approve-coston2.png\";\nimport SwitchNetwork from \"/static/img/deploy-first-contract/3-switch-networks.png\";\nimport CopyAddress from \"/static/img/deploy-first-contract/4-copy-address.png\";\nimport PasteAddress from \"/static/img/deploy-first-contract/5-paste-address.png\";\nimport AfterFaucetConfirmation from \"/static/img/deploy-first-contract/6-after-faucet-confirmation.png\";\nimport OpenSolidityCompiler from \"/static/img/deploy-first-contract/7-open-solidity-compiler.png\";\nimport SetEvmVersion from \"/static/img/deploy-first-contract/8-set-evm-version.png\";\nimport CompileContract from \"/static/img/deploy-first-contract/9-compile-contract.png\";\nimport DeployAndRunTxs from \"/static/img/deploy-first-contract/10-deploy-and-run-transactions.png\";\nimport SetInjectedProvider from \"/static/img/deploy-first-contract/11-set-injected-provider.png\";\nimport ConnectToMetamask from \"/static/img/deploy-first-contract/12-connect-to-metamask.png\";\nimport ConfirmPermissions from \"/static/img/deploy-first-contract/13-confirm-permissions.png\";\nimport MessageWhenDeploying from \"/static/img/deploy-first-contract/14-message-when-deploying.png\";\nimport ConfirmDeployInMetamask from \"/static/img/deploy-first-contract/15-confirm-deploy-in-metamask.png\";\nimport ClickOnMessage from \"/static/img/deploy-first-contract/16-click-on-message.png\";\nimport UpdateMessage from \"/static/img/deploy-first-contract/17-update-message.png\";\nimport ConfirmMetamaskUpdateMessage from \"/static/img/deploy-first-contract/18-confirm-metamask-update-message.png\";\nimport QueryUpdatedMessage from \"/static/img/deploy-first-contract/19-query-updated-message.png\";\n\nYou can deploy your first smart contract and run it in your browser without prior knowledge of Flare. This guide demonstrates how easy it is to develop smart contracts using the [Solidity language](https://soliditylang.org/), a [MetaMask wallet](https://metamask.io/) and the [Remix Development Environment](https://remix.ethereum.org/). All these tools are accessible in your browser for free, without requiring any sign-up.",
    "file_name": "files/hub-docs/network/1-getting-started.mdx",
    "meta_data": {
      "slug": "getting-started",
      "title": "Getting Started",
      "description": "Deploy a smart contract on Flare using your browser.",
      "keywords": [
        "solidity",
        "smart-contract",
        "metamask",
        "remix",
        "flare-network",
        "blockchain"
      ]
    },
    "type": "answer"
  },
  {
    "content": "import ThemedImage from \"@theme/ThemedImage\";\nimport useBaseUrl from \"@docusaurus/useBaseUrl\";\nimport AccessGranted from \"/static/img/verifiable-ai-hackathon/access-granted.png\";\nimport ChooseTemplate from \"/static/img/verifiable-ai-hackathon/choose-template.png\";\nimport GeminiKey from \"/static/img/verifiable-ai-hackathon/gemini-key.png\";\nimport OnboardingChecklist from \"@site/src/components/hackathon/OnboardingChecklist\";\nimport CreateKey from \"/static/img/verifiable-ai-hackathon/create-key.png\";\nimport PackageSetting from \"/static/img/verifiable-ai-hackathon/package-setting.png\";\nimport PackageView from \"/static/img/verifiable-ai-hackathon/package-view.png\";\nimport ChangeVisibility from \"/static/img/verifiable-ai-hackathon/change-visibility.png\";\n\n# Onboarding\n\nWelcome to the **Verifiable AI Hackathon**! \ud83c\udf89\n\nThis guide walks you through the **four-step setup** to ensure you have the necessary access and tools to start building.\n\n<OnboardingChecklist />\n\nimport ThemedImage from \"@theme/ThemedImage\";\nimport useBaseUrl from \"@docusaurus/useBaseUrl\";\nimport AccessGranted from \"/static/img/verifiable-ai-hackathon/access-granted.png\";\nimport ChooseTemplate from \"/static/img/verifiable-ai-hackathon/choose-template.png\";\nimport GeminiKey from \"/static/img/verifiable-ai-hackathon/gemini-key.png\";\nimport OnboardingChecklist from \"@site/src/components/hackathon/OnboardingChecklist\";\nimport CreateKey from \"/static/img/verifiable-ai-hackathon/create-key.png\";\nimport PackageSetting from \"/static/img/verifiable-ai-hackathon/package-setting.png\";\nimport PackageView from \"/static/img/verifiable-ai-hackathon/package-view.png\";\nimport ChangeVisibility from \"/static/img/verifiable-ai-hackathon/change-visibility.png\";\n\n# Onboarding\n\nWelcome to the **Verifiable AI Hackathon**! \ud83c\udf89\n\nThis guide walks you through the **four-step setup** to ensure you have the necessary access and tools to start building.\n\n<OnboardingChecklist />\n\nimport ThemedImage from \"@theme/ThemedImage\";\nimport useBaseUrl from \"@docusaurus/useBaseUrl\";\nimport AccessGranted from \"/static/img/verifiable-ai-hackathon/access-granted.png\";\nimport ChooseTemplate from \"/static/img/verifiable-ai-hackathon/choose-template.png\";\nimport GeminiKey from \"/static/img/verifiable-ai-hackathon/gemini-key.png\";\nimport OnboardingChecklist from \"@site/src/components/hackathon/OnboardingChecklist\";\nimport CreateKey from \"/static/img/verifiable-ai-hackathon/create-key.png\";\nimport PackageSetting from \"/static/img/verifiable-ai-hackathon/package-setting.png\";\nimport PackageView from \"/static/img/verifiable-ai-hackathon/package-view.png\";\nimport ChangeVisibility from \"/static/img/verifiable-ai-hackathon/change-visibility.png\";\n\n# Onboarding\n\nWelcome to the **Verifiable AI Hackathon**! \ud83c\udf89\n\nThis guide walks you through the **four-step setup** to ensure you have the necessary access and tools to start building.\n\n<OnboardingChecklist />\n\nimport ThemedImage from \"@theme/ThemedImage\";\nimport useBaseUrl from \"@docusaurus/useBaseUrl\";\nimport AccessGranted from \"/static/img/verifiable-ai-hackathon/access-granted.png\";\nimport ChooseTemplate from \"/static/img/verifiable-ai-hackathon/choose-template.png\";\nimport GeminiKey from \"/static/img/verifiable-ai-hackathon/gemini-key.png\";\nimport OnboardingChecklist from \"@site/src/components/hackathon/OnboardingChecklist\";\nimport CreateKey from \"/static/img/verifiable-ai-hackathon/create-key.png\";\nimport PackageSetting from \"/static/img/verifiable-ai-hackathon/package-setting.png\";\nimport PackageView from \"/static/img/verifiable-ai-hackathon/package-view.png\";\nimport ChangeVisibility from \"/static/img/verifiable-ai-hackathon/change-visibility.png\";\n\n# Onboarding\n\nWelcome to the **Verifiable AI Hackathon**! \ud83c\udf89\n\nThis guide walks you through the **four-step setup** to ensure you have the necessary access and tools to start building.\n\n<OnboardingChecklist />\n\nimport ThemedImage from \"@theme/ThemedImage\";\nimport useBaseUrl from \"@docusaurus/useBaseUrl\";\nimport AccessGranted from \"/static/img/verifiable-ai-hackathon/access-granted.png\";\nimport ChooseTemplate from \"/static/img/verifiable-ai-hackathon/choose-template.png\";\nimport GeminiKey from \"/static/img/verifiable-ai-hackathon/gemini-key.png\";\nimport OnboardingChecklist from \"@site/src/components/hackathon/OnboardingChecklist\";\nimport CreateKey from \"/static/img/verifiable-ai-hackathon/create-key.png\";\nimport PackageSetting from \"/static/img/verifiable-ai-hackathon/package-setting.png\";\nimport PackageView from \"/static/img/verifiable-ai-hackathon/package-view.png\";\nimport ChangeVisibility from \"/static/img/verifiable-ai-hackathon/change-visibility.png\";\n\n# Onboarding\n\nWelcome to the **Verifiable AI Hackathon**! \ud83c\udf89\n\nThis guide walks you through the **four-step setup** to ensure you have the necessary access and tools to start building.\n\n<OnboardingChecklist />",
    "file_name": "files/hub-docs/hackathon/0-onboarding.mdx",
    "meta_data": {
      "sidebar_position": 1,
      "unlisted": false,
      "slug": "onboarding",
      "title": "Onboarding",
      "description": "Step-by-step guide for setting up infrastructure, credentials, and cloud instances for the Verifiable AI Hackathon.",
      "keywords": [
        "flare",
        "ai",
        "confidential-compute",
        "hackathon",
        "google-cloud",
        "onboarding"
      ]
    },
    "type": "answer"
  },
  {
    "content": "import ThemedImage from \"@theme/ThemedImage\";\nimport useBaseUrl from \"@docusaurus/useBaseUrl\";\nimport AccessGranted from \"/static/img/verifiable-ai-hackathon/access-granted.png\";\nimport ChooseTemplate from \"/static/img/verifiable-ai-hackathon/choose-template.png\";\nimport GeminiKey from \"/static/img/verifiable-ai-hackathon/gemini-key.png\";\nimport OnboardingChecklist from \"@site/src/components/hackathon/OnboardingChecklist\";\nimport CreateKey from \"/static/img/verifiable-ai-hackathon/create-key.png\";\nimport PackageSetting from \"/static/img/verifiable-ai-hackathon/package-setting.png\";\nimport PackageView from \"/static/img/verifiable-ai-hackathon/package-view.png\";\nimport ChangeVisibility from \"/static/img/verifiable-ai-hackathon/change-visibility.png\";\n\n# Onboarding\n\nWelcome to the **Verifiable AI Hackathon**! \ud83c\udf89\n\nThis guide walks you through the **four-step setup** to ensure you have the necessary access and tools to start building.\n\n<OnboardingChecklist />\n\nimport ThemedImage from \"@theme/ThemedImage\";\nimport useBaseUrl from \"@docusaurus/useBaseUrl\";\nimport AccessGranted from \"/static/img/verifiable-ai-hackathon/access-granted.png\";\nimport ChooseTemplate from \"/static/img/verifiable-ai-hackathon/choose-template.png\";\nimport GeminiKey from \"/static/img/verifiable-ai-hackathon/gemini-key.png\";\nimport OnboardingChecklist from \"@site/src/components/hackathon/OnboardingChecklist\";\nimport CreateKey from \"/static/img/verifiable-ai-hackathon/create-key.png\";\nimport PackageSetting from \"/static/img/verifiable-ai-hackathon/package-setting.png\";\nimport PackageView from \"/static/img/verifiable-ai-hackathon/package-view.png\";\nimport ChangeVisibility from \"/static/img/verifiable-ai-hackathon/change-visibility.png\";\n\n# Onboarding\n\nWelcome to the **Verifiable AI Hackathon**! \ud83c\udf89\n\nThis guide walks you through the **four-step setup** to ensure you have the necessary access and tools to start building.\n\n<OnboardingChecklist />\n\nimport ThemedImage from \"@theme/ThemedImage\";\nimport useBaseUrl from \"@docusaurus/useBaseUrl\";\nimport AccessGranted from \"/static/img/verifiable-ai-hackathon/access-granted.png\";\nimport ChooseTemplate from \"/static/img/verifiable-ai-hackathon/choose-template.png\";\nimport GeminiKey from \"/static/img/verifiable-ai-hackathon/gemini-key.png\";\nimport OnboardingChecklist from \"@site/src/components/hackathon/OnboardingChecklist\";\nimport CreateKey from \"/static/img/verifiable-ai-hackathon/create-key.png\";\nimport PackageSetting from \"/static/img/verifiable-ai-hackathon/package-setting.png\";\nimport PackageView from \"/static/img/verifiable-ai-hackathon/package-view.png\";\nimport ChangeVisibility from \"/static/img/verifiable-ai-hackathon/change-visibility.png\";\n\n# Onboarding\n\nWelcome to the **Verifiable AI Hackathon**! \ud83c\udf89\n\nThis guide walks you through the **four-step setup** to ensure you have the necessary access and tools to start building.\n\n<OnboardingChecklist />",
    "file_name": "files/hub-docs/hackathon/0-onboarding.mdx",
    "meta_data": {
      "sidebar_position": 1,
      "unlisted": false,
      "slug": "onboarding",
      "title": "Onboarding",
      "description": "Step-by-step guide for setting up infrastructure, credentials, and cloud instances for the Verifiable AI Hackathon.",
      "keywords": [
        "flare",
        "ai",
        "confidential-compute",
        "hackathon",
        "google-cloud",
        "onboarding"
      ]
    },
    "type": "answer"
  },
  {
    "content": "import ConfidentialVMBuilder from \"@site/src/components/hackathon/ConfidentialVMBuilder\";\n\nReference for commands you will encounter when interacting with Confidential VMs.\n\nimport ConfidentialVMBuilder from \"@site/src/components/hackathon/ConfidentialVMBuilder\";\n\nReference for commands you will encounter when interacting with Confidential VMs.\n\nimport ConfidentialVMBuilder from \"@site/src/components/hackathon/ConfidentialVMBuilder\";\n\nReference for commands you will encounter when interacting with Confidential VMs.\n\nimport ConfidentialVMBuilder from \"@site/src/components/hackathon/ConfidentialVMBuilder\";\n\nReference for commands you will encounter when interacting with Confidential VMs.\n\nimport ConfidentialVMBuilder from \"@site/src/components/hackathon/ConfidentialVMBuilder\";\n\nReference for commands you will encounter when interacting with Confidential VMs.\n\nimport ConfidentialVMBuilder from \"@site/src/components/hackathon/ConfidentialVMBuilder\";\n\nReference for commands you will encounter when interacting with Confidential VMs.\n\nimport ConfidentialVMBuilder from \"@site/src/components/hackathon/ConfidentialVMBuilder\";\n\nReference for commands you will encounter when interacting with Confidential VMs.\n\nimport ConfidentialVMBuilder from \"@site/src/components/hackathon/ConfidentialVMBuilder\";\n\nReference for commands you will encounter when interacting with Confidential VMs.",
    "file_name": "files/hub-docs/hackathon/1-cookbook.mdx",
    "meta_data": {
      "sidebar_position": 2,
      "unlisted": false,
      "title": "Cookbook",
      "description": "Cookbook commands for managing Confidential VMs.",
      "keywords": [
        "flare",
        "ai",
        "confidential-compute",
        "hackathon",
        "google-cloud",
        "onboarding"
      ]
    },
    "type": "answer"
  },
  {
    "content": "| **Auditor** | **Date**  | **Report**                                                                                                                                                             |\n| ----------- | --------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Coinspect   | Feb 2025  | [FTSOv2 Custom Feeds](@site/static/pdf/audits/20250205-Coinspect-SmartContractAudit-Flare-FTSOv2CustomFeedsDiffReview-v240210.pdf)                                     |\n| Coinspect   | Jan 2025  | [Smart Contract Preregistration](@site/static/pdf/audits/20250101-Coinspect-SmartContractAudit-Flare-Pre-Register&FTSOManagement-v250109.pdf)                          |\n| Coinspect   | Dec 2024  | [FAssets Smart Contract Audit V2 Updates](@site/static/pdf/audits/20241215-Coinspect-SmartContractAudit-Flare-FAssetV2Updates-v241217.pdf)                             |\n| FYEO        | Oct 2024  | [FlareDA Layer (FTSO & FDC)](@site/static/pdf/audits/20241001-FLARE-SecurityCodeReviewFLAREDataAvailabilityv1.0_Public.pdf)                                            |\n| Coinspect   | Oct 2024  | [Verifier servers and FDC updates](@site/static/pdf/audits/20241001-Coinspect-SourceCodeAudit-Flare-FDCv2-v250113.pdf)                                                 |\n| Coinspect   | Sep 2024  | [FAssets Smart Contract Audit](@site/static/pdf/audits/20240901-Coinspect-SmartContractAudit-Flare-FassetUpdate-v240910.pdf)                                           |\n| Coinspect   | Aug 2024  | [FDC Client](@site/static/pdf/audits/20240801-Coinspect-Source_Code_Audit-Flare-FDCv1-v241004.pdf)                                                                     |\n| Coinspect   | June 2024 | [rNat (rFLR) smart contracts](@site/static/pdf/audits/20240601-Coinspect-SmartContractSecurityReview-Flare-RNatContracts-v240701.pdf)                                  |\n| FYEO        | June 2024 | [Lowering gas limit for Songbird](@site/static/pdf/audits/20240601-FYEO-Flare-Ongoing_Songbird_June_20th_1.0_Public.docx.pdf)                                          |\n| FYEO        | June 2024 | [Flare upgrade to Avalanche 1.9.0](@site/static/pdf/audits/20240601-FYEO-Flare-Ongoing_Songbird_June_10th_1.0_Public.pdf)                                              |\n| FYEO        | May 2024  | [Songbird codebase integration into Flare](@site/static/pdf/audits/20240501-FYEO-FlareOngoingSongbird1.0_Public.pdf)                                                   |\n| Coinspect   | May 2024  | [Voter Registry Fix](@site/static/pdf/audits/20240501-Coinspect-Flare-SecurityReview-VoterRegistryFix-v240603.pdf)                                                     |\n| Halborn     | May 2024  | [FTSO fast updates implementation](@site/static/pdf/audits/20240501-Halborn-FastUpdatesAudit.pdf)                                                                      |\n| Halborn     | May 2024  | [FTSO Fast updates protocol](@site/static/pdf/audits/20240501-Halborn-FTSOFastUpdatesprotocolAudit.pdf)                                                                |\n| Coinspect   | Apr 2024  | [Flare Smart Contract V2 Audit 1](@site/static/pdf/audits/20230401-Coinspect-Flare-SourceCodeSecurityReview-SmartContractsV2-v240515.pdf)                              |\n| Coinspect   | Apr 2024  | [FTSO V2 Fast Updates](@site/static/pdf/audits/20240401-Coinspect-Flare-SourceCodeSecurityReview-FastUpdates-v240612.pdf)                                              |\n| Coinspect   | Mar 2024  | [Transaction Verifier](@site/static/pdf/audits/20240301-Coinspect-Flare-SourceCodeSecurityReview-TransactionVerifier-v240516.pdf)                                      |\n| Coinspect   | Jan 2024  | [FTSO V2 Scaling](@site/static/pdf/audits/20240101-Coinspect-Flare-SourceCodeSecurityReview-FTSOScaling-v240515.pdf)                                                   |\n| Coinspect   | Jan 2024  | [Flare Systems Client (Top level client)](@site/static/pdf/audits/20240101-Coinspect-Flare-SourceCodeSecurityReview-TopLevelClient-v240515.pdf)                        |\n| Coinspect   | Jan 2024  | [CChain Indexer](@site/static/pdf/audits/20240101-Coinspect-Flare-SourceCodeSecurityReview-CChainIndexer-v240409.pdf)                                                  |\n| Coinspect   | Jan 2024  | [Attestation Suite](@site/static/pdf/audits/20240101-Coinspect-Smart_Contract_Review-Flare_Attestation_Suite-v240220.pdf)                                              |\n| Coinspect   | Dec 2023  | [FAsset Liquidator](@site/static/pdf/audits/20231207-Coinspect-Flare-Smart_Contract_Review-FAsset_Liquidator-v231207.pdf)                                              |\n| Coinspect   | Nov 2023  | [Hex Wrapped Tokens](@site/static/pdf/audits/20231101-Coinspect-Flare-SmartContractAudit-HexWrappedTokens-v231211.pdf)                                                 |\n| Coinspect   | Oct 2023  | [FAsset V2 Bots](@site/static/pdf/audits/20231001-Coinspect-Flare-Source_Code_Review-FAsset_Bots-v240220.pdf)                                                          |\n| Coinspect   | Oct 2023  | [Staking P2 Off-chain Services](@site/static/pdf/audits/20231001-Coinspect-Flare-Source_Code_Review-Staking_P2-Offchain_Services-v240220.pdf)                          |\n| Coinspect   | Sep 2023  | [FAsset V2](@site/static/pdf/audits/20230901-Coinspect-Flare-Smart_Contract_Review-FAsset_V2-v240220.pdf)                                                              |\n| Coinspect   | Sep 2023  | [Staking P2](@site/static/pdf/audits/20230901-Coinspect-Flare-Smart_Contract_Review-StakingP2-v240220.pdf)                                                             |\n| FYEO        | Feb 2023  | [Golang Validator Flare Network](@site/static/pdf/audits/20230201-FlareNetworksLtd.-SecureCodeReviewof_Golang_Validator_on_the_Flare_Network_v1.0_February_Public.pdf) |\n| Coinspect   | Jan 2023  | [FTSO V1 Hybrid reward band](@site/static/pdf/audits/20230101-Coinspect-SmartContractAudit-FlareHybridBandRewardv230220.pdf)                                           |\n| FYEO        | Dec 2022  | [Validator Codebase V3](@site/static/pdf/audits/20221201-FlareNetworksLtd.-Dec2022-SecureCodeReviewofSoliditySmartContractsontheFlareNetworkv1.0_Public.pdf)           |\n| FYEO        | Dec 2022  | [Smart Contracts V1 Audit 3](@site/static/pdf/audits/20221201-FlareNetworksLtd.-Dec2022-SecureCodeReviewofSoliditySmartContractsontheFlareNetworkv1.0_Public.pdf)      |\n| Coinspect   | Dec 2022  | [Flare TDE Updates](@site/static/pdf/audits/20221201-Coinspect-SmartContractAudit-FlareTDEUpdates-v221220.pdf)                                                         |\n| FYEO        | Oct 2022  | [Smart Contract V1 Audit 2](@site/static/pdf/audits/20221001-Flare_Networks_Ltd.-Secure_Code_Review_of_Solidity_Smart_Contracts_on_the_Flare_Network_v1.0_Public.pdf)  |\n| Coinspect   | Oct 2022  | [Flare Airdrop](@site/static/pdf/audits/20221001-Coinspect-Smart_Contract_Audit-Flare_Airdrop_Update-v221109.pdf)                                                      |\n| FYEO        | Sep 2022  | [Validator Codebase V2](@site/static/pdf/audits/20220901-Flare_Networks_Ltd.-Secure_Code_Review_of_the_Flare_Validator_V2-Report_v1.0_Public.pdf)                      |\n| FYEO        | Sep 2022  | [Smart Contracts V1 Audit 1](@site/static/pdf/audits/20220901-Flare_Networks_Ltd.-Secure_Code_Review_of_Solidity_Contracts_on_the_Flare_Network_v1.0_public.pdf)       |\n| FYEO        | Aug 2022  | [Validator Codebase](@site/static/pdf/audits/20220801-Flare_Networks_Ltd.-Secure_Code_Review_of_the_Flare_Network's_Validator_Codebase_v1.0_Public.pdf)                |\n| Coinspect   | Jun 2022  | [Multi Chain Library](@site/static/pdf/audits/20220601-Coinspect-Flare-Source_Code_Review-Multichain_Client_Library-v240220.pdf)                                       |\n| Coinspect   | Jun 2022  | [Attestation Client V1](@site/static/pdf/audits/20220601-Coinspect-Flare-Source_Code_Review-Attestation_Client-v240220.pdf)                                            |\n| Coinspect   | Jun 2022  | [FAssets V1](@site/static/pdf/audits/20220601-Coinspect_Smart_Contract_Audit_fAsset_v220829.pdf)                                                                       |\n| Coinspect   | Jun 2022  | [Smart Contracts](@site/static/pdf/audits/20220601-Coinspect-Smart_Contract_Audit-Flare_Network_Launch.pdf)                                                            |\n| Coinspect   | Mar 2022  | [Flare Smart Contracts V1 Audit 2](@site/static/pdf/audits/20220201-Coinspect-Smart_Contract_Audit-Flare.pdf)                                                          |\n| Coinspect   | Jul 2021  | [Flare Smart Contracts V1 Audit 1](@site/static/pdf/audits/20210701-Coinspect-Smart_Contract_Audit-Flare.pdf)                                                          |",
    "meta_data": {
      "slug": "audits",
      "title": "Audits",
      "description": "Security audits of the Flare Network and its components.",
      "keywords": [
        "audits",
        "security",
        "smart-contracts",
        "flare-network"
      ],
      "hide_table_of_contents": true
    },
    "file_name": "files/hub-docs/support/audits.mdx",
    "type": "answer"
  },
  {
    "content": "import SetEvmVersionRemix from \"/static/img/set-evm-version-remix.png\";\n\n### Why am I getting `invalid opcode: opcode 0x5f not defined`?\n\nFlare supports EVM versions up to London, which does not support the `PUSH0` opcode, leading to this error. To fix this:\n\n- **Using Remix:** Set EVM version to `london` in the **Advanced Configurations** section of the **Solidity Compiler** tab:\n\n  <img src={SetEvmVersionRemix} style={{ width: 300 }} />\n\n- **Using Hardhat or Foundry:** Set EVM version to `london` in [hardhat.config.ts](https://github.com/flare-foundation/flare-hardhat-starter/blob/master/hardhat.config.ts#L34) or [foundry.toml](https://github.com/flare-foundation/flare-foundry-starter/blob/master/foundry.toml).\n\n- **Using Standard Solidity JSON:** Set `evmVersion` to `london`:\n\n  ```json\n  {\n    \"settings\": {\n      \"optimizer\": {\n        /* ... */\n      },\n      \"evmVersion\": \"london\"\n    }\n  }\n  ```\n\n- **Using `solc` CLI:** Set `--evm-version` to `london`:\n\n  ```bash\n  solc --evm-version london <args>\n  ```\n\n### Where can I get Flare testnet tokens?\n\nYou can get:\n\n- Testnet C2FLR from the [Coston2 Faucet](https://faucet.flare.network/coston2).\n\n- Testnet CFLR from the [Coston Faucet](https://faucet.flare.network/coston).\n\nTo understand the difference between Coston and Coston2, see the [Network Configuration](/network/overview#configuration) page.\n\n### I have a project I would like to build on Flare. Can I get a grant?\n\nYes! Grants from the Flare Foundation are designed to support innovative and impactful projects in order to accelerate the growth of the Flare ecosystem. Whether you're an independent innovator or part of a larger team, if you believe that you can make valuable contributions to the Flare ecosystem, we'd like to hear from you.\n\nLearn more about [Grants](https://flare.network/grants/).\n\n### Where can I get technical support?\n\nConnect with the rapidly growing community of developers building on Flare.\n\n- Engage with Flare's developer community on [Telegram](https://t.me/FlareNetwork).\n\n- Contribute to Flare's open-source codebase on [GitHub](https://github.com/flare-foundation/).\n\n- Join the community on [Discord](https://discord.com/invite/flarenetwork).\n\n### Where can I learn about Flare-specific terminology?\n\nLearn more about the terminology used in the Flare ecosystem on the [Terminology](/support/terminology) page.",
    "meta_data": {
      "slug": "faqs",
      "title": "FAQs",
      "description": "Frequently asked questions when building on Flare.",
      "keywords": [
        "faq",
        "frequently-asked-questions",
        "flare-network",
        "support"
      ]
    },
    "file_name": "files/hub-docs/support/faqs.mdx",
    "type": "answer"
  },
  {
    "content": "## Account\n\nAn account is a record in the Flare ledger that holds data and facilitates the sending and receiving of tokens. Each account is identified by a unique address derived from a public key. An account can be either an [externally owned account (EOA)](#externally-owned-account-eoa) or a [smart contract](#smart-contract).\n\n## Account\n\nAn account is a record in the Flare ledger that holds data and facilitates the sending and receiving of tokens. Each account is identified by a unique address derived from a public key. An account can be either an [externally owned account (EOA)](#externally-owned-account-eoa) or a [smart contract](#smart-contract).\n\n## Account\n\nAn account is a record in the Flare ledger that holds data and facilitates the sending and receiving of tokens. Each account is identified by a unique address derived from a public key. An account can be either an [externally owned account (EOA)](#externally-owned-account-eoa) or a [smart contract](#smart-contract).\n\n## Account\n\nAn account is a record in the Flare ledger that holds data and facilitates the sending and receiving of tokens. Each account is identified by a unique address derived from a public key. An account can be either an [externally owned account (EOA)](#externally-owned-account-eoa) or a [smart contract](#smart-contract).\n\n## Account\n\nAn account is a record in the Flare ledger that holds data and facilitates the sending and receiving of tokens. Each account is identified by a unique address derived from a public key. An account can be either an [externally owned account (EOA)](#externally-owned-account-eoa) or a [smart contract](#smart-contract).\n\n## Account\n\nAn account is a record in the Flare ledger that holds data and facilitates the sending and receiving of tokens. Each account is identified by a unique address derived from a public key. An account can be either an [externally owned account (EOA)](#externally-owned-account-eoa) or a [smart contract](#smart-contract).\n\n## Account\n\nAn account is a record in the Flare ledger that holds data and facilitates the sending and receiving of tokens. Each account is identified by a unique address derived from a public key. An account can be either an [externally owned account (EOA)](#externally-owned-account-eoa) or a [smart contract](#smart-contract).\n\n## Account\n\nAn account is a record in the Flare ledger that holds data and facilitates the sending and receiving of tokens. Each account is identified by a unique address derived from a public key. An account can be either an [externally owned account (EOA)](#externally-owned-account-eoa) or a [smart contract](#smart-contract).\n\n## Account\n\nAn account is a record in the Flare ledger that holds data and facilitates the sending and receiving of tokens. Each account is identified by a unique address derived from a public key. An account can be either an [externally owned account (EOA)](#externally-owned-account-eoa) or a [smart contract](#smart-contract).\n\n## Account\n\nAn account is a record in the Flare ledger that holds data and facilitates the sending and receiving of tokens. Each account is identified by a unique address derived from a public key. An account can be either an [externally owned account (EOA)](#externally-owned-account-eoa) or a [smart contract](#smart-contract).\n\n## Account\n\nAn account is a record in the Flare ledger that holds data and facilitates the sending and receiving of tokens. Each account is identified by a unique address derived from a public key. An account can be either an [externally owned account (EOA)](#externally-owned-account-eoa) or a [smart contract](#smart-contract).\n\n## Account\n\nAn account is a record in the Flare ledger that holds data and facilitates the sending and receiving of tokens. Each account is identified by a unique address derived from a public key. An account can be either an [externally owned account (EOA)](#externally-owned-account-eoa) or a [smart contract](#smart-contract).\n\n## Account\n\nAn account is a record in the Flare ledger that holds data and facilitates the sending and receiving of tokens. Each account is identified by a unique address derived from a public key. An account can be either an [externally owned account (EOA)](#externally-owned-account-eoa) or a [smart contract](#smart-contract).\n\n## Account\n\nAn account is a record in the Flare ledger that holds data and facilitates the sending and receiving of tokens. Each account is identified by a unique address derived from a public key. An account can be either an [externally owned account (EOA)](#externally-owned-account-eoa) or a [smart contract](#smart-contract).\n\n## Account\n\nAn account is a record in the Flare ledger that holds data and facilitates the sending and receiving of tokens. Each account is identified by a unique address derived from a public key. An account can be either an [externally owned account (EOA)](#externally-owned-account-eoa) or a [smart contract](#smart-contract).",
    "file_name": "files/hub-docs/support/terminology.mdx",
    "meta_data": {
      "slug": "terminology",
      "title": "Terminology",
      "description": "Definitions of key terms used in the Flare network.",
      "keywords": [
        "terminology",
        "flare-network",
        "definitions"
      ]
    },
    "type": "answer"
  },
  {
    "content": "## Account\n\nAn account is a record in the Flare ledger that holds data and facilitates the sending and receiving of tokens. Each account is identified by a unique address derived from a public key. An account can be either an [externally owned account (EOA)](#externally-owned-account-eoa) or a [smart contract](#smart-contract).\n\n## Account\n\nAn account is a record in the Flare ledger that holds data and facilitates the sending and receiving of tokens. Each account is identified by a unique address derived from a public key. An account can be either an [externally owned account (EOA)](#externally-owned-account-eoa) or a [smart contract](#smart-contract).\n\n## Account\n\nAn account is a record in the Flare ledger that holds data and facilitates the sending and receiving of tokens. Each account is identified by a unique address derived from a public key. An account can be either an [externally owned account (EOA)](#externally-owned-account-eoa) or a [smart contract](#smart-contract).\n\n## Account\n\nAn account is a record in the Flare ledger that holds data and facilitates the sending and receiving of tokens. Each account is identified by a unique address derived from a public key. An account can be either an [externally owned account (EOA)](#externally-owned-account-eoa) or a [smart contract](#smart-contract).\n\n## Account\n\nAn account is a record in the Flare ledger that holds data and facilitates the sending and receiving of tokens. Each account is identified by a unique address derived from a public key. An account can be either an [externally owned account (EOA)](#externally-owned-account-eoa) or a [smart contract](#smart-contract).\n\n## Account\n\nAn account is a record in the Flare ledger that holds data and facilitates the sending and receiving of tokens. Each account is identified by a unique address derived from a public key. An account can be either an [externally owned account (EOA)](#externally-owned-account-eoa) or a [smart contract](#smart-contract).\n\n## Account\n\nAn account is a record in the Flare ledger that holds data and facilitates the sending and receiving of tokens. Each account is identified by a unique address derived from a public key. An account can be either an [externally owned account (EOA)](#externally-owned-account-eoa) or a [smart contract](#smart-contract).",
    "file_name": "files/hub-docs/support/terminology.mdx",
    "meta_data": {
      "slug": "terminology",
      "title": "Terminology",
      "description": "Definitions of key terms used in the Flare network.",
      "keywords": [
        "terminology",
        "flare-network",
        "definitions"
      ]
    },
    "type": "answer"
  },
  {
    "content": "import WhitepapersGrid from \"@site/src/components/WhitepapersGrid\";\n\nExplore Flare's whitepapers, research, and analytics to gain deeper insights into its technology.\n\n<WhitepapersGrid />",
    "meta_data": {
      "slug": "whitepapers",
      "title": "Whitepapers",
      "description": "Explore Flare's whitepapers, research, and analytics to gain deeper insights into its technology.",
      "keywords": [
        "whitepaper",
        "research",
        "flare-network",
        "analytics",
        "ftso"
      ],
      "hide_table_of_contents": true
    },
    "file_name": "files/hub-docs/support/whitepapers.mdx",
    "type": "answer"
  },
  {
    "content": "import Remix from \"@site/src/components/remix\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport YoutubeEmbed from \"@site/src/components/youtube\";\nimport FDCTransferEventListener from \"!!raw-loader!/examples/developer-hub-solidity/FDCTransferEventListener.sol\";\nimport PrepareRequest from \"!!raw-loader!/examples/developer-hub-javascript/fdc_prepare_request.ts\";\nimport SubmitRequest from \"!!raw-loader!/examples/developer-hub-javascript/fdc_submit_request.ts\";\nimport GetProof from \"!!raw-loader!/examples/developer-hub-javascript/fdc_get_proof.ts\";\nimport VerifyProof from \"!!raw-loader!/examples/developer-hub-javascript/fdc_verify_proof.ts\";\n\nThe Flare Data Connector (FDC) is a powerful cross-chain protocol that enables smart contracts on Flare to securely access and verify data from other blockchains.\nThis section demonstrates how to bridge data across chains and attest to events on EVM networks, with practical examples using the Ethereum testnet (Sepolia) and Flare Network.\n\n:::info[New to smart contract development?]\n\nLearn how to [deploy your first smart contract](/network/getting-started) on Flare before you start this guide, or explore the [official starter kits](/network/guides/hardhat-foundry-starter-kit) for Hardhat and Foundry.\n\n:::\n\nAt its core, FDC enables any smart contract on Flare to query immutable, verifiable information from supported blockchain networks. The protocol achieves consensus through the BitVote-reveal mechanism within the Flare Systems Protocol suite, allowing dapps to validate external blockchain data using Merkle proofs.\n\nCurrently supported networks include:\n\n- **Non smart-contract**: Bitcoin, Dogecoin, and XRP Ledger (including their testnets)\n- **Smart-contract**: Ethereum, Songbird, and Flare (including Sepolia, Songbird Testnet Coston, and Flare Testnet Coston2)\n\nThe protocol's extensible design allows for future integration of additional blockchains and attestation types, making it a foundation for cross-chain interoperability.\n\nimport Remix from \"@site/src/components/remix\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport YoutubeEmbed from \"@site/src/components/youtube\";\nimport FDCTransferEventListener from \"!!raw-loader!/examples/developer-hub-solidity/FDCTransferEventListener.sol\";\nimport PrepareRequest from \"!!raw-loader!/examples/developer-hub-javascript/fdc_prepare_request.ts\";\nimport SubmitRequest from \"!!raw-loader!/examples/developer-hub-javascript/fdc_submit_request.ts\";\nimport GetProof from \"!!raw-loader!/examples/developer-hub-javascript/fdc_get_proof.ts\";\nimport VerifyProof from \"!!raw-loader!/examples/developer-hub-javascript/fdc_verify_proof.ts\";\n\nThe Flare Data Connector (FDC) is a powerful cross-chain protocol that enables smart contracts on Flare to securely access and verify data from other blockchains.\nThis section demonstrates how to bridge data across chains and attest to events on EVM networks, with practical examples using the Ethereum testnet (Sepolia) and Flare Network.\n\n:::info[New to smart contract development?]\n\nLearn how to [deploy your first smart contract](/network/getting-started) on Flare before you start this guide, or explore the [official starter kits](/network/guides/hardhat-foundry-starter-kit) for Hardhat and Foundry.\n\n:::\n\nAt its core, FDC enables any smart contract on Flare to query immutable, verifiable information from supported blockchain networks. The protocol achieves consensus through the BitVote-reveal mechanism within the Flare Systems Protocol suite, allowing dapps to validate external blockchain data using Merkle proofs.\n\nCurrently supported networks include:\n\n- **Non smart-contract**: Bitcoin, Dogecoin, and XRP Ledger (including their testnets)\n- **Smart-contract**: Ethereum, Songbird, and Flare (including Sepolia, Songbird Testnet Coston, and Flare Testnet Coston2)\n\nThe protocol's extensible design allows for future integration of additional blockchains and attestation types, making it a foundation for cross-chain interoperability.",
    "file_name": "files/hub-docs/fdc/2-getting-started.mdx",
    "meta_data": {
      "sidebar_position": 2,
      "unlisted": false,
      "title": "Getting Started",
      "description": "Learn how to verify data from other chains using FDC.",
      "keywords": [
        "fdc",
        "oracle",
        "flare-data-connector",
        "flare-network",
        "smart-contracts",
        "solidity",
        "remix"
      ]
    },
    "type": "answer"
  },
  {
    "content": "import Remix from \"@site/src/components/remix\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport YoutubeEmbed from \"@site/src/components/youtube\";\nimport FDCTransferEventListener from \"!!raw-loader!/examples/developer-hub-solidity/FDCTransferEventListener.sol\";\nimport PrepareRequest from \"!!raw-loader!/examples/developer-hub-javascript/fdc_prepare_request.ts\";\nimport SubmitRequest from \"!!raw-loader!/examples/developer-hub-javascript/fdc_submit_request.ts\";\nimport GetProof from \"!!raw-loader!/examples/developer-hub-javascript/fdc_get_proof.ts\";\nimport VerifyProof from \"!!raw-loader!/examples/developer-hub-javascript/fdc_verify_proof.ts\";\n\nThe Flare Data Connector (FDC) is a powerful cross-chain protocol that enables smart contracts on Flare to securely access and verify data from other blockchains.\nThis section demonstrates how to bridge data across chains and attest to events on EVM networks, with practical examples using the Ethereum testnet (Sepolia) and Flare Network.\n\n:::info[New to smart contract development?]\n\nLearn how to [deploy your first smart contract](/network/getting-started) on Flare before you start this guide, or explore the [official starter kits](/network/guides/hardhat-foundry-starter-kit) for Hardhat and Foundry.\n\n:::\n\nAt its core, FDC enables any smart contract on Flare to query immutable, verifiable information from supported blockchain networks. The protocol achieves consensus through the BitVote-reveal mechanism within the Flare Systems Protocol suite, allowing dapps to validate external blockchain data using Merkle proofs.\n\nCurrently supported networks include:\n\n- **Non smart-contract**: Bitcoin, Dogecoin, and XRP Ledger (including their testnets)\n- **Smart-contract**: Ethereum, Songbird, and Flare (including Sepolia, Songbird Testnet Coston, and Flare Testnet Coston2)\n\nThe protocol's extensible design allows for future integration of additional blockchains and attestation types, making it a foundation for cross-chain interoperability.\n\nimport Remix from \"@site/src/components/remix\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport YoutubeEmbed from \"@site/src/components/youtube\";\nimport FDCTransferEventListener from \"!!raw-loader!/examples/developer-hub-solidity/FDCTransferEventListener.sol\";\nimport PrepareRequest from \"!!raw-loader!/examples/developer-hub-javascript/fdc_prepare_request.ts\";\nimport SubmitRequest from \"!!raw-loader!/examples/developer-hub-javascript/fdc_submit_request.ts\";\nimport GetProof from \"!!raw-loader!/examples/developer-hub-javascript/fdc_get_proof.ts\";\nimport VerifyProof from \"!!raw-loader!/examples/developer-hub-javascript/fdc_verify_proof.ts\";\n\nThe Flare Data Connector (FDC) is a powerful cross-chain protocol that enables smart contracts on Flare to securely access and verify data from other blockchains.\nThis section demonstrates how to bridge data across chains and attest to events on EVM networks, with practical examples using the Ethereum testnet (Sepolia) and Flare Network.\n\n:::info[New to smart contract development?]\n\nLearn how to [deploy your first smart contract](/network/getting-started) on Flare before you start this guide, or explore the [official starter kits](/network/guides/hardhat-foundry-starter-kit) for Hardhat and Foundry.\n\n:::\n\nAt its core, FDC enables any smart contract on Flare to query immutable, verifiable information from supported blockchain networks. The protocol achieves consensus through the BitVote-reveal mechanism within the Flare Systems Protocol suite, allowing dapps to validate external blockchain data using Merkle proofs.\n\nCurrently supported networks include:\n\n- **Non smart-contract**: Bitcoin, Dogecoin, and XRP Ledger (including their testnets)\n- **Smart-contract**: Ethereum, Songbird, and Flare (including Sepolia, Songbird Testnet Coston, and Flare Testnet Coston2)\n\nThe protocol's extensible design allows for future integration of additional blockchains and attestation types, making it a foundation for cross-chain interoperability.",
    "file_name": "files/hub-docs/fdc/2-getting-started.mdx",
    "meta_data": {
      "sidebar_position": 2,
      "unlisted": false,
      "title": "Getting Started",
      "description": "Learn how to verify data from other chains using FDC.",
      "keywords": [
        "fdc",
        "oracle",
        "flare-data-connector",
        "flare-network",
        "smart-contracts",
        "solidity",
        "remix"
      ]
    },
    "type": "answer"
  },
  {
    "content": "import Remix from \"@site/src/components/remix\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport YoutubeEmbed from \"@site/src/components/youtube\";\nimport FDCTransferEventListener from \"!!raw-loader!/examples/developer-hub-solidity/FDCTransferEventListener.sol\";\nimport PrepareRequest from \"!!raw-loader!/examples/developer-hub-javascript/fdc_prepare_request.ts\";\nimport SubmitRequest from \"!!raw-loader!/examples/developer-hub-javascript/fdc_submit_request.ts\";\nimport GetProof from \"!!raw-loader!/examples/developer-hub-javascript/fdc_get_proof.ts\";\nimport VerifyProof from \"!!raw-loader!/examples/developer-hub-javascript/fdc_verify_proof.ts\";\n\nThe Flare Data Connector (FDC) is a powerful cross-chain protocol that enables smart contracts on Flare to securely access and verify data from other blockchains.\nThis section demonstrates how to bridge data across chains and attest to events on EVM networks, with practical examples using the Ethereum testnet (Sepolia) and Flare Network.\n\n:::info[New to smart contract development?]\n\nLearn how to [deploy your first smart contract](/network/getting-started) on Flare before you start this guide, or explore the [official starter kits](/network/guides/hardhat-foundry-starter-kit) for Hardhat and Foundry.\n\n:::\n\nAt its core, FDC enables any smart contract on Flare to query immutable, verifiable information from supported blockchain networks. The protocol achieves consensus through the BitVote-reveal mechanism within the Flare Systems Protocol suite, allowing dapps to validate external blockchain data using Merkle proofs.\n\nCurrently supported networks include:\n\n- **Non smart-contract**: Bitcoin, Dogecoin, and XRP Ledger (including their testnets)\n- **Smart-contract**: Ethereum, Songbird, and Flare (including Sepolia, Songbird Testnet Coston, and Flare Testnet Coston2)\n\nThe protocol's extensible design allows for future integration of additional blockchains and attestation types, making it a foundation for cross-chain interoperability.\n\nimport Remix from \"@site/src/components/remix\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport YoutubeEmbed from \"@site/src/components/youtube\";\nimport FDCTransferEventListener from \"!!raw-loader!/examples/developer-hub-solidity/FDCTransferEventListener.sol\";\nimport PrepareRequest from \"!!raw-loader!/examples/developer-hub-javascript/fdc_prepare_request.ts\";\nimport SubmitRequest from \"!!raw-loader!/examples/developer-hub-javascript/fdc_submit_request.ts\";\nimport GetProof from \"!!raw-loader!/examples/developer-hub-javascript/fdc_get_proof.ts\";\nimport VerifyProof from \"!!raw-loader!/examples/developer-hub-javascript/fdc_verify_proof.ts\";\n\nThe Flare Data Connector (FDC) is a powerful cross-chain protocol that enables smart contracts on Flare to securely access and verify data from other blockchains.\nThis section demonstrates how to bridge data across chains and attest to events on EVM networks, with practical examples using the Ethereum testnet (Sepolia) and Flare Network.\n\n:::info[New to smart contract development?]\n\nLearn how to [deploy your first smart contract](/network/getting-started) on Flare before you start this guide, or explore the [official starter kits](/network/guides/hardhat-foundry-starter-kit) for Hardhat and Foundry.\n\n:::\n\nAt its core, FDC enables any smart contract on Flare to query immutable, verifiable information from supported blockchain networks. The protocol achieves consensus through the BitVote-reveal mechanism within the Flare Systems Protocol suite, allowing dapps to validate external blockchain data using Merkle proofs.\n\nCurrently supported networks include:\n\n- **Non smart-contract**: Bitcoin, Dogecoin, and XRP Ledger (including their testnets)\n- **Smart-contract**: Ethereum, Songbird, and Flare (including Sepolia, Songbird Testnet Coston, and Flare Testnet Coston2)\n\nThe protocol's extensible design allows for future integration of additional blockchains and attestation types, making it a foundation for cross-chain interoperability.",
    "file_name": "files/hub-docs/fdc/2-getting-started.mdx",
    "meta_data": {
      "sidebar_position": 2,
      "unlisted": false,
      "title": "Getting Started",
      "description": "Learn how to verify data from other chains using FDC.",
      "keywords": [
        "fdc",
        "oracle",
        "flare-data-connector",
        "flare-network",
        "smart-contracts",
        "solidity",
        "remix"
      ]
    },
    "type": "answer"
  },
  {
    "content": "import Remix from \"@site/src/components/remix\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport YoutubeEmbed from \"@site/src/components/youtube\";\nimport FDCTransferEventListener from \"!!raw-loader!/examples/developer-hub-solidity/FDCTransferEventListener.sol\";\nimport PrepareRequest from \"!!raw-loader!/examples/developer-hub-javascript/fdc_prepare_request.ts\";\nimport SubmitRequest from \"!!raw-loader!/examples/developer-hub-javascript/fdc_submit_request.ts\";\nimport GetProof from \"!!raw-loader!/examples/developer-hub-javascript/fdc_get_proof.ts\";\nimport VerifyProof from \"!!raw-loader!/examples/developer-hub-javascript/fdc_verify_proof.ts\";\n\nThe Flare Data Connector (FDC) is a powerful cross-chain protocol that enables smart contracts on Flare to securely access and verify data from other blockchains.\nThis section demonstrates how to bridge data across chains and attest to events on EVM networks, with practical examples using the Ethereum testnet (Sepolia) and Flare Network.\n\n:::info[New to smart contract development?]\n\nLearn how to [deploy your first smart contract](/network/getting-started) on Flare before you start this guide, or explore the [official starter kits](/network/guides/hardhat-foundry-starter-kit) for Hardhat and Foundry.\n\n:::\n\nAt its core, FDC enables any smart contract on Flare to query immutable, verifiable information from supported blockchain networks. The protocol achieves consensus through the BitVote-reveal mechanism within the Flare Systems Protocol suite, allowing dapps to validate external blockchain data using Merkle proofs.\n\nCurrently supported networks include:\n\n- **Non smart-contract**: Bitcoin, Dogecoin, and XRP Ledger (including their testnets)\n- **Smart-contract**: Ethereum, Songbird, and Flare (including Sepolia, Songbird Testnet Coston, and Flare Testnet Coston2)\n\nThe protocol's extensible design allows for future integration of additional blockchains and attestation types, making it a foundation for cross-chain interoperability.\n\nimport Remix from \"@site/src/components/remix\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport YoutubeEmbed from \"@site/src/components/youtube\";\nimport FDCTransferEventListener from \"!!raw-loader!/examples/developer-hub-solidity/FDCTransferEventListener.sol\";\nimport PrepareRequest from \"!!raw-loader!/examples/developer-hub-javascript/fdc_prepare_request.ts\";\nimport SubmitRequest from \"!!raw-loader!/examples/developer-hub-javascript/fdc_submit_request.ts\";\nimport GetProof from \"!!raw-loader!/examples/developer-hub-javascript/fdc_get_proof.ts\";\nimport VerifyProof from \"!!raw-loader!/examples/developer-hub-javascript/fdc_verify_proof.ts\";\n\nThe Flare Data Connector (FDC) is a powerful cross-chain protocol that enables smart contracts on Flare to securely access and verify data from other blockchains.\nThis section demonstrates how to bridge data across chains and attest to events on EVM networks, with practical examples using the Ethereum testnet (Sepolia) and Flare Network.\n\n:::info[New to smart contract development?]\n\nLearn how to [deploy your first smart contract](/network/getting-started) on Flare before you start this guide, or explore the [official starter kits](/network/guides/hardhat-foundry-starter-kit) for Hardhat and Foundry.\n\n:::\n\nAt its core, FDC enables any smart contract on Flare to query immutable, verifiable information from supported blockchain networks. The protocol achieves consensus through the BitVote-reveal mechanism within the Flare Systems Protocol suite, allowing dapps to validate external blockchain data using Merkle proofs.\n\nCurrently supported networks include:\n\n- **Non smart-contract**: Bitcoin, Dogecoin, and XRP Ledger (including their testnets)\n- **Smart-contract**: Ethereum, Songbird, and Flare (including Sepolia, Songbird Testnet Coston, and Flare Testnet Coston2)\n\nThe protocol's extensible design allows for future integration of additional blockchains and attestation types, making it a foundation for cross-chain interoperability.",
    "file_name": "files/hub-docs/fdc/2-getting-started.mdx",
    "meta_data": {
      "sidebar_position": 2,
      "unlisted": false,
      "title": "Getting Started",
      "description": "Learn how to verify data from other chains using FDC.",
      "keywords": [
        "fdc",
        "oracle",
        "flare-data-connector",
        "flare-network",
        "smart-contracts",
        "solidity",
        "remix"
      ]
    },
    "type": "answer"
  },
  {
    "content": "import Remix from \"@site/src/components/remix\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport YoutubeEmbed from \"@site/src/components/youtube\";\nimport FDCTransferEventListener from \"!!raw-loader!/examples/developer-hub-solidity/FDCTransferEventListener.sol\";\nimport PrepareRequest from \"!!raw-loader!/examples/developer-hub-javascript/fdc_prepare_request.ts\";\nimport SubmitRequest from \"!!raw-loader!/examples/developer-hub-javascript/fdc_submit_request.ts\";\nimport GetProof from \"!!raw-loader!/examples/developer-hub-javascript/fdc_get_proof.ts\";\nimport VerifyProof from \"!!raw-loader!/examples/developer-hub-javascript/fdc_verify_proof.ts\";\n\nThe Flare Data Connector (FDC) is a powerful cross-chain protocol that enables smart contracts on Flare to securely access and verify data from other blockchains.\nThis section demonstrates how to bridge data across chains and attest to events on EVM networks, with practical examples using the Ethereum testnet (Sepolia) and Flare Network.\n\n:::info[New to smart contract development?]\n\nLearn how to [deploy your first smart contract](/network/getting-started) on Flare before you start this guide, or explore the [official starter kits](/network/guides/hardhat-foundry-starter-kit) for Hardhat and Foundry.\n\n:::\n\nAt its core, FDC enables any smart contract on Flare to query immutable, verifiable information from supported blockchain networks. The protocol achieves consensus through the BitVote-reveal mechanism within the Flare Systems Protocol suite, allowing dapps to validate external blockchain data using Merkle proofs.\n\nCurrently supported networks include:\n\n- **Non smart-contract**: Bitcoin, Dogecoin, and XRP Ledger (including their testnets)\n- **Smart-contract**: Ethereum, Songbird, and Flare (including Sepolia, Songbird Testnet Coston, and Flare Testnet Coston2)\n\nThe protocol's extensible design allows for future integration of additional blockchains and attestation types, making it a foundation for cross-chain interoperability.",
    "file_name": "files/hub-docs/fdc/2-getting-started.mdx",
    "meta_data": {
      "sidebar_position": 2,
      "unlisted": false,
      "title": "Getting Started",
      "description": "Learn how to verify data from other chains using FDC.",
      "keywords": [
        "fdc",
        "oracle",
        "flare-data-connector",
        "flare-network",
        "smart-contracts",
        "solidity",
        "remix"
      ]
    },
    "type": "answer"
  },
  {
    "content": "import DocCardList from \"@theme/DocCardList\";\n\n**FDC Attestations** provide cryptographic proofs for data originating outside Flare's EVM state. They enable smart contracts to verify external data trustlessly. For example, FDC attestations can validate:\n\n- **Non-Payment Verification:** Confirm whether a payment **has not been made** on a UTXO chains like Bitcoin or Dogecoin.\n- **Event Log Authentication:** Verify event logs generated by transactions on EVM-compatible blockchains.\n\nFDC currently supports the following six attestation types:\n\n<DocCardList />",
    "meta_data": {
      "title": "Attestation Types",
      "description": "Learn about different attestation types supported by FDC.",
      "keywords": [
        "fdc",
        "oracle",
        "flare-data-connector",
        "flare-network"
      ],
      "sidebar_position": 3
    },
    "file_name": "files/hub-docs/fdc/3-attestation-types.mdx",
    "type": "answer"
  },
  {
    "content": "import ThemedImage from \"@theme/ThemedImage\";\nimport useBaseUrl from \"@docusaurus/useBaseUrl\";\n\nThe **Flare Data Connector (FDC)** is an [enshrined oracle](/support/terminology#enshrined-oracle) designed to validate external data for Flare's EVM state.\nIt allows users to submit attested data that smart contracts can trust, eliminating the need for direct reliance on users for data integrity.\n\nimport ThemedImage from \"@theme/ThemedImage\";\nimport useBaseUrl from \"@docusaurus/useBaseUrl\";\n\nThe **Flare Data Connector (FDC)** is an [enshrined oracle](/support/terminology#enshrined-oracle) designed to validate external data for Flare's EVM state.\nIt allows users to submit attested data that smart contracts can trust, eliminating the need for direct reliance on users for data integrity.\n\nimport ThemedImage from \"@theme/ThemedImage\";\nimport useBaseUrl from \"@docusaurus/useBaseUrl\";\n\nThe **Flare Data Connector (FDC)** is an [enshrined oracle](/support/terminology#enshrined-oracle) designed to validate external data for Flare's EVM state.\nIt allows users to submit attested data that smart contracts can trust, eliminating the need for direct reliance on users for data integrity.\n\nimport ThemedImage from \"@theme/ThemedImage\";\nimport useBaseUrl from \"@docusaurus/useBaseUrl\";\n\nThe **Flare Data Connector (FDC)** is an [enshrined oracle](/support/terminology#enshrined-oracle) designed to validate external data for Flare's EVM state.\nIt allows users to submit attested data that smart contracts can trust, eliminating the need for direct reliance on users for data integrity.\n\nimport ThemedImage from \"@theme/ThemedImage\";\nimport useBaseUrl from \"@docusaurus/useBaseUrl\";\n\nThe **Flare Data Connector (FDC)** is an [enshrined oracle](/support/terminology#enshrined-oracle) designed to validate external data for Flare's EVM state.\nIt allows users to submit attested data that smart contracts can trust, eliminating the need for direct reliance on users for data integrity.",
    "file_name": "files/hub-docs/fdc/1-overview.mdx",
    "meta_data": {
      "sidebar_position": 1,
      "slug": "overview",
      "title": "FDC Overview",
      "authors": [
        "lukaavbreht",
        "filipkoprivec"
      ],
      "description": "The Flare Data Connector (FDC) enables secure, on-chain attestation of external data.",
      "tags": [
        "intermediate",
        "ethereum",
        "fdc"
      ],
      "keywords": [
        "ethereum",
        "flare-data-connector",
        "evm",
        "flare-network"
      ],
      "unlisted": false
    },
    "type": "answer"
  },
  {
    "content": "import Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport DocCardList from \"@theme/DocCardList\";\nimport SolidityReference from \"@site/src/components/DataTables/SolidityReference\";\n\nimport Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport DocCardList from \"@theme/DocCardList\";\nimport SolidityReference from \"@site/src/components/DataTables/SolidityReference\";\n\nimport Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport DocCardList from \"@theme/DocCardList\";\nimport SolidityReference from \"@site/src/components/DataTables/SolidityReference\";",
    "file_name": "files/hub-docs/fdc/5-reference.mdx",
    "meta_data": {
      "title": "FDC Reference",
      "description": "Solidity reference for FDC smart contracts.",
      "keywords": [
        "solidity",
        "reference",
        "fdc",
        "flare-data-connector",
        "flare-network",
        "smart-contracts"
      ]
    },
    "type": "answer"
  },
  {
    "content": "import Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\n\n<details>\n<summary>Automated registration on testnets.</summary>\n\n:::danger\n\nAutomated registration can expose private keys. Only use on testnets.\n\n:::\n\nOn testnets, you can register your entity addresses with the [`register-entities.ts`](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/deployment/tasks/register-entities.ts) script and your sortition public key with the [`register-public-keys.ts`](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/deployment/tasks/register-public-keys.ts) scripts.\n\n1. Clone and build [flare-smart-contracts-v2](https://github.com/flare-foundation/flare-smart-contracts-v2/):\n\n```bash\ngit clone https://github.com/flare-foundation/flare-smart-contracts-v2/\ncd flare-smart-contracts-v2\nyarn\nyarn c\n```\n\n2. Create an `entities.json` file with the following account addresses and private keys:\n\n```json\n[\n  {\n    \"identity\": {\n      \"address\": \"<address>\",\n      \"privateKey\": \"<private key hex>\"\n    },\n    \"submit\": {\n      \"address\": \"<address>\",\n      \"privateKey\": \"<private key hex>\"\n    },\n    \"submitSignatures\": {\n      \"address\": \"<address>\",\n      \"privateKey\": \"<private key hex>\"\n    },\n    \"signingPolicy\": {\n      \"address\": \"<address>\",\n      \"privateKey\": \"<private key hex>\"\n    },\n    \"delegation\": {\n      \"address\": \"<address>\",\n      \"privateKey\": \"<private key hex>\"\n    },\n    \"sortitionPrivateKey\": \"<private key hex>\"\n  }\n]\n```\n\n3. Setup the following variables in `.env`:\n\n<Tabs groupId=\"network\">\n  <TabItem value=\"coston2\" label=\"Flare Testnet Coston2\" default>\n\n    ```text title=\".env\"\n    ENTITIES_FILE_PATH=\"<path to entities.json>\"\n    COSTON2_RPC=<non-public Coston2 RPC>\n    CHAIN_CONFIG=\"coston2\"\n    ```\n\n  </TabItem>\n  <TabItem value=\"songbird\" label=\"Songbird Canary-Network\">\n\n    ```text title=\".env\"\n    ENTITIES_FILE_PATH=\"<path to entities.json>\"\n    SONGBIRD_RPC=<non-public Songbird RPC>\n    CHAIN_CONFIG=\"songbird\"\n    ```\n\n  </TabItem>\n  <TabItem value=\"coston\" label=\"Songbird Testnet Coston\">\n\n    ```text title=\".env\"\n    ENTITIES_FILE_PATH=\"<path to entities.json>\"\n    COSTON_RPC=<non-public Coston RPC>\n    CHAIN_CONFIG=\"coston\"\n    ```\n\n  </TabItem>\n</Tabs>\n\n4. Run the registration tasks:\n\n<Tabs groupId=\"network\">\n  <TabItem value=\"coston2\" label=\"Flare Testnet Coston2\" default>\n\n    ```bash\n    yarn hardhat --network coston2 register-entities\n    yarn hardhat --network coston2 register-public-keys\n    ```\n\n  </TabItem>\n  <TabItem value=\"songbird\" label=\"Songbird Canary-Network\">\n\n    ```bash\n    yarn hardhat --network songbird register-entities\n    yarn hardhat --network songbird register-public-keys\n    ```\n\n  </TabItem>\n  <TabItem value=\"coston\" label=\"Songbird Testnet Coston\">\n\n    ```bash\n    yarn hardhat --network coston register-entities\n    yarn hardhat --network coston register-public-keys\n    ```\n\n  </TabItem>\n</Tabs>\n</details>\n",
    "meta_data": {},
    "file_name": "files/hub-docs/run-node/_automated_registration.mdx",
    "type": "answer"
  },
  {
    "content": "import Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\n\nA validator node is essential for securing the network by validating transactions and blocks, and participating in the consensus process. Deploying validator nodes enables participation in the consensus mechanism and allows for the collection of rewards provided by the network to those who help secure it.\n\nValidator nodes perform the following tasks:\n\n- **Validation:** Ensure the validity of transactions.\n- **Consensus:** Reach agreement with other validators on the transactions to be added to the blockchain.\n- **Block Addition:** Bundle the agreed-upon transactions into a block and append it to the blockchain.\n\nOn Flare, data protocols such as the [Flare Time Series Oracle](/run-node/ftso-data-provider) and [Flare Data Connector](/run-node/fdc-attestation-provider) are enshrined into the network. This requires validators to perform additional tasks to secure the network and earn rewards.\n\n<details>\n<summary>**Flare Staking Phases**</summary>\n\nDeployment will occur in three phases, during which:\n\n1. Infrastructure entities will be progressively on-boarded to ensure the network remains operational.\n2. Current FTSO data providers must build a minimum stake to function as validators.\n3. Existing validators need to enhance their capabilities to become data providers.\n\nEach phase will gradually relinquish control, allowing the network to validate independently of the Flare Foundation.\n\n**Launch (Jul 2022)**\n\nAt network launch, 20 validators had their node IDs hard-coded into the client software, preventing other validators from participating. The Flare Foundation managed these nodes and gradually reassigned 16 of them to 4 external entities to increase decentralization. These entities, known as professional validators, are experienced infrastructure providers managing blockchain nodes. During this period, FTSO data providers operated entirely independently of validators.\n\n**Phase 1 (July 2023)**\n\nA network fork enabled Avalanche's proof-of-stake mechanism, opening validation to everyone. Simultaneously, all stakes from the original validators expired. The Flare Foundation loaned all the stakes for the initial validators, maintaining the distribution of validation power while testing proof-of-stake. After some FTSO data providers completed a KYC process, the Flare Foundation loaned them funds to deploy validation nodes and act as validators.\n\nSince staking occurs on the P-chain, staked tokens cannot access rewards managed by smart contracts on the C-chain. To address this, a communication mechanism between the two chains is being developed. All staking rewards are manually calculated offchain and then distributed onchain. These calculations will initially be private for fine-tuning and will become public in Phase 2 for verification.\n\n**Phase 2 (Oct 2023, current)**\n\nOnce FTSO data providers have gathered enough stake to ensure the network's continued operation, all stakes loaned by the Flare Foundation to the launch validators will be withdrawn. Professional validators are expected to cease operations unless they provide their own stake. The Flare Foundation might delegate stake to KYC-verified FTSO data providers to help initiate the system. This process, known as stake boosting, will run for a limited time. Staked funds can earn [FlareDrops](https://flare.network/flaredrop-guide/) and participate in governance but not earn [FTSO](https://flare.network/ftso/) delegation rewards.\n\nStaking rewards will:\n\n- Consider validator uptime and staked amount, which is publicly monitored.\n- Require that the validator is also an FTSO data provider consistently rewarded for accurate prices.\n- Be manually calculated offchain using a public script and then distributed onchain.\n\n**Phase 3**\n\nOnce secure communication between the P- and C-chains is established, staking rewards will be managed entirely onchain. The goal is for funds staked on the P-chain to have the same rights as wrapped FLR on the C-chain, enabling them to earn [FTSO](https://flare.network/ftso/) rewards, [FlareDrops](https://flare.network/flaredrop-guide/), and participate in governance.\n\n**Summary of Phases**\n\n|                                                   | Launch | Phase 1 | Phase 2\\* | Phase 3 |\n| ------------------------------------------------- | :----: | :-----: | :-------: | :-----: |\n| Validation open to everybody                      |   \u274c   |   \u2705    |    \u2705     |   \u2705    |\n| Validators must provide own stake                 |   \u274c   |   \u274c    |    \u2705     |   \u2705    |\n| Validators must be data providers to earn rewards |   \u274c   |   \u274c    |    \u2705     |   \u2705    |\n| Locked stake can earn staking rewards             |   \u274c   |   \u274c    |    \u2705     |   \u2705    |\n| Staking rewards are handled onchain               |   \u274c   |   \u274c    |    \u274c     |   \u2705    |\n| Same rights for staked and wrapped tokens         |   \u274c   |   \u274c    |    \u274c     |   \u2705    |\n\n\\*Current Phase\n\n</details>",
    "file_name": "files/hub-docs/run-node/2-validator-node.mdx",
    "meta_data": {
      "sidebar_position": 2,
      "slug": "validator-node",
      "title": "Validator Node",
      "description": "Secure Flare by reaching consensus on state transitions."
    },
    "type": "answer"
  },
  {
    "content": "import Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\n\nA validator node is essential for securing the network by validating transactions and blocks, and participating in the consensus process. Deploying validator nodes enables participation in the consensus mechanism and allows for the collection of rewards provided by the network to those who help secure it.\n\nValidator nodes perform the following tasks:\n\n- **Validation:** Ensure the validity of transactions.\n- **Consensus:** Reach agreement with other validators on the transactions to be added to the blockchain.\n- **Block Addition:** Bundle the agreed-upon transactions into a block and append it to the blockchain.\n\nOn Flare, data protocols such as the [Flare Time Series Oracle](/run-node/ftso-data-provider) and [Flare Data Connector](/run-node/fdc-attestation-provider) are enshrined into the network. This requires validators to perform additional tasks to secure the network and earn rewards.\n\n<details>\n<summary>**Flare Staking Phases**</summary>\n\nDeployment will occur in three phases, during which:\n\n1. Infrastructure entities will be progressively on-boarded to ensure the network remains operational.\n2. Current FTSO data providers must build a minimum stake to function as validators.\n3. Existing validators need to enhance their capabilities to become data providers.\n\nEach phase will gradually relinquish control, allowing the network to validate independently of the Flare Foundation.\n\n**Launch (Jul 2022)**\n\nAt network launch, 20 validators had their node IDs hard-coded into the client software, preventing other validators from participating. The Flare Foundation managed these nodes and gradually reassigned 16 of them to 4 external entities to increase decentralization. These entities, known as professional validators, are experienced infrastructure providers managing blockchain nodes. During this period, FTSO data providers operated entirely independently of validators.\n\n**Phase 1 (July 2023)**\n\nA network fork enabled Avalanche's proof-of-stake mechanism, opening validation to everyone. Simultaneously, all stakes from the original validators expired. The Flare Foundation loaned all the stakes for the initial validators, maintaining the distribution of validation power while testing proof-of-stake. After some FTSO data providers completed a KYC process, the Flare Foundation loaned them funds to deploy validation nodes and act as validators.\n\nSince staking occurs on the P-chain, staked tokens cannot access rewards managed by smart contracts on the C-chain. To address this, a communication mechanism between the two chains is being developed. All staking rewards are manually calculated offchain and then distributed onchain. These calculations will initially be private for fine-tuning and will become public in Phase 2 for verification.\n\n**Phase 2 (Oct 2023, current)**\n\nOnce FTSO data providers have gathered enough stake to ensure the network's continued operation, all stakes loaned by the Flare Foundation to the launch validators will be withdrawn. Professional validators are expected to cease operations unless they provide their own stake. The Flare Foundation might delegate stake to KYC-verified FTSO data providers to help initiate the system. This process, known as stake boosting, will run for a limited time. Staked funds can earn [FlareDrops](https://flare.network/flaredrop-guide/) and participate in governance but not earn [FTSO](https://flare.network/ftso/) delegation rewards.\n\nStaking rewards will:\n\n- Consider validator uptime and staked amount, which is publicly monitored.\n- Require that the validator is also an FTSO data provider consistently rewarded for accurate prices.\n- Be manually calculated offchain using a public script and then distributed onchain.\n\n**Phase 3**\n\nOnce secure communication between the P- and C-chains is established, staking rewards will be managed entirely onchain. The goal is for funds staked on the P-chain to have the same rights as wrapped FLR on the C-chain, enabling them to earn [FTSO](https://flare.network/ftso/) rewards, [FlareDrops](https://flare.network/flaredrop-guide/), and participate in governance.\n\n**Summary of Phases**\n\n|                                                   | Launch | Phase 1 | Phase 2\\* | Phase 3 |\n| ------------------------------------------------- | :----: | :-----: | :-------: | :-----: |\n| Validation open to everybody                      |   \u274c   |   \u2705    |    \u2705     |   \u2705    |\n| Validators must provide own stake                 |   \u274c   |   \u274c    |    \u2705     |   \u2705    |\n| Validators must be data providers to earn rewards |   \u274c   |   \u274c    |    \u2705     |   \u2705    |\n| Locked stake can earn staking rewards             |   \u274c   |   \u274c    |    \u2705     |   \u2705    |\n| Staking rewards are handled onchain               |   \u274c   |   \u274c    |    \u274c     |   \u2705    |\n| Same rights for staked and wrapped tokens         |   \u274c   |   \u274c    |    \u274c     |   \u2705    |\n\n\\*Current Phase\n\n</details>",
    "file_name": "files/hub-docs/run-node/2-validator-node.mdx",
    "meta_data": {
      "sidebar_position": 2,
      "slug": "validator-node",
      "title": "Validator Node",
      "description": "Secure Flare by reaching consensus on state transitions."
    },
    "type": "answer"
  },
  {
    "content": "import Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\n\nA validator node is essential for securing the network by validating transactions and blocks, and participating in the consensus process. Deploying validator nodes enables participation in the consensus mechanism and allows for the collection of rewards provided by the network to those who help secure it.\n\nValidator nodes perform the following tasks:\n\n- **Validation:** Ensure the validity of transactions.\n- **Consensus:** Reach agreement with other validators on the transactions to be added to the blockchain.\n- **Block Addition:** Bundle the agreed-upon transactions into a block and append it to the blockchain.\n\nOn Flare, data protocols such as the [Flare Time Series Oracle](/run-node/ftso-data-provider) and [Flare Data Connector](/run-node/fdc-attestation-provider) are enshrined into the network. This requires validators to perform additional tasks to secure the network and earn rewards.\n\n<details>\n<summary>**Flare Staking Phases**</summary>\n\nDeployment will occur in three phases, during which:\n\n1. Infrastructure entities will be progressively on-boarded to ensure the network remains operational.\n2. Current FTSO data providers must build a minimum stake to function as validators.\n3. Existing validators need to enhance their capabilities to become data providers.\n\nEach phase will gradually relinquish control, allowing the network to validate independently of the Flare Foundation.\n\n**Launch (Jul 2022)**\n\nAt network launch, 20 validators had their node IDs hard-coded into the client software, preventing other validators from participating. The Flare Foundation managed these nodes and gradually reassigned 16 of them to 4 external entities to increase decentralization. These entities, known as professional validators, are experienced infrastructure providers managing blockchain nodes. During this period, FTSO data providers operated entirely independently of validators.\n\n**Phase 1 (July 2023)**\n\nA network fork enabled Avalanche's proof-of-stake mechanism, opening validation to everyone. Simultaneously, all stakes from the original validators expired. The Flare Foundation loaned all the stakes for the initial validators, maintaining the distribution of validation power while testing proof-of-stake. After some FTSO data providers completed a KYC process, the Flare Foundation loaned them funds to deploy validation nodes and act as validators.\n\nSince staking occurs on the P-chain, staked tokens cannot access rewards managed by smart contracts on the C-chain. To address this, a communication mechanism between the two chains is being developed. All staking rewards are manually calculated offchain and then distributed onchain. These calculations will initially be private for fine-tuning and will become public in Phase 2 for verification.\n\n**Phase 2 (Oct 2023, current)**\n\nOnce FTSO data providers have gathered enough stake to ensure the network's continued operation, all stakes loaned by the Flare Foundation to the launch validators will be withdrawn. Professional validators are expected to cease operations unless they provide their own stake. The Flare Foundation might delegate stake to KYC-verified FTSO data providers to help initiate the system. This process, known as stake boosting, will run for a limited time. Staked funds can earn [FlareDrops](https://flare.network/flaredrop-guide/) and participate in governance but not earn [FTSO](https://flare.network/ftso/) delegation rewards.\n\nStaking rewards will:\n\n- Consider validator uptime and staked amount, which is publicly monitored.\n- Require that the validator is also an FTSO data provider consistently rewarded for accurate prices.\n- Be manually calculated offchain using a public script and then distributed onchain.\n\n**Phase 3**\n\nOnce secure communication between the P- and C-chains is established, staking rewards will be managed entirely onchain. The goal is for funds staked on the P-chain to have the same rights as wrapped FLR on the C-chain, enabling them to earn [FTSO](https://flare.network/ftso/) rewards, [FlareDrops](https://flare.network/flaredrop-guide/), and participate in governance.\n\n**Summary of Phases**\n\n|                                                   | Launch | Phase 1 | Phase 2\\* | Phase 3 |\n| ------------------------------------------------- | :----: | :-----: | :-------: | :-----: |\n| Validation open to everybody                      |   \u274c   |   \u2705    |    \u2705     |   \u2705    |\n| Validators must provide own stake                 |   \u274c   |   \u274c    |    \u2705     |   \u2705    |\n| Validators must be data providers to earn rewards |   \u274c   |   \u274c    |    \u2705     |   \u2705    |\n| Locked stake can earn staking rewards             |   \u274c   |   \u274c    |    \u2705     |   \u2705    |\n| Staking rewards are handled onchain               |   \u274c   |   \u274c    |    \u274c     |   \u2705    |\n| Same rights for staked and wrapped tokens         |   \u274c   |   \u274c    |    \u274c     |   \u2705    |\n\n\\*Current Phase\n\n</details>",
    "file_name": "files/hub-docs/run-node/2-validator-node.mdx",
    "meta_data": {
      "sidebar_position": 2,
      "slug": "validator-node",
      "title": "Validator Node",
      "description": "Secure Flare by reaching consensus on state transitions."
    },
    "type": "answer"
  },
  {
    "content": "import Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\n\nA validator node is essential for securing the network by validating transactions and blocks, and participating in the consensus process. Deploying validator nodes enables participation in the consensus mechanism and allows for the collection of rewards provided by the network to those who help secure it.\n\nValidator nodes perform the following tasks:\n\n- **Validation:** Ensure the validity of transactions.\n- **Consensus:** Reach agreement with other validators on the transactions to be added to the blockchain.\n- **Block Addition:** Bundle the agreed-upon transactions into a block and append it to the blockchain.\n\nOn Flare, data protocols such as the [Flare Time Series Oracle](/run-node/ftso-data-provider) and [Flare Data Connector](/run-node/fdc-attestation-provider) are enshrined into the network. This requires validators to perform additional tasks to secure the network and earn rewards.\n\n<details>\n<summary>**Flare Staking Phases**</summary>\n\nDeployment will occur in three phases, during which:\n\n1. Infrastructure entities will be progressively on-boarded to ensure the network remains operational.\n2. Current FTSO data providers must build a minimum stake to function as validators.\n3. Existing validators need to enhance their capabilities to become data providers.\n\nEach phase will gradually relinquish control, allowing the network to validate independently of the Flare Foundation.\n\n**Launch (Jul 2022)**\n\nAt network launch, 20 validators had their node IDs hard-coded into the client software, preventing other validators from participating. The Flare Foundation managed these nodes and gradually reassigned 16 of them to 4 external entities to increase decentralization. These entities, known as professional validators, are experienced infrastructure providers managing blockchain nodes. During this period, FTSO data providers operated entirely independently of validators.\n\n**Phase 1 (July 2023)**\n\nA network fork enabled Avalanche's proof-of-stake mechanism, opening validation to everyone. Simultaneously, all stakes from the original validators expired. The Flare Foundation loaned all the stakes for the initial validators, maintaining the distribution of validation power while testing proof-of-stake. After some FTSO data providers completed a KYC process, the Flare Foundation loaned them funds to deploy validation nodes and act as validators.\n\nSince staking occurs on the P-chain, staked tokens cannot access rewards managed by smart contracts on the C-chain. To address this, a communication mechanism between the two chains is being developed. All staking rewards are manually calculated offchain and then distributed onchain. These calculations will initially be private for fine-tuning and will become public in Phase 2 for verification.\n\n**Phase 2 (Oct 2023, current)**\n\nOnce FTSO data providers have gathered enough stake to ensure the network's continued operation, all stakes loaned by the Flare Foundation to the launch validators will be withdrawn. Professional validators are expected to cease operations unless they provide their own stake. The Flare Foundation might delegate stake to KYC-verified FTSO data providers to help initiate the system. This process, known as stake boosting, will run for a limited time. Staked funds can earn [FlareDrops](https://flare.network/flaredrop-guide/) and participate in governance but not earn [FTSO](https://flare.network/ftso/) delegation rewards.\n\nStaking rewards will:\n\n- Consider validator uptime and staked amount, which is publicly monitored.\n- Require that the validator is also an FTSO data provider consistently rewarded for accurate prices.\n- Be manually calculated offchain using a public script and then distributed onchain.\n\n**Phase 3**\n\nOnce secure communication between the P- and C-chains is established, staking rewards will be managed entirely onchain. The goal is for funds staked on the P-chain to have the same rights as wrapped FLR on the C-chain, enabling them to earn [FTSO](https://flare.network/ftso/) rewards, [FlareDrops](https://flare.network/flaredrop-guide/), and participate in governance.\n\n**Summary of Phases**\n\n|                                                   | Launch | Phase 1 | Phase 2\\* | Phase 3 |\n| ------------------------------------------------- | :----: | :-----: | :-------: | :-----: |\n| Validation open to everybody                      |   \u274c   |   \u2705    |    \u2705     |   \u2705    |\n| Validators must provide own stake                 |   \u274c   |   \u274c    |    \u2705     |   \u2705    |\n| Validators must be data providers to earn rewards |   \u274c   |   \u274c    |    \u2705     |   \u2705    |\n| Locked stake can earn staking rewards             |   \u274c   |   \u274c    |    \u2705     |   \u2705    |\n| Staking rewards are handled onchain               |   \u274c   |   \u274c    |    \u274c     |   \u2705    |\n| Same rights for staked and wrapped tokens         |   \u274c   |   \u274c    |    \u274c     |   \u2705    |\n\n\\*Current Phase\n\n</details>",
    "file_name": "files/hub-docs/run-node/2-validator-node.mdx",
    "meta_data": {
      "sidebar_position": 2,
      "slug": "validator-node",
      "title": "Validator Node",
      "description": "Secure Flare by reaching consensus on state transitions."
    },
    "type": "answer"
  },
  {
    "content": "import Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\n\nA validator node is essential for securing the network by validating transactions and blocks, and participating in the consensus process. Deploying validator nodes enables participation in the consensus mechanism and allows for the collection of rewards provided by the network to those who help secure it.\n\nValidator nodes perform the following tasks:\n\n- **Validation:** Ensure the validity of transactions.\n- **Consensus:** Reach agreement with other validators on the transactions to be added to the blockchain.\n- **Block Addition:** Bundle the agreed-upon transactions into a block and append it to the blockchain.\n\nOn Flare, data protocols such as the [Flare Time Series Oracle](/run-node/ftso-data-provider) and [Flare Data Connector](/run-node/fdc-attestation-provider) are enshrined into the network. This requires validators to perform additional tasks to secure the network and earn rewards.\n\n<details>\n<summary>**Flare Staking Phases**</summary>\n\nDeployment will occur in three phases, during which:\n\n1. Infrastructure entities will be progressively on-boarded to ensure the network remains operational.\n2. Current FTSO data providers must build a minimum stake to function as validators.\n3. Existing validators need to enhance their capabilities to become data providers.\n\nEach phase will gradually relinquish control, allowing the network to validate independently of the Flare Foundation.\n\n**Launch (Jul 2022)**\n\nAt network launch, 20 validators had their node IDs hard-coded into the client software, preventing other validators from participating. The Flare Foundation managed these nodes and gradually reassigned 16 of them to 4 external entities to increase decentralization. These entities, known as professional validators, are experienced infrastructure providers managing blockchain nodes. During this period, FTSO data providers operated entirely independently of validators.\n\n**Phase 1 (July 2023)**\n\nA network fork enabled Avalanche's proof-of-stake mechanism, opening validation to everyone. Simultaneously, all stakes from the original validators expired. The Flare Foundation loaned all the stakes for the initial validators, maintaining the distribution of validation power while testing proof-of-stake. After some FTSO data providers completed a KYC process, the Flare Foundation loaned them funds to deploy validation nodes and act as validators.\n\nSince staking occurs on the P-chain, staked tokens cannot access rewards managed by smart contracts on the C-chain. To address this, a communication mechanism between the two chains is being developed. All staking rewards are manually calculated offchain and then distributed onchain. These calculations will initially be private for fine-tuning and will become public in Phase 2 for verification.\n\n**Phase 2 (Oct 2023, current)**\n\nOnce FTSO data providers have gathered enough stake to ensure the network's continued operation, all stakes loaned by the Flare Foundation to the launch validators will be withdrawn. Professional validators are expected to cease operations unless they provide their own stake. The Flare Foundation might delegate stake to KYC-verified FTSO data providers to help initiate the system. This process, known as stake boosting, will run for a limited time. Staked funds can earn [FlareDrops](https://flare.network/flaredrop-guide/) and participate in governance but not earn [FTSO](https://flare.network/ftso/) delegation rewards.\n\nStaking rewards will:\n\n- Consider validator uptime and staked amount, which is publicly monitored.\n- Require that the validator is also an FTSO data provider consistently rewarded for accurate prices.\n- Be manually calculated offchain using a public script and then distributed onchain.\n\n**Phase 3**\n\nOnce secure communication between the P- and C-chains is established, staking rewards will be managed entirely onchain. The goal is for funds staked on the P-chain to have the same rights as wrapped FLR on the C-chain, enabling them to earn [FTSO](https://flare.network/ftso/) rewards, [FlareDrops](https://flare.network/flaredrop-guide/), and participate in governance.\n\n**Summary of Phases**\n\n|                                                   | Launch | Phase 1 | Phase 2\\* | Phase 3 |\n| ------------------------------------------------- | :----: | :-----: | :-------: | :-----: |\n| Validation open to everybody                      |   \u274c   |   \u2705    |    \u2705     |   \u2705    |\n| Validators must provide own stake                 |   \u274c   |   \u274c    |    \u2705     |   \u2705    |\n| Validators must be data providers to earn rewards |   \u274c   |   \u274c    |    \u2705     |   \u2705    |\n| Locked stake can earn staking rewards             |   \u274c   |   \u274c    |    \u2705     |   \u2705    |\n| Staking rewards are handled onchain               |   \u274c   |   \u274c    |    \u274c     |   \u2705    |\n| Same rights for staked and wrapped tokens         |   \u274c   |   \u274c    |    \u274c     |   \u2705    |\n\n\\*Current Phase\n\n</details>",
    "file_name": "files/hub-docs/run-node/2-validator-node.mdx",
    "meta_data": {
      "sidebar_position": 2,
      "slug": "validator-node",
      "title": "Validator Node",
      "description": "Secure Flare by reaching consensus on state transitions."
    },
    "type": "answer"
  },
  {
    "content": ":::info\n\nThe FTSO Provider deployment is now integrated into the [`flare-systems-deployment`](https://github.com/flare-foundation/flare-systems-deployment) repository, which also supports FDC deployments. Previously, deployments were managed through the `ftso-v2-provider-deployment` repository.\n\nThe older repository is being deprecated. While it remains available for legacy deployments on Flare or Songbird, transitioning to the updated repository is strongly recommended. Active development has shifted to the new repository, where all future updates and features will be introduced. You can find the deprecation notice and detailed upgrade instructions [here](https://github.com/flare-foundation/ftso-v2-provider-deployment/tree/0.3.1-deprecation.2) until the information is merged into the official repository.\n\nFor additional information and updates, please follow us on the [Flare forum](https://forum.flare.network/).\n\n:::",
    "meta_data": {
      "sidebar_position": 3,
      "slug": "ftso-data-provider",
      "title": "FTSO Data Provider",
      "description": "Provide block-latency and anchor feeds for FTSOv2."
    },
    "file_name": "files/hub-docs/run-node/3-ftso-data-provider.mdx",
    "type": "answer"
  },
  {
    "content": "import Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\n\nAn RPC node (also sometimes referred to as an observer node) is responsible for servicing application requests. Unlike [validator nodes](/run-node/validator-node), RPC nodes operate outside the network and do not influence consensus or block production. This guide will walk you through deploying an RPC node for Flare.\n\nYou have two options for setting up an RPC node, each with its own pros and cons:\n\n1. [Setup on bare-metal](#setup-on-bare-metal): More complex, but offers better performance and lower memory usage.\n\n2. [Setup with Docker](#setup-with-docker): Simpler, but results in lower performance and higher memory usage.\n\nimport Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\n\nAn RPC node (also sometimes referred to as an observer node) is responsible for servicing application requests. Unlike [validator nodes](/run-node/validator-node), RPC nodes operate outside the network and do not influence consensus or block production. This guide will walk you through deploying an RPC node for Flare.\n\nYou have two options for setting up an RPC node, each with its own pros and cons:\n\n1. [Setup on bare-metal](#setup-on-bare-metal): More complex, but offers better performance and lower memory usage.\n\n2. [Setup with Docker](#setup-with-docker): Simpler, but results in lower performance and higher memory usage.\n\nimport Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\n\nAn RPC node (also sometimes referred to as an observer node) is responsible for servicing application requests. Unlike [validator nodes](/run-node/validator-node), RPC nodes operate outside the network and do not influence consensus or block production. This guide will walk you through deploying an RPC node for Flare.\n\nYou have two options for setting up an RPC node, each with its own pros and cons:\n\n1. [Setup on bare-metal](#setup-on-bare-metal): More complex, but offers better performance and lower memory usage.\n\n2. [Setup with Docker](#setup-with-docker): Simpler, but results in lower performance and higher memory usage.\n\nimport Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\n\nAn RPC node (also sometimes referred to as an observer node) is responsible for servicing application requests. Unlike [validator nodes](/run-node/validator-node), RPC nodes operate outside the network and do not influence consensus or block production. This guide will walk you through deploying an RPC node for Flare.\n\nYou have two options for setting up an RPC node, each with its own pros and cons:\n\n1. [Setup on bare-metal](#setup-on-bare-metal): More complex, but offers better performance and lower memory usage.\n\n2. [Setup with Docker](#setup-with-docker): Simpler, but results in lower performance and higher memory usage.\n\nimport Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\n\nAn RPC node (also sometimes referred to as an observer node) is responsible for servicing application requests. Unlike [validator nodes](/run-node/validator-node), RPC nodes operate outside the network and do not influence consensus or block production. This guide will walk you through deploying an RPC node for Flare.\n\nYou have two options for setting up an RPC node, each with its own pros and cons:\n\n1. [Setup on bare-metal](#setup-on-bare-metal): More complex, but offers better performance and lower memory usage.\n\n2. [Setup with Docker](#setup-with-docker): Simpler, but results in lower performance and higher memory usage.",
    "file_name": "files/hub-docs/run-node/1-rpc-node.mdx",
    "meta_data": {
      "sidebar_position": 1,
      "slug": "rpc-node",
      "title": "RPC Node",
      "description": "Service application requests locally or publicly."
    },
    "type": "answer"
  },
  {
    "content": "import Step1 from \"/static/img/run-node-gcp-marketplace/step1-img.png\";\nimport Step2 from \"/static/img/run-node-gcp-marketplace/step2-img.png\";\nimport Step2_1 from \"/static/img/run-node-gcp-marketplace/step2-1-img.png\";\n\nDeploy blockchain nodes without the need to install dependencies or manage configuration files. The nodes come with a copy of the databases locally which drastically reduces bootstrap times. The machine images are available for Flare Mainnet, Flare Testnet Coston2, Songbird Canary-Network, Songbird Testnet Coston and several other networks.\n\nHead to [Google Cloud Marketplace](https://console.cloud.google.com/marketplace/product/flare-public/blockchain-machine-image-flare-network) to get started.\n\nimport Step1 from \"/static/img/run-node-gcp-marketplace/step1-img.png\";\nimport Step2 from \"/static/img/run-node-gcp-marketplace/step2-img.png\";\nimport Step2_1 from \"/static/img/run-node-gcp-marketplace/step2-1-img.png\";\n\nDeploy blockchain nodes without the need to install dependencies or manage configuration files. The nodes come with a copy of the databases locally which drastically reduces bootstrap times. The machine images are available for Flare Mainnet, Flare Testnet Coston2, Songbird Canary-Network, Songbird Testnet Coston and several other networks.\n\nHead to [Google Cloud Marketplace](https://console.cloud.google.com/marketplace/product/flare-public/blockchain-machine-image-flare-network) to get started.\n\nimport Step1 from \"/static/img/run-node-gcp-marketplace/step1-img.png\";\nimport Step2 from \"/static/img/run-node-gcp-marketplace/step2-img.png\";\nimport Step2_1 from \"/static/img/run-node-gcp-marketplace/step2-1-img.png\";\n\nDeploy blockchain nodes without the need to install dependencies or manage configuration files. The nodes come with a copy of the databases locally which drastically reduces bootstrap times. The machine images are available for Flare Mainnet, Flare Testnet Coston2, Songbird Canary-Network, Songbird Testnet Coston and several other networks.\n\nHead to [Google Cloud Marketplace](https://console.cloud.google.com/marketplace/product/flare-public/blockchain-machine-image-flare-network) to get started.\n\nimport Step1 from \"/static/img/run-node-gcp-marketplace/step1-img.png\";\nimport Step2 from \"/static/img/run-node-gcp-marketplace/step2-img.png\";\nimport Step2_1 from \"/static/img/run-node-gcp-marketplace/step2-1-img.png\";\n\nDeploy blockchain nodes without the need to install dependencies or manage configuration files. The nodes come with a copy of the databases locally which drastically reduces bootstrap times. The machine images are available for Flare Mainnet, Flare Testnet Coston2, Songbird Canary-Network, Songbird Testnet Coston and several other networks.\n\nHead to [Google Cloud Marketplace](https://console.cloud.google.com/marketplace/product/flare-public/blockchain-machine-image-flare-network) to get started.\n\nimport Step1 from \"/static/img/run-node-gcp-marketplace/step1-img.png\";\nimport Step2 from \"/static/img/run-node-gcp-marketplace/step2-img.png\";\nimport Step2_1 from \"/static/img/run-node-gcp-marketplace/step2-1-img.png\";\n\nDeploy blockchain nodes without the need to install dependencies or manage configuration files. The nodes come with a copy of the databases locally which drastically reduces bootstrap times. The machine images are available for Flare Mainnet, Flare Testnet Coston2, Songbird Canary-Network, Songbird Testnet Coston and several other networks.\n\nHead to [Google Cloud Marketplace](https://console.cloud.google.com/marketplace/product/flare-public/blockchain-machine-image-flare-network) to get started.\n\nimport Step1 from \"/static/img/run-node-gcp-marketplace/step1-img.png\";\nimport Step2 from \"/static/img/run-node-gcp-marketplace/step2-img.png\";\nimport Step2_1 from \"/static/img/run-node-gcp-marketplace/step2-1-img.png\";\n\nDeploy blockchain nodes without the need to install dependencies or manage configuration files. The nodes come with a copy of the databases locally which drastically reduces bootstrap times. The machine images are available for Flare Mainnet, Flare Testnet Coston2, Songbird Canary-Network, Songbird Testnet Coston and several other networks.\n\nHead to [Google Cloud Marketplace](https://console.cloud.google.com/marketplace/product/flare-public/blockchain-machine-image-flare-network) to get started.",
    "file_name": "files/hub-docs/run-node/5-GCP-marketplace-nodes.mdx",
    "meta_data": {
      "sidebar_position": 5,
      "slug": "gcp-marketplace-nodes",
      "title": "GCP Marketplace Nodes",
      "description": "Pre-configured blockchain nodes in GCP marketplace"
    },
    "type": "answer"
  },
  {
    "content": "import Step1 from \"/static/img/run-node-gcp-marketplace/step1-img.png\";\nimport Step2 from \"/static/img/run-node-gcp-marketplace/step2-img.png\";\nimport Step2_1 from \"/static/img/run-node-gcp-marketplace/step2-1-img.png\";\n\nDeploy blockchain nodes without the need to install dependencies or manage configuration files. The nodes come with a copy of the databases locally which drastically reduces bootstrap times. The machine images are available for Flare Mainnet, Flare Testnet Coston2, Songbird Canary-Network, Songbird Testnet Coston and several other networks.\n\nHead to [Google Cloud Marketplace](https://console.cloud.google.com/marketplace/product/flare-public/blockchain-machine-image-flare-network) to get started.\n\nimport Step1 from \"/static/img/run-node-gcp-marketplace/step1-img.png\";\nimport Step2 from \"/static/img/run-node-gcp-marketplace/step2-img.png\";\nimport Step2_1 from \"/static/img/run-node-gcp-marketplace/step2-1-img.png\";\n\nDeploy blockchain nodes without the need to install dependencies or manage configuration files. The nodes come with a copy of the databases locally which drastically reduces bootstrap times. The machine images are available for Flare Mainnet, Flare Testnet Coston2, Songbird Canary-Network, Songbird Testnet Coston and several other networks.\n\nHead to [Google Cloud Marketplace](https://console.cloud.google.com/marketplace/product/flare-public/blockchain-machine-image-flare-network) to get started.",
    "file_name": "files/hub-docs/run-node/5-GCP-marketplace-nodes.mdx",
    "meta_data": {
      "sidebar_position": 5,
      "slug": "gcp-marketplace-nodes",
      "title": "GCP Marketplace Nodes",
      "description": "Pre-configured blockchain nodes in GCP marketplace"
    },
    "type": "answer"
  },
  {
    "content": ":::info\n\nThe FDC Provider deployment is now integrated into the [`flare-systems-deployment`](https://github.com/flare-foundation/flare-systems-deployment) repository, which also supports FTSO deployments. Previously, deployments were managed through the `ftso-v2-provider-deployment` repository.\n\nThe older repository is being deprecated. While it remains available for legacy deployments on Flare or Songbird, transitioning to the updated repository is strongly recommended. Active development has shifted to the new repository, where all future updates and features will be introduced. You can find the deprecation notice and detailed upgrade instructions [here](https://github.com/flare-foundation/ftso-v2-provider-deployment/tree/0.3.1-deprecation.2) until the information is merged into the official repository.\n\nTo run the FDC Client, you must also deploy verifiers and nodes that the client depends on. The [`fdc-suite-deployment`](https://github.com/flare-foundation/fdc-suite-deployment) repository contains comprehensive instructions for setting up and deploying these components.\n\nIf you already operate some of the required nodes, you can connect the FDC Client to those existing nodes, ensuring that the configurations remain compatible to avoid any operational issues.\n\n:::",
    "meta_data": {
      "sidebar_position": 4,
      "slug": "fdc-attestation-provider",
      "title": "FDC Attestation Provider",
      "description": "Provide attestations for FDC."
    },
    "file_name": "files/hub-docs/run-node/4-fdc-attestation-provider.mdx",
    "type": "answer"
  },
  {
    "content": "import Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport ThemedImage from \"@theme/ThemedImage\";\nimport useBaseUrl from \"@docusaurus/useBaseUrl\";\nimport AutomatedRegistration from \"./_automated_registration.mdx\";\n\nThis guide provides a sample deployment configuration for infrastructure providers participating in the [Flare Systems Protocol (FSP)](https://dev.flare.network/network/fsp).\nThe FSP consists of [Flare Time Series Oracle (FTSO)](https://dev.flare.network/ftso/overview) and [Flare Data Connector (FDC)](https://dev.flare.network/fdc/overview).\n\n<ThemedImage\n  alt=\"Data Provider System for FSP\"\n  sources={{\n    light: useBaseUrl(\"/img/run-node-fsp/fsp_run_node_light.svg\"),\n    dark: useBaseUrl(\"/img/run-node-fsp/fsp_run_node_dark.svg\"),\n  }}\n/>\n\nAn FSP provider system consists of the following six components:\n\n1. **Flare System Client**: Manages interactions with FTSO smart contracts, including data collection, submission, voter registration, and system tasks.\n2. **C-chain Indexer**: Tracks FSP-related blockchain transactions and events, enabling data calculations and action triggers.\n3. **FTSO Client**: Provides anchor feed submissions and median data to the System Client.\n4. **Fast Updates Client**: Submits block-latency feeds to Fast Updates contracts.\n5. **Feed Value Provider**: Retrieves data from exchanges and supplies current feed values (prices).\n6. **FDC Client**: Provides FDC protocol voting round data to the System Client.\n\nimport Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport ThemedImage from \"@theme/ThemedImage\";\nimport useBaseUrl from \"@docusaurus/useBaseUrl\";\nimport AutomatedRegistration from \"./_automated_registration.mdx\";\n\nThis guide provides a sample deployment configuration for infrastructure providers participating in the [Flare Systems Protocol (FSP)](https://dev.flare.network/network/fsp).\nThe FSP consists of [Flare Time Series Oracle (FTSO)](https://dev.flare.network/ftso/overview) and [Flare Data Connector (FDC)](https://dev.flare.network/fdc/overview).\n\n<ThemedImage\n  alt=\"Data Provider System for FSP\"\n  sources={{\n    light: useBaseUrl(\"/img/run-node-fsp/fsp_run_node_light.svg\"),\n    dark: useBaseUrl(\"/img/run-node-fsp/fsp_run_node_dark.svg\"),\n  }}\n/>\n\nAn FSP provider system consists of the following six components:\n\n1. **Flare System Client**: Manages interactions with FTSO smart contracts, including data collection, submission, voter registration, and system tasks.\n2. **C-chain Indexer**: Tracks FSP-related blockchain transactions and events, enabling data calculations and action triggers.\n3. **FTSO Client**: Provides anchor feed submissions and median data to the System Client.\n4. **Fast Updates Client**: Submits block-latency feeds to Fast Updates contracts.\n5. **Feed Value Provider**: Retrieves data from exchanges and supplies current feed values (prices).\n6. **FDC Client**: Provides FDC protocol voting round data to the System Client.\n\nimport Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport ThemedImage from \"@theme/ThemedImage\";\nimport useBaseUrl from \"@docusaurus/useBaseUrl\";\nimport AutomatedRegistration from \"./_automated_registration.mdx\";\n\nThis guide provides a sample deployment configuration for infrastructure providers participating in the [Flare Systems Protocol (FSP)](https://dev.flare.network/network/fsp).\nThe FSP consists of [Flare Time Series Oracle (FTSO)](https://dev.flare.network/ftso/overview) and [Flare Data Connector (FDC)](https://dev.flare.network/fdc/overview).\n\n<ThemedImage\n  alt=\"Data Provider System for FSP\"\n  sources={{\n    light: useBaseUrl(\"/img/run-node-fsp/fsp_run_node_light.svg\"),\n    dark: useBaseUrl(\"/img/run-node-fsp/fsp_run_node_dark.svg\"),\n  }}\n/>\n\nAn FSP provider system consists of the following six components:\n\n1. **Flare System Client**: Manages interactions with FTSO smart contracts, including data collection, submission, voter registration, and system tasks.\n2. **C-chain Indexer**: Tracks FSP-related blockchain transactions and events, enabling data calculations and action triggers.\n3. **FTSO Client**: Provides anchor feed submissions and median data to the System Client.\n4. **Fast Updates Client**: Submits block-latency feeds to Fast Updates contracts.\n5. **Feed Value Provider**: Retrieves data from exchanges and supplies current feed values (prices).\n6. **FDC Client**: Provides FDC protocol voting round data to the System Client.",
    "file_name": "files/hub-docs/run-node/6-flare-systems-provider.mdx",
    "meta_data": {
      "sidebar_position": 6,
      "title": "Flare Systems Provider",
      "description": "Provide data for Flare's enshrined FTSO and FDC protocols.",
      "unlisted": true
    },
    "type": "answer"
  },
  {
    "content": "import Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport ThemedImage from \"@theme/ThemedImage\";\nimport useBaseUrl from \"@docusaurus/useBaseUrl\";\nimport AutomatedRegistration from \"./_automated_registration.mdx\";\n\nThis guide provides a sample deployment configuration for infrastructure providers participating in the [Flare Systems Protocol (FSP)](https://dev.flare.network/network/fsp).\nThe FSP consists of [Flare Time Series Oracle (FTSO)](https://dev.flare.network/ftso/overview) and [Flare Data Connector (FDC)](https://dev.flare.network/fdc/overview).\n\n<ThemedImage\n  alt=\"Data Provider System for FSP\"\n  sources={{\n    light: useBaseUrl(\"/img/run-node-fsp/fsp_run_node_light.svg\"),\n    dark: useBaseUrl(\"/img/run-node-fsp/fsp_run_node_dark.svg\"),\n  }}\n/>\n\nAn FSP provider system consists of the following six components:\n\n1. **Flare System Client**: Manages interactions with FTSO smart contracts, including data collection, submission, voter registration, and system tasks.\n2. **C-chain Indexer**: Tracks FSP-related blockchain transactions and events, enabling data calculations and action triggers.\n3. **FTSO Client**: Provides anchor feed submissions and median data to the System Client.\n4. **Fast Updates Client**: Submits block-latency feeds to Fast Updates contracts.\n5. **Feed Value Provider**: Retrieves data from exchanges and supplies current feed values (prices).\n6. **FDC Client**: Provides FDC protocol voting round data to the System Client.\n\nimport Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport ThemedImage from \"@theme/ThemedImage\";\nimport useBaseUrl from \"@docusaurus/useBaseUrl\";\nimport AutomatedRegistration from \"./_automated_registration.mdx\";\n\nThis guide provides a sample deployment configuration for infrastructure providers participating in the [Flare Systems Protocol (FSP)](https://dev.flare.network/network/fsp).\nThe FSP consists of [Flare Time Series Oracle (FTSO)](https://dev.flare.network/ftso/overview) and [Flare Data Connector (FDC)](https://dev.flare.network/fdc/overview).\n\n<ThemedImage\n  alt=\"Data Provider System for FSP\"\n  sources={{\n    light: useBaseUrl(\"/img/run-node-fsp/fsp_run_node_light.svg\"),\n    dark: useBaseUrl(\"/img/run-node-fsp/fsp_run_node_dark.svg\"),\n  }}\n/>\n\nAn FSP provider system consists of the following six components:\n\n1. **Flare System Client**: Manages interactions with FTSO smart contracts, including data collection, submission, voter registration, and system tasks.\n2. **C-chain Indexer**: Tracks FSP-related blockchain transactions and events, enabling data calculations and action triggers.\n3. **FTSO Client**: Provides anchor feed submissions and median data to the System Client.\n4. **Fast Updates Client**: Submits block-latency feeds to Fast Updates contracts.\n5. **Feed Value Provider**: Retrieves data from exchanges and supplies current feed values (prices).\n6. **FDC Client**: Provides FDC protocol voting round data to the System Client.\n\nimport Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport ThemedImage from \"@theme/ThemedImage\";\nimport useBaseUrl from \"@docusaurus/useBaseUrl\";\nimport AutomatedRegistration from \"./_automated_registration.mdx\";\n\nThis guide provides a sample deployment configuration for infrastructure providers participating in the [Flare Systems Protocol (FSP)](https://dev.flare.network/network/fsp).\nThe FSP consists of [Flare Time Series Oracle (FTSO)](https://dev.flare.network/ftso/overview) and [Flare Data Connector (FDC)](https://dev.flare.network/fdc/overview).\n\n<ThemedImage\n  alt=\"Data Provider System for FSP\"\n  sources={{\n    light: useBaseUrl(\"/img/run-node-fsp/fsp_run_node_light.svg\"),\n    dark: useBaseUrl(\"/img/run-node-fsp/fsp_run_node_dark.svg\"),\n  }}\n/>\n\nAn FSP provider system consists of the following six components:\n\n1. **Flare System Client**: Manages interactions with FTSO smart contracts, including data collection, submission, voter registration, and system tasks.\n2. **C-chain Indexer**: Tracks FSP-related blockchain transactions and events, enabling data calculations and action triggers.\n3. **FTSO Client**: Provides anchor feed submissions and median data to the System Client.\n4. **Fast Updates Client**: Submits block-latency feeds to Fast Updates contracts.\n5. **Feed Value Provider**: Retrieves data from exchanges and supplies current feed values (prices).\n6. **FDC Client**: Provides FDC protocol voting round data to the System Client.",
    "file_name": "files/hub-docs/run-node/6-flare-systems-provider.mdx",
    "meta_data": {
      "sidebar_position": 6,
      "title": "Flare Systems Provider",
      "description": "Provide data for Flare's enshrined FTSO and FDC protocols.",
      "unlisted": true
    },
    "type": "answer"
  },
  {
    "content": "import Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport ThemedImage from \"@theme/ThemedImage\";\nimport useBaseUrl from \"@docusaurus/useBaseUrl\";\nimport AutomatedRegistration from \"./_automated_registration.mdx\";\n\nThis guide provides a sample deployment configuration for infrastructure providers participating in the [Flare Systems Protocol (FSP)](https://dev.flare.network/network/fsp).\nThe FSP consists of [Flare Time Series Oracle (FTSO)](https://dev.flare.network/ftso/overview) and [Flare Data Connector (FDC)](https://dev.flare.network/fdc/overview).\n\n<ThemedImage\n  alt=\"Data Provider System for FSP\"\n  sources={{\n    light: useBaseUrl(\"/img/run-node-fsp/fsp_run_node_light.svg\"),\n    dark: useBaseUrl(\"/img/run-node-fsp/fsp_run_node_dark.svg\"),\n  }}\n/>\n\nAn FSP provider system consists of the following six components:\n\n1. **Flare System Client**: Manages interactions with FTSO smart contracts, including data collection, submission, voter registration, and system tasks.\n2. **C-chain Indexer**: Tracks FSP-related blockchain transactions and events, enabling data calculations and action triggers.\n3. **FTSO Client**: Provides anchor feed submissions and median data to the System Client.\n4. **Fast Updates Client**: Submits block-latency feeds to Fast Updates contracts.\n5. **Feed Value Provider**: Retrieves data from exchanges and supplies current feed values (prices).\n6. **FDC Client**: Provides FDC protocol voting round data to the System Client.\n\nimport Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport ThemedImage from \"@theme/ThemedImage\";\nimport useBaseUrl from \"@docusaurus/useBaseUrl\";\nimport AutomatedRegistration from \"./_automated_registration.mdx\";\n\nThis guide provides a sample deployment configuration for infrastructure providers participating in the [Flare Systems Protocol (FSP)](https://dev.flare.network/network/fsp).\nThe FSP consists of [Flare Time Series Oracle (FTSO)](https://dev.flare.network/ftso/overview) and [Flare Data Connector (FDC)](https://dev.flare.network/fdc/overview).\n\n<ThemedImage\n  alt=\"Data Provider System for FSP\"\n  sources={{\n    light: useBaseUrl(\"/img/run-node-fsp/fsp_run_node_light.svg\"),\n    dark: useBaseUrl(\"/img/run-node-fsp/fsp_run_node_dark.svg\"),\n  }}\n/>\n\nAn FSP provider system consists of the following six components:\n\n1. **Flare System Client**: Manages interactions with FTSO smart contracts, including data collection, submission, voter registration, and system tasks.\n2. **C-chain Indexer**: Tracks FSP-related blockchain transactions and events, enabling data calculations and action triggers.\n3. **FTSO Client**: Provides anchor feed submissions and median data to the System Client.\n4. **Fast Updates Client**: Submits block-latency feeds to Fast Updates contracts.\n5. **Feed Value Provider**: Retrieves data from exchanges and supplies current feed values (prices).\n6. **FDC Client**: Provides FDC protocol voting round data to the System Client.",
    "file_name": "files/hub-docs/run-node/6-flare-systems-provider.mdx",
    "meta_data": {
      "sidebar_position": 6,
      "title": "Flare Systems Provider",
      "description": "Provide data for Flare's enshrined FTSO and FDC protocols.",
      "unlisted": true
    },
    "type": "answer"
  },
  {
    "content": "import Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\n\nimport OperationalParameters from \"/src/components/FAssets/OperationalParameters\";\n\nThis page lists the current values for the most important parameters of the FAssets system on **Songbird Canary-Network** and **Songbird Testnet Coston**. These values are subject to change as the system is further developed and tested.\n\nimport Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\n\nimport OperationalParameters from \"/src/components/FAssets/OperationalParameters\";\n\nThis page lists the current values for the most important parameters of the FAssets system on **Songbird Canary-Network** and **Songbird Testnet Coston**. These values are subject to change as the system is further developed and tested.\n\nimport Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\n\nimport OperationalParameters from \"/src/components/FAssets/OperationalParameters\";\n\nThis page lists the current values for the most important parameters of the FAssets system on **Songbird Canary-Network** and **Songbird Testnet Coston**. These values are subject to change as the system is further developed and tested.",
    "file_name": "files/hub-docs/fassets/6-operational-parameters.mdx",
    "meta_data": {
      "title": "Operational Parameters",
      "slug": "operational-parameters",
      "description": "Songbird FAssets Operational Parameters",
      "keywords": [
        "fassets",
        "xrp",
        "bitcoin",
        "dogecoin",
        "flare-network"
      ]
    },
    "type": "answer"
  },
  {
    "content": "import JiraIssueCollector from \"/src/components/JiraIssueCollector\";\n\nThe launch of FAssets on Songbird Canary-Network demonstrates system behavior while paving the way for its next deployment on Flare Mainnet. The primary goals of this test are to ensure the system operates as intended, identify edge cases, refine usability and automation, and incentivize whitehat security researchers to uncover potential code errors.\n\nThe test on Songbird Canary-Network will have the following characteristics:\n\n| Parameters                          | Description                                                                                                                                                                                                                              |\n| ----------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| FAsset Sequence                     | XRP will be tested first, followed by either BTC or DOGE.                                                                                                                                                                                |\n| Agent Whitelisting                  | FAssets agents must be whitelisted by Flare Labs to perform their roles.                                                                                                                                                                 |\n| Caps and Losses                     | Flare Labs will underwrite up to \\$300,000 in FAsset issuance to cover any losses resulting from system issues, while imposing a cap of $2 million in issuance per asset.                                                                |\n| Duration of the Test                | Each FAsset will be tested on Songbird for at least 6 weeks until no issues have been found.                                                                                                                                             |\n| FAssets Minting dApps               | FAssets system users can access the frontend web interface for minting and redeeming: <br/> - [`https://fasset.oracle-daemon.com/sgb`](https://fasset.oracle-daemon.com/sgb) <br /> - [`https://fassets.au.cc/`](https://fassets.au.cc/) |\n| System Integrity and FAsset Pricing | During the Songbird test, restrictions and incentives may cause the FAsset price to deviate from the underlying currency's value. The current focus is on testing system integrity, not price alignment.                                 |\n| Vault Collateral                    | USDX will serve as collateral for FAsset agent vaults. To ensure sufficient support for FAsset issuance and possible liquidations on Songbird, a large amount of USDX has been minted.                                                   |\n\n:::tip[Help improve FAssets]\n\nTo participate, begin by joining the Flare Network FAssets Songbird [Telegram channel](https://t.me/FlareSupport) or contact [support@flarelabs.org](mailto:support@flarelabs.org).\n\n<JiraIssueCollector />\n\n:::",
    "meta_data": {
      "title": "FAssets on Songbird",
      "description": "Participate in the FAssets open beta.",
      "keywords": [
        "fassets",
        "xrp",
        "bitcoin",
        "dogecoin",
        "flare-network"
      ]
    },
    "file_name": "files/hub-docs/fassets/7-songbird.mdx",
    "type": "answer"
  },
  {
    "content": "import Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport DocCardList from \"@theme/DocCardList\";\nimport SolidityReference from \"@site/src/components/DataTables/SolidityReference\";\n\nimport Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport DocCardList from \"@theme/DocCardList\";\nimport SolidityReference from \"@site/src/components/DataTables/SolidityReference\";\n\nimport Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport DocCardList from \"@theme/DocCardList\";\nimport SolidityReference from \"@site/src/components/DataTables/SolidityReference\";",
    "file_name": "files/hub-docs/fassets/8-reference.mdx",
    "meta_data": {
      "title": "FAssets Reference",
      "description": "Solidity reference for FAssets smart contracts.",
      "keywords": [
        "solidity",
        "reference",
        "fassets",
        "xrp",
        "bitcoin",
        "dogecoin",
        "flare-network",
        "smart-contracts"
      ]
    },
    "type": "answer"
  },
  {
    "content": "import ThemedImage from \"@theme/ThemedImage\";\nimport useBaseUrl from \"@docusaurus/useBaseUrl\";\n\nFAssets is a trustless, over-collateralized bridge connecting non smart contract networks to Flare.\nIt enables the creation of wrapped tokens (`FAssets`) for assets like BTC, DOGE and XRP.\nThese tokens can participate in Flare's DeFi ecosystem or be redeemed for their original assets.\n\nFAssets are powered by Flare's enshrined data protocols:\n\n- **[Flare Time Series Oracle (FTSO)](/ftso/overview):** Provides decentralized price feeds.\n- **[Flare Data Connector (FDC)](/fdc/overview):** Verifies off-chain actions, such as transactions on other blockchains.\n\nEach FAsset is backed by a mix of collateral, including:\n\n1. Stablecoin or ETH collateral.\n2. FLR (Flare's native token) or SGB (Songbird's native token) collateral.\n\nAgents and a community-provided collateral pool ensure trustlessness through over-collateralization.\n\nimport ThemedImage from \"@theme/ThemedImage\";\nimport useBaseUrl from \"@docusaurus/useBaseUrl\";\n\nFAssets is a trustless, over-collateralized bridge connecting non smart contract networks to Flare.\nIt enables the creation of wrapped tokens (`FAssets`) for assets like BTC, DOGE and XRP.\nThese tokens can participate in Flare's DeFi ecosystem or be redeemed for their original assets.\n\nFAssets are powered by Flare's enshrined data protocols:\n\n- **[Flare Time Series Oracle (FTSO)](/ftso/overview):** Provides decentralized price feeds.\n- **[Flare Data Connector (FDC)](/fdc/overview):** Verifies off-chain actions, such as transactions on other blockchains.\n\nEach FAsset is backed by a mix of collateral, including:\n\n1. Stablecoin or ETH collateral.\n2. FLR (Flare's native token) or SGB (Songbird's native token) collateral.\n\nAgents and a community-provided collateral pool ensure trustlessness through over-collateralization.\n\nimport ThemedImage from \"@theme/ThemedImage\";\nimport useBaseUrl from \"@docusaurus/useBaseUrl\";\n\nFAssets is a trustless, over-collateralized bridge connecting non smart contract networks to Flare.\nIt enables the creation of wrapped tokens (`FAssets`) for assets like BTC, DOGE and XRP.\nThese tokens can participate in Flare's DeFi ecosystem or be redeemed for their original assets.\n\nFAssets are powered by Flare's enshrined data protocols:\n\n- **[Flare Time Series Oracle (FTSO)](/ftso/overview):** Provides decentralized price feeds.\n- **[Flare Data Connector (FDC)](/fdc/overview):** Verifies off-chain actions, such as transactions on other blockchains.\n\nEach FAsset is backed by a mix of collateral, including:\n\n1. Stablecoin or ETH collateral.\n2. FLR (Flare's native token) or SGB (Songbird's native token) collateral.\n\nAgents and a community-provided collateral pool ensure trustlessness through over-collateralization.",
    "file_name": "files/hub-docs/fassets/1-overview.mdx",
    "meta_data": {
      "title": "FAssets",
      "description": "FAssets is a trustless over-collateralized bridge to non smart contract networks to Flare.",
      "keywords": [
        "fassets",
        "xrp",
        "bitcoin",
        "dogecoin",
        "flare-network"
      ]
    },
    "type": "answer"
  },
  {
    "content": "import ThemedImage from \"@theme/ThemedImage\";\nimport useBaseUrl from \"@docusaurus/useBaseUrl\";\n\nFAssets collateral is locked in contracts that ensure the minted FAssets can always be redeemed for the underlying assets they represent or compensated by collateral.\nAlong with Flare's native token, FLR, any governance approved ERC-20 token on the Flare blockchain can be used as collateral.\n\nFAssets collateral ensures the security and redemption of minted FAssets by locking collateral in smart contracts. This guarantees that FAssets can either be redeemed for their underlying assets or compensated by collateral. Collateral can include Flare's native token (FLR) and any governance-approved ERC-20 tokens on the Flare blockchain.\n\nimport ThemedImage from \"@theme/ThemedImage\";\nimport useBaseUrl from \"@docusaurus/useBaseUrl\";\n\nFAssets collateral is locked in contracts that ensure the minted FAssets can always be redeemed for the underlying assets they represent or compensated by collateral.\nAlong with Flare's native token, FLR, any governance approved ERC-20 token on the Flare blockchain can be used as collateral.\n\nFAssets collateral ensures the security and redemption of minted FAssets by locking collateral in smart contracts. This guarantees that FAssets can either be redeemed for their underlying assets or compensated by collateral. Collateral can include Flare's native token (FLR) and any governance-approved ERC-20 tokens on the Flare blockchain.\n\nimport ThemedImage from \"@theme/ThemedImage\";\nimport useBaseUrl from \"@docusaurus/useBaseUrl\";\n\nFAssets collateral is locked in contracts that ensure the minted FAssets can always be redeemed for the underlying assets they represent or compensated by collateral.\nAlong with Flare's native token, FLR, any governance approved ERC-20 token on the Flare blockchain can be used as collateral.\n\nFAssets collateral ensures the security and redemption of minted FAssets by locking collateral in smart contracts. This guarantees that FAssets can either be redeemed for their underlying assets or compensated by collateral. Collateral can include Flare's native token (FLR) and any governance-approved ERC-20 tokens on the Flare blockchain.\n\nimport ThemedImage from \"@theme/ThemedImage\";\nimport useBaseUrl from \"@docusaurus/useBaseUrl\";\n\nFAssets collateral is locked in contracts that ensure the minted FAssets can always be redeemed for the underlying assets they represent or compensated by collateral.\nAlong with Flare's native token, FLR, any governance approved ERC-20 token on the Flare blockchain can be used as collateral.\n\nFAssets collateral ensures the security and redemption of minted FAssets by locking collateral in smart contracts. This guarantees that FAssets can either be redeemed for their underlying assets or compensated by collateral. Collateral can include Flare's native token (FLR) and any governance-approved ERC-20 tokens on the Flare blockchain.\n\nimport ThemedImage from \"@theme/ThemedImage\";\nimport useBaseUrl from \"@docusaurus/useBaseUrl\";\n\nFAssets collateral is locked in contracts that ensure the minted FAssets can always be redeemed for the underlying assets they represent or compensated by collateral.\nAlong with Flare's native token, FLR, any governance approved ERC-20 token on the Flare blockchain can be used as collateral.\n\nFAssets collateral ensures the security and redemption of minted FAssets by locking collateral in smart contracts. This guarantees that FAssets can either be redeemed for their underlying assets or compensated by collateral. Collateral can include Flare's native token (FLR) and any governance-approved ERC-20 tokens on the Flare blockchain.\n\nimport ThemedImage from \"@theme/ThemedImage\";\nimport useBaseUrl from \"@docusaurus/useBaseUrl\";\n\nFAssets collateral is locked in contracts that ensure the minted FAssets can always be redeemed for the underlying assets they represent or compensated by collateral.\nAlong with Flare's native token, FLR, any governance approved ERC-20 token on the Flare blockchain can be used as collateral.\n\nFAssets collateral ensures the security and redemption of minted FAssets by locking collateral in smart contracts. This guarantees that FAssets can either be redeemed for their underlying assets or compensated by collateral. Collateral can include Flare's native token (FLR) and any governance-approved ERC-20 tokens on the Flare blockchain.",
    "file_name": "files/hub-docs/fassets/2-collateral.mdx",
    "meta_data": {
      "title": "Collateral",
      "description": "Understand how collateral works in FAssets.",
      "keywords": [
        "fassets",
        "xrp",
        "bitcoin",
        "dogecoin",
        "flare-network"
      ]
    },
    "type": "answer"
  },
  {
    "content": "import ThemedImage from \"@theme/ThemedImage\";\nimport useBaseUrl from \"@docusaurus/useBaseUrl\";\n\nFAssets collateral is locked in contracts that ensure the minted FAssets can always be redeemed for the underlying assets they represent or compensated by collateral.\nAlong with Flare's native token, FLR, any governance approved ERC-20 token on the Flare blockchain can be used as collateral.\n\nFAssets collateral ensures the security and redemption of minted FAssets by locking collateral in smart contracts. This guarantees that FAssets can either be redeemed for their underlying assets or compensated by collateral. Collateral can include Flare's native token (FLR) and any governance-approved ERC-20 tokens on the Flare blockchain.\n\nimport ThemedImage from \"@theme/ThemedImage\";\nimport useBaseUrl from \"@docusaurus/useBaseUrl\";\n\nFAssets collateral is locked in contracts that ensure the minted FAssets can always be redeemed for the underlying assets they represent or compensated by collateral.\nAlong with Flare's native token, FLR, any governance approved ERC-20 token on the Flare blockchain can be used as collateral.\n\nFAssets collateral ensures the security and redemption of minted FAssets by locking collateral in smart contracts. This guarantees that FAssets can either be redeemed for their underlying assets or compensated by collateral. Collateral can include Flare's native token (FLR) and any governance-approved ERC-20 tokens on the Flare blockchain.",
    "file_name": "files/hub-docs/fassets/2-collateral.mdx",
    "meta_data": {
      "title": "Collateral",
      "description": "Understand how collateral works in FAssets.",
      "keywords": [
        "fassets",
        "xrp",
        "bitcoin",
        "dogecoin",
        "flare-network"
      ]
    },
    "type": "answer"
  },
  {
    "content": "Liquidation is the process of selling assets to bring the FAssets system back to health after an [agent](/fassets/overview#agents) becomes undercollateralized. The following types of liquidation can occur:\n\n- **Unhealthy position liquidation**: Occurs when the [collateral ratio (CR)](/fassets/collateral#collateral-ratio) of either the agent's vault or collateral pool falls below its respective [minimal CR](/fassets/collateral#system-wide-thresholds).\n  In this case, the agent's position is liquidated until the collateral ratio reaches the [safety CR](/fassets/collateral#system-wide-thresholds) or all of the backed FAssets are liquidated.\n- **Full liquidation**: Occurs when the agent makes an [illegal payment](#illegal-payments) from the underlying chain address.\n  In this case, all the FAssets backed by the agent are liquidated, and the liquidation cannot be stopped.\n\nIn both cases, [liquidators](/fassets/overview#liquidators), who can be anyone who holds FAssets, are encouraged to sell their FAssets back to the system.\nThey will be paid with the agent's collateral plus a premium, as a penalty against the agent for unhealthy positions or misconduct.\n\nLiquidation is the process of selling assets to bring the FAssets system back to health after an [agent](/fassets/overview#agents) becomes undercollateralized. The following types of liquidation can occur:\n\n- **Unhealthy position liquidation**: Occurs when the [collateral ratio (CR)](/fassets/collateral#collateral-ratio) of either the agent's vault or collateral pool falls below its respective [minimal CR](/fassets/collateral#system-wide-thresholds).\n  In this case, the agent's position is liquidated until the collateral ratio reaches the [safety CR](/fassets/collateral#system-wide-thresholds) or all of the backed FAssets are liquidated.\n- **Full liquidation**: Occurs when the agent makes an [illegal payment](#illegal-payments) from the underlying chain address.\n  In this case, all the FAssets backed by the agent are liquidated, and the liquidation cannot be stopped.\n\nIn both cases, [liquidators](/fassets/overview#liquidators), who can be anyone who holds FAssets, are encouraged to sell their FAssets back to the system.\nThey will be paid with the agent's collateral plus a premium, as a penalty against the agent for unhealthy positions or misconduct.\n\nLiquidation is the process of selling assets to bring the FAssets system back to health after an [agent](/fassets/overview#agents) becomes undercollateralized. The following types of liquidation can occur:\n\n- **Unhealthy position liquidation**: Occurs when the [collateral ratio (CR)](/fassets/collateral#collateral-ratio) of either the agent's vault or collateral pool falls below its respective [minimal CR](/fassets/collateral#system-wide-thresholds).\n  In this case, the agent's position is liquidated until the collateral ratio reaches the [safety CR](/fassets/collateral#system-wide-thresholds) or all of the backed FAssets are liquidated.\n- **Full liquidation**: Occurs when the agent makes an [illegal payment](#illegal-payments) from the underlying chain address.\n  In this case, all the FAssets backed by the agent are liquidated, and the liquidation cannot be stopped.\n\nIn both cases, [liquidators](/fassets/overview#liquidators), who can be anyone who holds FAssets, are encouraged to sell their FAssets back to the system.\nThey will be paid with the agent's collateral plus a premium, as a penalty against the agent for unhealthy positions or misconduct.\n\nLiquidation is the process of selling assets to bring the FAssets system back to health after an [agent](/fassets/overview#agents) becomes undercollateralized. The following types of liquidation can occur:\n\n- **Unhealthy position liquidation**: Occurs when the [collateral ratio (CR)](/fassets/collateral#collateral-ratio) of either the agent's vault or collateral pool falls below its respective [minimal CR](/fassets/collateral#system-wide-thresholds).\n  In this case, the agent's position is liquidated until the collateral ratio reaches the [safety CR](/fassets/collateral#system-wide-thresholds) or all of the backed FAssets are liquidated.\n- **Full liquidation**: Occurs when the agent makes an [illegal payment](#illegal-payments) from the underlying chain address.\n  In this case, all the FAssets backed by the agent are liquidated, and the liquidation cannot be stopped.\n\nIn both cases, [liquidators](/fassets/overview#liquidators), who can be anyone who holds FAssets, are encouraged to sell their FAssets back to the system.\nThey will be paid with the agent's collateral plus a premium, as a penalty against the agent for unhealthy positions or misconduct.",
    "file_name": "files/hub-docs/fassets/5-liquidation.mdx",
    "meta_data": {
      "title": "Liquidation",
      "description": "Understand how liquidations work in FAssets.",
      "keywords": [
        "fassets",
        "xrp",
        "bitcoin",
        "dogecoin",
        "flare-network"
      ]
    },
    "type": "answer"
  },
  {
    "content": "Liquidation is the process of selling assets to bring the FAssets system back to health after an [agent](/fassets/overview#agents) becomes undercollateralized. The following types of liquidation can occur:\n\n- **Unhealthy position liquidation**: Occurs when the [collateral ratio (CR)](/fassets/collateral#collateral-ratio) of either the agent's vault or collateral pool falls below its respective [minimal CR](/fassets/collateral#system-wide-thresholds).\n  In this case, the agent's position is liquidated until the collateral ratio reaches the [safety CR](/fassets/collateral#system-wide-thresholds) or all of the backed FAssets are liquidated.\n- **Full liquidation**: Occurs when the agent makes an [illegal payment](#illegal-payments) from the underlying chain address.\n  In this case, all the FAssets backed by the agent are liquidated, and the liquidation cannot be stopped.\n\nIn both cases, [liquidators](/fassets/overview#liquidators), who can be anyone who holds FAssets, are encouraged to sell their FAssets back to the system.\nThey will be paid with the agent's collateral plus a premium, as a penalty against the agent for unhealthy positions or misconduct.",
    "file_name": "files/hub-docs/fassets/5-liquidation.mdx",
    "meta_data": {
      "title": "Liquidation",
      "description": "Understand how liquidations work in FAssets.",
      "keywords": [
        "fassets",
        "xrp",
        "bitcoin",
        "dogecoin",
        "flare-network"
      ]
    },
    "type": "answer"
  },
  {
    "content": "Minting FAssets is the process of wrapping underlying tokens from connected blockchains into FAssets to be used on the Flare blockchain.\nAny user can mint FAssets.\n\nMinting FAssets is the process of wrapping underlying tokens from connected blockchains into FAssets to be used on the Flare blockchain.\nAny user can mint FAssets.\n\nMinting FAssets is the process of wrapping underlying tokens from connected blockchains into FAssets to be used on the Flare blockchain.\nAny user can mint FAssets.\n\nMinting FAssets is the process of wrapping underlying tokens from connected blockchains into FAssets to be used on the Flare blockchain.\nAny user can mint FAssets.\n\nMinting FAssets is the process of wrapping underlying tokens from connected blockchains into FAssets to be used on the Flare blockchain.\nAny user can mint FAssets.\n\nMinting FAssets is the process of wrapping underlying tokens from connected blockchains into FAssets to be used on the Flare blockchain.\nAny user can mint FAssets.\n\nMinting FAssets is the process of wrapping underlying tokens from connected blockchains into FAssets to be used on the Flare blockchain.\nAny user can mint FAssets.\n\nMinting FAssets is the process of wrapping underlying tokens from connected blockchains into FAssets to be used on the Flare blockchain.\nAny user can mint FAssets.\n\nMinting FAssets is the process of wrapping underlying tokens from connected blockchains into FAssets to be used on the Flare blockchain.\nAny user can mint FAssets.\n\nMinting FAssets is the process of wrapping underlying tokens from connected blockchains into FAssets to be used on the Flare blockchain.\nAny user can mint FAssets.\n\nMinting FAssets is the process of wrapping underlying tokens from connected blockchains into FAssets to be used on the Flare blockchain.\nAny user can mint FAssets.\n\nMinting FAssets is the process of wrapping underlying tokens from connected blockchains into FAssets to be used on the Flare blockchain.\nAny user can mint FAssets.",
    "file_name": "files/hub-docs/fassets/3-minting.mdx",
    "meta_data": {
      "title": "Minting",
      "description": "Understand how minting works in FAssets.",
      "keywords": [
        "fassets",
        "xrp",
        "bitcoin",
        "dogecoin",
        "flare-network"
      ]
    },
    "type": "answer"
  },
  {
    "content": "Any holder of FAssets can redeem their FAssets for the underlying original asset.\nTo do so, these holders, known as redeemers, send FAssets to the Asset Manager smart contract, and the redeemed amount is paid with the underlying asset from an agent's address.\n\nAny holder of FAssets can redeem their FAssets for the underlying original asset.\nTo do so, these holders, known as redeemers, send FAssets to the Asset Manager smart contract, and the redeemed amount is paid with the underlying asset from an agent's address.\n\nAny holder of FAssets can redeem their FAssets for the underlying original asset.\nTo do so, these holders, known as redeemers, send FAssets to the Asset Manager smart contract, and the redeemed amount is paid with the underlying asset from an agent's address.\n\nAny holder of FAssets can redeem their FAssets for the underlying original asset.\nTo do so, these holders, known as redeemers, send FAssets to the Asset Manager smart contract, and the redeemed amount is paid with the underlying asset from an agent's address.\n\nAny holder of FAssets can redeem their FAssets for the underlying original asset.\nTo do so, these holders, known as redeemers, send FAssets to the Asset Manager smart contract, and the redeemed amount is paid with the underlying asset from an agent's address.\n\nAny holder of FAssets can redeem their FAssets for the underlying original asset.\nTo do so, these holders, known as redeemers, send FAssets to the Asset Manager smart contract, and the redeemed amount is paid with the underlying asset from an agent's address.",
    "file_name": "files/hub-docs/fassets/4-redemption.mdx",
    "meta_data": {
      "title": "Redemption",
      "description": "Understand how redemptions work in FAssets.",
      "keywords": [
        "fassets",
        "xrp",
        "bitcoin",
        "dogecoin",
        "flare-network"
      ]
    },
    "type": "answer"
  },
  {
    "content": "import CodeBlock from \"@theme/CodeBlock\";\nimport FtsoV2MigrationExample from \"!!raw-loader!/examples/developer-hub-solidity/FtsoV2MigrationExample.sol\";\n\nThis guide is for applications moving from FTSOv1 to FTSOv2. Briefly, FTSOv2 comprises of:\n\n- **[Block-Latency Feeds](/ftso/feeds)**: These feeds are updated with each new block, approximately every 1.8 seconds. They can be accessed through [FtsoV2Interface](/ftso/solidity-reference/FtsoV2Interface) and are available directly on-chain.\n- **[Anchor Feeds](/ftso/scaling/anchor-feeds)**: These feeds are provided through [Scaling](/ftso/scaling/overview) with a latency of 90 seconds. Feeds can be verified using [FtsoV2Interface](/ftso/solidity-reference/FtsoV2Interface) but are not immediately available on-chain.\n\nA key difference between the two is the introduction of a payment mechanism for data access. This system helps prevent unnecessary data requests and ensures sustainable funding. For more details, refer to the [`IFeeCalculator`](/ftso/solidity-reference/IFeeCalculator) contract, which calculates fees for data access using the [`calculateFeeByIds`](/ftso/solidity-reference/IFeeCalculator#calculatefeebyids) method.\n\nAdditionally, a new Long Term Support (LTS) system has been launched to ensure continued access to essential data and metadata within the Flare ecosystem. A series of [LTS interfaces](#lts-interfaces) have been introduced, each aligned with a specific product in the Flare ecosystem. It is strongly recommended to use these LTS contracts for data access instead of querying individual contracts or interfaces, as they are designed for long-term stability, even as underlying protocols evolve or migrate.\n\nimport CodeBlock from \"@theme/CodeBlock\";\nimport FtsoV2MigrationExample from \"!!raw-loader!/examples/developer-hub-solidity/FtsoV2MigrationExample.sol\";\n\nThis guide is for applications moving from FTSOv1 to FTSOv2. Briefly, FTSOv2 comprises of:\n\n- **[Block-Latency Feeds](/ftso/feeds)**: These feeds are updated with each new block, approximately every 1.8 seconds. They can be accessed through [FtsoV2Interface](/ftso/solidity-reference/FtsoV2Interface) and are available directly on-chain.\n- **[Anchor Feeds](/ftso/scaling/anchor-feeds)**: These feeds are provided through [Scaling](/ftso/scaling/overview) with a latency of 90 seconds. Feeds can be verified using [FtsoV2Interface](/ftso/solidity-reference/FtsoV2Interface) but are not immediately available on-chain.\n\nA key difference between the two is the introduction of a payment mechanism for data access. This system helps prevent unnecessary data requests and ensures sustainable funding. For more details, refer to the [`IFeeCalculator`](/ftso/solidity-reference/IFeeCalculator) contract, which calculates fees for data access using the [`calculateFeeByIds`](/ftso/solidity-reference/IFeeCalculator#calculatefeebyids) method.\n\nAdditionally, a new Long Term Support (LTS) system has been launched to ensure continued access to essential data and metadata within the Flare ecosystem. A series of [LTS interfaces](#lts-interfaces) have been introduced, each aligned with a specific product in the Flare ecosystem. It is strongly recommended to use these LTS contracts for data access instead of querying individual contracts or interfaces, as they are designed for long-term stability, even as underlying protocols evolve or migrate.",
    "file_name": "files/hub-docs/ftso/5-migration.mdx",
    "meta_data": {
      "title": "Migrating from v1",
      "slug": "migration",
      "description": "Migration guide for dApps moving from FTSOv1 to FTSOv2.",
      "keywords": [
        "solidity",
        "ftso",
        "flare-time-series-oracle",
        "flare-network",
        "smart-contracts"
      ]
    },
    "type": "answer"
  },
  {
    "content": "import CodeBlock from \"@theme/CodeBlock\";\nimport FtsoV2MigrationExample from \"!!raw-loader!/examples/developer-hub-solidity/FtsoV2MigrationExample.sol\";\n\nThis guide is for applications moving from FTSOv1 to FTSOv2. Briefly, FTSOv2 comprises of:\n\n- **[Block-Latency Feeds](/ftso/feeds)**: These feeds are updated with each new block, approximately every 1.8 seconds. They can be accessed through [FtsoV2Interface](/ftso/solidity-reference/FtsoV2Interface) and are available directly on-chain.\n- **[Anchor Feeds](/ftso/scaling/anchor-feeds)**: These feeds are provided through [Scaling](/ftso/scaling/overview) with a latency of 90 seconds. Feeds can be verified using [FtsoV2Interface](/ftso/solidity-reference/FtsoV2Interface) but are not immediately available on-chain.\n\nA key difference between the two is the introduction of a payment mechanism for data access. This system helps prevent unnecessary data requests and ensures sustainable funding. For more details, refer to the [`IFeeCalculator`](/ftso/solidity-reference/IFeeCalculator) contract, which calculates fees for data access using the [`calculateFeeByIds`](/ftso/solidity-reference/IFeeCalculator#calculatefeebyids) method.\n\nAdditionally, a new Long Term Support (LTS) system has been launched to ensure continued access to essential data and metadata within the Flare ecosystem. A series of [LTS interfaces](#lts-interfaces) have been introduced, each aligned with a specific product in the Flare ecosystem. It is strongly recommended to use these LTS contracts for data access instead of querying individual contracts or interfaces, as they are designed for long-term stability, even as underlying protocols evolve or migrate.\n\nimport CodeBlock from \"@theme/CodeBlock\";\nimport FtsoV2MigrationExample from \"!!raw-loader!/examples/developer-hub-solidity/FtsoV2MigrationExample.sol\";\n\nThis guide is for applications moving from FTSOv1 to FTSOv2. Briefly, FTSOv2 comprises of:\n\n- **[Block-Latency Feeds](/ftso/feeds)**: These feeds are updated with each new block, approximately every 1.8 seconds. They can be accessed through [FtsoV2Interface](/ftso/solidity-reference/FtsoV2Interface) and are available directly on-chain.\n- **[Anchor Feeds](/ftso/scaling/anchor-feeds)**: These feeds are provided through [Scaling](/ftso/scaling/overview) with a latency of 90 seconds. Feeds can be verified using [FtsoV2Interface](/ftso/solidity-reference/FtsoV2Interface) but are not immediately available on-chain.\n\nA key difference between the two is the introduction of a payment mechanism for data access. This system helps prevent unnecessary data requests and ensures sustainable funding. For more details, refer to the [`IFeeCalculator`](/ftso/solidity-reference/IFeeCalculator) contract, which calculates fees for data access using the [`calculateFeeByIds`](/ftso/solidity-reference/IFeeCalculator#calculatefeebyids) method.\n\nAdditionally, a new Long Term Support (LTS) system has been launched to ensure continued access to essential data and metadata within the Flare ecosystem. A series of [LTS interfaces](#lts-interfaces) have been introduced, each aligned with a specific product in the Flare ecosystem. It is strongly recommended to use these LTS contracts for data access instead of querying individual contracts or interfaces, as they are designed for long-term stability, even as underlying protocols evolve or migrate.",
    "file_name": "files/hub-docs/ftso/5-migration.mdx",
    "meta_data": {
      "title": "Migrating from v1",
      "slug": "migration",
      "description": "Migration guide for dApps moving from FTSOv1 to FTSOv2.",
      "keywords": [
        "solidity",
        "ftso",
        "flare-time-series-oracle",
        "flare-network",
        "smart-contracts"
      ]
    },
    "type": "answer"
  },
  {
    "content": "import CodeBlock from \"@theme/CodeBlock\";\nimport FtsoV2MigrationExample from \"!!raw-loader!/examples/developer-hub-solidity/FtsoV2MigrationExample.sol\";\n\nThis guide is for applications moving from FTSOv1 to FTSOv2. Briefly, FTSOv2 comprises of:\n\n- **[Block-Latency Feeds](/ftso/feeds)**: These feeds are updated with each new block, approximately every 1.8 seconds. They can be accessed through [FtsoV2Interface](/ftso/solidity-reference/FtsoV2Interface) and are available directly on-chain.\n- **[Anchor Feeds](/ftso/scaling/anchor-feeds)**: These feeds are provided through [Scaling](/ftso/scaling/overview) with a latency of 90 seconds. Feeds can be verified using [FtsoV2Interface](/ftso/solidity-reference/FtsoV2Interface) but are not immediately available on-chain.\n\nA key difference between the two is the introduction of a payment mechanism for data access. This system helps prevent unnecessary data requests and ensures sustainable funding. For more details, refer to the [`IFeeCalculator`](/ftso/solidity-reference/IFeeCalculator) contract, which calculates fees for data access using the [`calculateFeeByIds`](/ftso/solidity-reference/IFeeCalculator#calculatefeebyids) method.\n\nAdditionally, a new Long Term Support (LTS) system has been launched to ensure continued access to essential data and metadata within the Flare ecosystem. A series of [LTS interfaces](#lts-interfaces) have been introduced, each aligned with a specific product in the Flare ecosystem. It is strongly recommended to use these LTS contracts for data access instead of querying individual contracts or interfaces, as they are designed for long-term stability, even as underlying protocols evolve or migrate.\n\nimport CodeBlock from \"@theme/CodeBlock\";\nimport FtsoV2MigrationExample from \"!!raw-loader!/examples/developer-hub-solidity/FtsoV2MigrationExample.sol\";\n\nThis guide is for applications moving from FTSOv1 to FTSOv2. Briefly, FTSOv2 comprises of:\n\n- **[Block-Latency Feeds](/ftso/feeds)**: These feeds are updated with each new block, approximately every 1.8 seconds. They can be accessed through [FtsoV2Interface](/ftso/solidity-reference/FtsoV2Interface) and are available directly on-chain.\n- **[Anchor Feeds](/ftso/scaling/anchor-feeds)**: These feeds are provided through [Scaling](/ftso/scaling/overview) with a latency of 90 seconds. Feeds can be verified using [FtsoV2Interface](/ftso/solidity-reference/FtsoV2Interface) but are not immediately available on-chain.\n\nA key difference between the two is the introduction of a payment mechanism for data access. This system helps prevent unnecessary data requests and ensures sustainable funding. For more details, refer to the [`IFeeCalculator`](/ftso/solidity-reference/IFeeCalculator) contract, which calculates fees for data access using the [`calculateFeeByIds`](/ftso/solidity-reference/IFeeCalculator#calculatefeebyids) method.\n\nAdditionally, a new Long Term Support (LTS) system has been launched to ensure continued access to essential data and metadata within the Flare ecosystem. A series of [LTS interfaces](#lts-interfaces) have been introduced, each aligned with a specific product in the Flare ecosystem. It is strongly recommended to use these LTS contracts for data access instead of querying individual contracts or interfaces, as they are designed for long-term stability, even as underlying protocols evolve or migrate.",
    "file_name": "files/hub-docs/ftso/5-migration.mdx",
    "meta_data": {
      "title": "Migrating from v1",
      "slug": "migration",
      "description": "Migration guide for dApps moving from FTSOv1 to FTSOv2.",
      "keywords": [
        "solidity",
        "ftso",
        "flare-time-series-oracle",
        "flare-network",
        "smart-contracts"
      ]
    },
    "type": "answer"
  },
  {
    "content": "import Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport DocCardList from \"@theme/DocCardList\";\nimport SolidityReference from \"@site/src/components/DataTables/SolidityReference\";\n\nimport Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport DocCardList from \"@theme/DocCardList\";\nimport SolidityReference from \"@site/src/components/DataTables/SolidityReference\";\n\nimport Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport DocCardList from \"@theme/DocCardList\";\nimport SolidityReference from \"@site/src/components/DataTables/SolidityReference\";",
    "file_name": "files/hub-docs/ftso/4-solidity-reference.mdx",
    "meta_data": {
      "title": "FTSOv2 Reference",
      "description": "Solidity reference for FTSOv2 smart contracts.",
      "keywords": [
        "solidity",
        "reference",
        "ftso",
        "flare-time-series-oracle",
        "flare-network",
        "smart-contracts"
      ]
    },
    "type": "answer"
  },
  {
    "content": "import CodeBlock from \"@theme/CodeBlock\";\nimport TabItem from \"@theme/TabItem\";\nimport Tabs from \"@theme/Tabs\";\nimport GetFeedIdSol from \"!!raw-loader!/examples/developer-hub-solidity/GetFeedId.sol\";\nimport GetFeedIdPy from \"!!raw-loader!/examples/developer-hub-python/get_feed_id.py\";\nimport GetFeedIdJS from \"!!raw-loader!/examples/developer-hub-javascript/get_feed_id.js\";\nimport GetFeedIdRs from \"!!raw-loader!/examples/developer-hub-rust/src/bin/get_feed_id.rs\";\nimport GetFeedIdGo from \"!!raw-loader!/examples/developer-hub-go/get_feed_id.go\";\n\n<details>\n    <summary>Example of the structured encoding process.</summary>\n\n    Taking the feed name `FLR/USD`:\n\n    - **Category**: `01` (Crypto)\n    - **Hex-Encoded Feed Name**: `464c522f555344` (hexadecimal representation of `FLR/USD`)\n    - **Zero Padding**: The category and hex-encoded feed name combined and padded: `01464c522f55534400000000000000000000000000`\n    - **Final ID**: Adding the `0x` prefix results in `0x01464c522f55534400000000000000000000000000`\n\n    <Tabs block>\n        <TabItem value=\"Solidity\" label=\"Solidity\" default>\n\n            <CodeBlock language=\"solidity\" title=\"GetFeedId.sol\">\n                {GetFeedIdSol}\n            </CodeBlock>\n\n        </TabItem>\n        <TabItem value=\"Javascript\" label=\"Javascript\">\n\n            <CodeBlock language=\"javascript\" title=\"get_feed_id.js\">\n                {GetFeedIdJS}\n            </CodeBlock>\n\n        </TabItem>\n        <TabItem value=\"Python\" label=\"Python\">\n\n            <CodeBlock language=\"python\" title=\"get_feed_id.py\">\n                {GetFeedIdPy}\n            </CodeBlock>\n\n        </TabItem>\n        <TabItem value=\"Rust\" label=\"Rust\">\n\n            <CodeBlock language=\"rust\" title=\"get_feed_id.rs\">\n                {GetFeedIdRs}\n            </CodeBlock>\n\n        </TabItem>\n        <TabItem value=\"Go\" label=\"Go\">\n\n            <CodeBlock language=\"go\" title=\"get_feed_id.go\">\n                {GetFeedIdGo}\n            </CodeBlock>\n\n        </TabItem>\n    </Tabs>\n\n</details>\n\n<details>\n<summary>\ud83d\udea6 Understanding feed risks.</summary>\n\nWhen building applications, developers must carefully evaluate the quality of the data they use. As a developer, you are responsible for identifying and assessing the accuracy, availability, and overall quality of the data you choose to integrate. It is important to understand that all data feeds carry inherent risks.\n\nThe table below categorizes feeds into three risk levels based on their market integrity, ranging from lowest to highest, a feed is assigned a higher risk level if it fails to meet **all** the criteria required for classification within a lower risk level:\n\n| **Aspect**                  | \ud83d\udfe2 **Low Risk**                           | \ud83d\udfe1 **Medium Risk**                          | \ud83d\udd34 **High Risk**                                       |\n| --------------------------- | ----------------------------------------- | ------------------------------------------- | ------------------------------------------------------ |\n| **Intrinsic Volatility**    | Low, stable price trends                  | Moderate price fluctuations                 | High, frequent price swings                            |\n| **Liquidity Variation**     | Abundant and consistent                   | Sufficient but variable                     | Limited and inconsistent                               |\n| **Liquidity Concentration** | Broad and well-distributed across venues  | Somewhat concentrated                       | Highly concentrated in a few sources                   |\n| **Asset Spread Risk**       | Tight spreads, minimal bid-ask gaps       | Moderate spreads, acceptable bid-ask gaps   | Wide spreads, significant bid-ask gaps                 |\n| **Cross Rate Risk**         | Low correlation, direct pricing available | Moderate correlation, indirect pricing used | High correlation, dependent on multiple intermediaries |\n\n**Other risk categories:**\n\n- \u26ab **New Feed**\n  New tokens lack historical data for proper risk assessment and stable price discovery.\n  Users must recognize these assets carry higher volatility risks and verify feed reliability independently.\n  After a monitoring period, feeds will be assigned risk levels or potentially discontinued.\n\nEach feed undergoes a rigorous assessment process prior to deployment. The evaluation criteria may vary depending on the specific type of feed being implemented and can evolve over time as our understanding of market integrity risks improves.\n\n</details>\n",
    "meta_data": {},
    "file_name": "files/hub-docs/ftso/_feed_explanation.mdx",
    "type": "answer"
  },
  {
    "content": "import ThemedImage from \"@theme/ThemedImage\";\nimport useBaseUrl from \"@docusaurus/useBaseUrl\";\n\nThe **F**lare **T**ime **S**eries **O**racle **(FTSO)** is an [enshrined oracle](/support/terminology#enshrined-oracle) that provides decentralized data feeds to the Flare network. Since the release of FTSOv1 two years ago, users and applications on Flare have enjoyed consistent and reliable pricing, with zero downtime or failures. FTSOv2 builds on the robust foundation laid by its predecessor, offering several enhancements:\n\n- **Secure.** Enshrined into Flare's core protocol, every oracle feed in FTSOv2 inherits the economic security of the entire network.\n\n- **Fast.** FTSOv2 features block-latency feeds, updating with each new block on Flare, every \u22481.8 seconds.\n\n- **Scalable.** FTSOv2 supports up to 1000 feeds across various asset classes including equities, commodities, and cryptocurrencies, with access to 2 weeks of historical data.\n\n- **Decentralized.** Each FTSOv2 feed is supported by around 100 independent data providers, who are selected by Flare users through their delegated stake, imposing a strict economic cost for misbehavior.\n\n- **Cost-effective.** Block-latency feeds in FTSOv2 are completely free to query. Feeds from Scaling are also free to query and verify locally, with minimal gas costs for onchain verification.\n\nimport ThemedImage from \"@theme/ThemedImage\";\nimport useBaseUrl from \"@docusaurus/useBaseUrl\";\n\nThe **F**lare **T**ime **S**eries **O**racle **(FTSO)** is an [enshrined oracle](/support/terminology#enshrined-oracle) that provides decentralized data feeds to the Flare network. Since the release of FTSOv1 two years ago, users and applications on Flare have enjoyed consistent and reliable pricing, with zero downtime or failures. FTSOv2 builds on the robust foundation laid by its predecessor, offering several enhancements:\n\n- **Secure.** Enshrined into Flare's core protocol, every oracle feed in FTSOv2 inherits the economic security of the entire network.\n\n- **Fast.** FTSOv2 features block-latency feeds, updating with each new block on Flare, every \u22481.8 seconds.\n\n- **Scalable.** FTSOv2 supports up to 1000 feeds across various asset classes including equities, commodities, and cryptocurrencies, with access to 2 weeks of historical data.\n\n- **Decentralized.** Each FTSOv2 feed is supported by around 100 independent data providers, who are selected by Flare users through their delegated stake, imposing a strict economic cost for misbehavior.\n\n- **Cost-effective.** Block-latency feeds in FTSOv2 are completely free to query. Feeds from Scaling are also free to query and verify locally, with minimal gas costs for onchain verification.",
    "file_name": "files/hub-docs/ftso/0-overview.mdx",
    "meta_data": {
      "slug": "overview",
      "title": "FTSOv2",
      "description": "FTSOv2 is an enshrined oracle that provides decentralized data feeds to the Flare network.",
      "keywords": [
        "ftso",
        "oracle",
        "flare-time-series-oracle",
        "flare-network"
      ]
    },
    "type": "answer"
  },
  {
    "content": "import Remix from \"@site/src/components/remix\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport YoutubeEmbed from \"@site/src/components/youtube\";\nimport FtsoV2FeedConsumer from \"!!raw-loader!/examples/developer-hub-solidity/FtsoV2FeedConsumer.sol\";\nimport OpenSolidityCompiler from \"/static/img/ftso-getting-started/0-open-solidity-compiler-tab.png\";\nimport SetEvmVersion from \"/static/img/ftso-getting-started/1-set-evm-version.png\";\nimport SetInjectedProvider from \"/static/img/ftso-getting-started/1-set-injected-provider.png\";\nimport CompileContract from \"/static/img/ftso-getting-started/2-compile-contract.png\";\nimport OpenDeploy from \"/static/img/ftso-getting-started/3-open-deploy.png\";\nimport DeployContract from \"/static/img/ftso-getting-started/4-deploy-contract.png\";\nimport ConfirmDeployInMetamask from \"/static/img/ftso-getting-started/5-confirm-deploy-in-metamask.png\";\nimport QueryLatestFeeds from \"/static/img/ftso-getting-started/6-query-latest-feeds.png\";\n\nYou can use FTSOv2 to connect your smart contracts with real-world data feeds. FTSOv2 leverages Flare's network of 100 independent data providers to fetch offchain data and deliver it onchain. This section demonstrates how to consume FTSOv2's block-latency feeds on Flare using an onchain Solidity contract.\n\n:::info[New to smart contract development?]\n\nLearn how to [deploy your first smart contract](/network/getting-started) before you start this guide.\n\n:::\n\nimport Remix from \"@site/src/components/remix\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport YoutubeEmbed from \"@site/src/components/youtube\";\nimport FtsoV2FeedConsumer from \"!!raw-loader!/examples/developer-hub-solidity/FtsoV2FeedConsumer.sol\";\nimport OpenSolidityCompiler from \"/static/img/ftso-getting-started/0-open-solidity-compiler-tab.png\";\nimport SetEvmVersion from \"/static/img/ftso-getting-started/1-set-evm-version.png\";\nimport SetInjectedProvider from \"/static/img/ftso-getting-started/1-set-injected-provider.png\";\nimport CompileContract from \"/static/img/ftso-getting-started/2-compile-contract.png\";\nimport OpenDeploy from \"/static/img/ftso-getting-started/3-open-deploy.png\";\nimport DeployContract from \"/static/img/ftso-getting-started/4-deploy-contract.png\";\nimport ConfirmDeployInMetamask from \"/static/img/ftso-getting-started/5-confirm-deploy-in-metamask.png\";\nimport QueryLatestFeeds from \"/static/img/ftso-getting-started/6-query-latest-feeds.png\";\n\nYou can use FTSOv2 to connect your smart contracts with real-world data feeds. FTSOv2 leverages Flare's network of 100 independent data providers to fetch offchain data and deliver it onchain. This section demonstrates how to consume FTSOv2's block-latency feeds on Flare using an onchain Solidity contract.\n\n:::info[New to smart contract development?]\n\nLearn how to [deploy your first smart contract](/network/getting-started) before you start this guide.\n\n:::\n\nimport Remix from \"@site/src/components/remix\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport YoutubeEmbed from \"@site/src/components/youtube\";\nimport FtsoV2FeedConsumer from \"!!raw-loader!/examples/developer-hub-solidity/FtsoV2FeedConsumer.sol\";\nimport OpenSolidityCompiler from \"/static/img/ftso-getting-started/0-open-solidity-compiler-tab.png\";\nimport SetEvmVersion from \"/static/img/ftso-getting-started/1-set-evm-version.png\";\nimport SetInjectedProvider from \"/static/img/ftso-getting-started/1-set-injected-provider.png\";\nimport CompileContract from \"/static/img/ftso-getting-started/2-compile-contract.png\";\nimport OpenDeploy from \"/static/img/ftso-getting-started/3-open-deploy.png\";\nimport DeployContract from \"/static/img/ftso-getting-started/4-deploy-contract.png\";\nimport ConfirmDeployInMetamask from \"/static/img/ftso-getting-started/5-confirm-deploy-in-metamask.png\";\nimport QueryLatestFeeds from \"/static/img/ftso-getting-started/6-query-latest-feeds.png\";\n\nYou can use FTSOv2 to connect your smart contracts with real-world data feeds. FTSOv2 leverages Flare's network of 100 independent data providers to fetch offchain data and deliver it onchain. This section demonstrates how to consume FTSOv2's block-latency feeds on Flare using an onchain Solidity contract.\n\n:::info[New to smart contract development?]\n\nLearn how to [deploy your first smart contract](/network/getting-started) before you start this guide.\n\n:::",
    "file_name": "files/hub-docs/ftso/1-getting-started.mdx",
    "meta_data": {
      "slug": "getting-started",
      "title": "Getting Started",
      "description": "Learn how to consume FTSOv2 feeds on Flare using an onchain Solidity contract.",
      "keywords": [
        "ftso",
        "oracle",
        "flare-time-series-oracle",
        "flare-network",
        "smart-contracts",
        "solidity",
        "remix",
        "metamask"
      ]
    },
    "type": "answer"
  },
  {
    "content": "import Remix from \"@site/src/components/remix\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport YoutubeEmbed from \"@site/src/components/youtube\";\nimport FtsoV2FeedConsumer from \"!!raw-loader!/examples/developer-hub-solidity/FtsoV2FeedConsumer.sol\";\nimport OpenSolidityCompiler from \"/static/img/ftso-getting-started/0-open-solidity-compiler-tab.png\";\nimport SetEvmVersion from \"/static/img/ftso-getting-started/1-set-evm-version.png\";\nimport SetInjectedProvider from \"/static/img/ftso-getting-started/1-set-injected-provider.png\";\nimport CompileContract from \"/static/img/ftso-getting-started/2-compile-contract.png\";\nimport OpenDeploy from \"/static/img/ftso-getting-started/3-open-deploy.png\";\nimport DeployContract from \"/static/img/ftso-getting-started/4-deploy-contract.png\";\nimport ConfirmDeployInMetamask from \"/static/img/ftso-getting-started/5-confirm-deploy-in-metamask.png\";\nimport QueryLatestFeeds from \"/static/img/ftso-getting-started/6-query-latest-feeds.png\";\n\nYou can use FTSOv2 to connect your smart contracts with real-world data feeds. FTSOv2 leverages Flare's network of 100 independent data providers to fetch offchain data and deliver it onchain. This section demonstrates how to consume FTSOv2's block-latency feeds on Flare using an onchain Solidity contract.\n\n:::info[New to smart contract development?]\n\nLearn how to [deploy your first smart contract](/network/getting-started) before you start this guide.\n\n:::",
    "file_name": "files/hub-docs/ftso/1-getting-started.mdx",
    "meta_data": {
      "slug": "getting-started",
      "title": "Getting Started",
      "description": "Learn how to consume FTSOv2 feeds on Flare using an onchain Solidity contract.",
      "keywords": [
        "ftso",
        "oracle",
        "flare-time-series-oracle",
        "flare-network",
        "smart-contracts",
        "solidity",
        "remix",
        "metamask"
      ]
    },
    "type": "answer"
  },
  {
    "content": "import FeedExplanation from \"./_feed_explanation.mdx\";\nimport NewGithubIssue from \"@site/src/components/newGithubIssue\";\nimport TabItem from \"@theme/TabItem\";\nimport Tabs from \"@theme/Tabs\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport BlockLatencyFeeds from \"@site/src/components/DataTables/BlockLatencyFeeds\";\n\nFTSOv2's block-latency feeds update incrementally with each new block on Flare, approximately every 1.8 seconds. Every feed leverages Flare's network of 100 independent data providers. These feeds primarily support cryptocurrency price data and are free to query on Flare, enabling decentralized applications to access up-to-date information without incurring additional costs.\n\nEach block-latency feed is uniquely identified by an ID composed of three components in a structured encoding process:\n\n1. **Category:** Indicates the type of asset - Crypto: `01`, Forex: `02`, Commodity: `03`, Stock: `04`\n\n2. **Hex-Encoded Feed Name:** The name of the feed is converted to a hexadecimal format.\n\n3. **Zero Padding:** The combined category and hex-encoded feed name are padded with zeros to a length of 21 bytes.\n\nThe resulting string is then prefixed with `0x`.\n\n<FeedExplanation />\n\n:::warning\n\n- Feed IDs are **not** addresses. They are `bytes21` structured encodings that combine the category and feed name to ensure each feed has a unique identifier.\n- **Do not** hardcode the number of decimals for a feed in your smart contract, as these can change as the feed value changes. You can use either of the following solutions:\n  - Check the number of decimal places every query ([`getFeedById`](/ftso/solidity-reference/FtsoV2Interface#getfeedbyid)).\n  - Use the feed value in Wei ([`getFeedByIdInWei`](/ftso/solidity-reference/FtsoV2Interface#getfeedbyidinwei)).\n\n:::\n\n<BlockLatencyFeeds />\n\nimport FeedExplanation from \"./_feed_explanation.mdx\";\nimport NewGithubIssue from \"@site/src/components/newGithubIssue\";\nimport TabItem from \"@theme/TabItem\";\nimport Tabs from \"@theme/Tabs\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport BlockLatencyFeeds from \"@site/src/components/DataTables/BlockLatencyFeeds\";\n\nFTSOv2's block-latency feeds update incrementally with each new block on Flare, approximately every 1.8 seconds. Every feed leverages Flare's network of 100 independent data providers. These feeds primarily support cryptocurrency price data and are free to query on Flare, enabling decentralized applications to access up-to-date information without incurring additional costs.\n\nEach block-latency feed is uniquely identified by an ID composed of three components in a structured encoding process:\n\n1. **Category:** Indicates the type of asset - Crypto: `01`, Forex: `02`, Commodity: `03`, Stock: `04`\n\n2. **Hex-Encoded Feed Name:** The name of the feed is converted to a hexadecimal format.\n\n3. **Zero Padding:** The combined category and hex-encoded feed name are padded with zeros to a length of 21 bytes.\n\nThe resulting string is then prefixed with `0x`.\n\n<FeedExplanation />\n\n:::warning\n\n- Feed IDs are **not** addresses. They are `bytes21` structured encodings that combine the category and feed name to ensure each feed has a unique identifier.\n- **Do not** hardcode the number of decimals for a feed in your smart contract, as these can change as the feed value changes. You can use either of the following solutions:\n  - Check the number of decimal places every query ([`getFeedById`](/ftso/solidity-reference/FtsoV2Interface#getfeedbyid)).\n  - Use the feed value in Wei ([`getFeedByIdInWei`](/ftso/solidity-reference/FtsoV2Interface#getfeedbyidinwei)).\n\n:::\n\n<BlockLatencyFeeds />",
    "file_name": "files/hub-docs/ftso/2-feeds.mdx",
    "meta_data": {
      "slug": "feeds",
      "title": "Block-Latency Feeds",
      "description": "FTSOv2's block-latency feeds update incrementally with each new block on Flare, approximately every 1.8 seconds.",
      "keywords": [
        "ftso",
        "oracle",
        "flare-time-series-oracle",
        "flare-network",
        "feeds",
        "block-latency"
      ]
    },
    "type": "answer"
  },
  {
    "content": "import CodeBlock from \"@theme/CodeBlock\";\nimport FtsoV2FeedConsumer from \"!!raw-loader!/examples/developer-hub-solidity/FtsoV2FeedConsumer_foundry.sol\";\nimport FtsoV2FeedConsumerTest from \"!!raw-loader!/examples/developer-hub-solidity/FtsoV2FeedConsumer_foundry.t.sol\";\n\nThis guide is for developers who want to build an FTSOv2 application using Foundry. In this guide, you will learn how to:\n\n- Create a contract to read the price of FLR/USD from FTSOv2 using [flare-periphery-contracts](https://www.npmjs.com/package/@flarenetwork/flare-periphery-contracts).\n\n- Compile your contract using Foundry [forge](https://book.getfoundry.sh/reference/forge/).\n\n- Deploy your contract to Flare Testnet Coston2, and interact with it using Foundry [cast](https://book.getfoundry.sh/reference/cast/).\n\nimport CodeBlock from \"@theme/CodeBlock\";\nimport FtsoV2FeedConsumer from \"!!raw-loader!/examples/developer-hub-solidity/FtsoV2FeedConsumer_foundry.sol\";\nimport FtsoV2FeedConsumerTest from \"!!raw-loader!/examples/developer-hub-solidity/FtsoV2FeedConsumer_foundry.t.sol\";\n\nThis guide is for developers who want to build an FTSOv2 application using Foundry. In this guide, you will learn how to:\n\n- Create a contract to read the price of FLR/USD from FTSOv2 using [flare-periphery-contracts](https://www.npmjs.com/package/@flarenetwork/flare-periphery-contracts).\n\n- Compile your contract using Foundry [forge](https://book.getfoundry.sh/reference/forge/).\n\n- Deploy your contract to Flare Testnet Coston2, and interact with it using Foundry [cast](https://book.getfoundry.sh/reference/cast/).\n\nimport CodeBlock from \"@theme/CodeBlock\";\nimport FtsoV2FeedConsumer from \"!!raw-loader!/examples/developer-hub-solidity/FtsoV2FeedConsumer_foundry.sol\";\nimport FtsoV2FeedConsumerTest from \"!!raw-loader!/examples/developer-hub-solidity/FtsoV2FeedConsumer_foundry.t.sol\";\n\nThis guide is for developers who want to build an FTSOv2 application using Foundry. In this guide, you will learn how to:\n\n- Create a contract to read the price of FLR/USD from FTSOv2 using [flare-periphery-contracts](https://www.npmjs.com/package/@flarenetwork/flare-periphery-contracts).\n\n- Compile your contract using Foundry [forge](https://book.getfoundry.sh/reference/forge/).\n\n- Deploy your contract to Flare Testnet Coston2, and interact with it using Foundry [cast](https://book.getfoundry.sh/reference/cast/).\n\nimport CodeBlock from \"@theme/CodeBlock\";\nimport FtsoV2FeedConsumer from \"!!raw-loader!/examples/developer-hub-solidity/FtsoV2FeedConsumer_foundry.sol\";\nimport FtsoV2FeedConsumerTest from \"!!raw-loader!/examples/developer-hub-solidity/FtsoV2FeedConsumer_foundry.t.sol\";\n\nThis guide is for developers who want to build an FTSOv2 application using Foundry. In this guide, you will learn how to:\n\n- Create a contract to read the price of FLR/USD from FTSOv2 using [flare-periphery-contracts](https://www.npmjs.com/package/@flarenetwork/flare-periphery-contracts).\n\n- Compile your contract using Foundry [forge](https://book.getfoundry.sh/reference/forge/).\n\n- Deploy your contract to Flare Testnet Coston2, and interact with it using Foundry [cast](https://book.getfoundry.sh/reference/cast/).\n\nimport CodeBlock from \"@theme/CodeBlock\";\nimport FtsoV2FeedConsumer from \"!!raw-loader!/examples/developer-hub-solidity/FtsoV2FeedConsumer_foundry.sol\";\nimport FtsoV2FeedConsumerTest from \"!!raw-loader!/examples/developer-hub-solidity/FtsoV2FeedConsumer_foundry.t.sol\";\n\nThis guide is for developers who want to build an FTSOv2 application using Foundry. In this guide, you will learn how to:\n\n- Create a contract to read the price of FLR/USD from FTSOv2 using [flare-periphery-contracts](https://www.npmjs.com/package/@flarenetwork/flare-periphery-contracts).\n\n- Compile your contract using Foundry [forge](https://book.getfoundry.sh/reference/forge/).\n\n- Deploy your contract to Flare Testnet Coston2, and interact with it using Foundry [cast](https://book.getfoundry.sh/reference/cast/).\n\nimport CodeBlock from \"@theme/CodeBlock\";\nimport FtsoV2FeedConsumer from \"!!raw-loader!/examples/developer-hub-solidity/FtsoV2FeedConsumer_foundry.sol\";\nimport FtsoV2FeedConsumerTest from \"!!raw-loader!/examples/developer-hub-solidity/FtsoV2FeedConsumer_foundry.t.sol\";\n\nThis guide is for developers who want to build an FTSOv2 application using Foundry. In this guide, you will learn how to:\n\n- Create a contract to read the price of FLR/USD from FTSOv2 using [flare-periphery-contracts](https://www.npmjs.com/package/@flarenetwork/flare-periphery-contracts).\n\n- Compile your contract using Foundry [forge](https://book.getfoundry.sh/reference/forge/).\n\n- Deploy your contract to Flare Testnet Coston2, and interact with it using Foundry [cast](https://book.getfoundry.sh/reference/cast/).",
    "file_name": "files/hub-docs/ftso/guides/build-first-app.mdx",
    "meta_data": {
      "title": "Build your first FTSOv2 app",
      "tags": [
        "intermediate",
        "ftso",
        "solidity"
      ],
      "slug": "build-first-app",
      "description": "Use FTSOv2 in your Foundry project.",
      "keywords": [
        "ftso",
        "oracle",
        "flare-time-series-oracle",
        "flare-network",
        "smart-contracts",
        "solidity",
        "remix"
      ],
      "sidebar_position": 1
    },
    "type": "answer"
  },
  {
    "content": "import TabItem from \"@theme/TabItem\";\nimport Tabs from \"@theme/Tabs\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport FtsoConfigEthersJs from \"!!raw-loader!/examples/developer-hub-javascript/ftsov2_config_coston2_ethers.js\";\nimport FtsoConfigWeb3Js from \"!!raw-loader!/examples/developer-hub-javascript/ftsov2_config_coston2_web3.js\";\nimport FtsoConfigWeb3Py from \"!!raw-loader!/examples/developer-hub-python/ftsov2_config_coston2.py\";\nimport FtsoConfigRust from \"!!raw-loader!/examples/developer-hub-rust/src/bin/ftsov2_config_coston2.rs\";\nimport FtsoConfigGo from \"!!raw-loader!/examples/developer-hub-go/ftsov2_config_coston2.go\";\n\nThis guide provides code examples demonstrating how to read FTSOv2 feed configurations offchain using various programming languages. To achieve this, you need two key pieces of information:\n\n1. **RPC Endpoint URL:** The RPC Endpoint URL determines which network your code will interact with. You can either use a node provider service or point to your [own RPC node](/run-node/rpc-node). A list of public and private RPC endpoints for all Flare networks is available on the [Network Configuration](/network/overview#configuration) page.\n\n2. **Contract Address:** The address for the `FastUpdatesConfiguration` contract varies by network. You can obtain this address in two ways:\n\n   - **From the Solidity Reference page:** Find the `FastUpdatesConfiguration` address for each network on the [Solidity Reference](/ftso/solidity-reference) page.\n\n     **OR**\n\n   - **Query the FlareContractRegistry Contract:** The `FlareContractRegistry` contract has the same address across all networks. You can query it to get the `FastUpdatesConfiguration` contract address. Refer to the specific language guides for examples:\n     - [JavaScript](/network/guides/flare-for-javascript-developers#make-query)\n     - [Python](/network/guides/flare-for-python-developers#make-query)\n     - [Rust](/network/guides/flare-for-rust-developers#make-query)\n     - [Go](/network/guides/flare-for-go-developers#make-query)\n\n:::tip\n\nAll examples in this guide are available at [developer-hub/examples](https://github.com/flare-foundation/developer-hub/tree/main/examples).\n\n:::\n\n<Tabs block>\n  <TabItem value=\"web3js\" label=\"web3.js\" default>\n    This example user [web3.js](https://github.com/web3/web3.js) to retrieve FTSOv2 feed configurations on Flare Testnet Coston2.\n    \n    ```bash\n    npm install web3\n    ```\n\n    <CodeBlock language=\"javascript\" title=\"ftsov2_config.js\">\n      {FtsoConfigWeb3Js}\n    </CodeBlock>\n\n  </TabItem>\n  <TabItem value=\"ethersjs\" label=\"ethers.js\">\n    This example uses [ethers.js](https://github.com/ethers-io/ethers.js/) to retrieve FTSOv2 feed configurations on Flare Testnet Coston2.\n    \n    ```bash\n    npm install ethers\n    ```\n    \n    <CodeBlock language=\"javascript\" title=\"ftsov2_config.js\">\n      {FtsoConfigEthersJs}\n    </CodeBlock>\n\n  </TabItem>\n  <TabItem value=\"web3py\" label=\"web3.py\">\n\n    This example uses [web3.py](https://github.com/ethereum/web3.py) to retrieve FTSOv2 feed configurations on Flare Testnet Coston2.\n\n    <Tabs groupId=\"python\">\n      <TabItem value=\"uv\" label=\"uv\" default>\n\n        ```bash\n        uv add web3\n        ```\n\n      </TabItem>\n      <TabItem value=\"pip\" label=\"pip\">\n\n        ```bash\n        pip install web3\n        ```\n\n      </TabItem>\n    </Tabs>\n\n    <CodeBlock language=\"python\" title=\"ftsov2_config.py\">\n      {FtsoConfigWeb3Py}\n    </CodeBlock>\n\n  </TabItem>\n  <TabItem value=\"alloyrs\" label=\"alloy-rs\">\n\n    This example uses [alloy-rs](https://github.com/alloy-rs) to retrieve FTSOv2 feed configurations on Flare Testnet Coston2.\n\n    ```bash\n    cargo add alloy eyre tokio --features alloy/full,tokio/rt,tokio/rt-multi-thread,tokio/macros\n    ```\n    <CodeBlock language=\"rust\" title=\"src/bin/ftsov2_config.rs\">\n      {FtsoConfigRust}\n    </CodeBlock>\n\n  </TabItem>\n  <TabItem value=\"goethereum\" label=\"go-ethereum\">\n\n    This example uses the Go API from [Geth](https://geth.ethereum.org) to retrieve FTSOv2 feed configurations on Flare Testnet Coston2.\n\n    ```bash\n    go get github.com/ethereum/go-ethereum/ethclient\n    ```\n\n    With Go, you need to manually fetch the contract's ABI and generate the Go bindings. Copy the [FastUpdatesConfiguration ABI](https://api.routescan.io/v2/network/testnet/evm/114/etherscan/api?module=contract&action=getabi&address=0xE7d1D5D58cAE01a82b84989A931999Cb34A86B14&format=raw) and paste it into a file named `FastUpdatesConfiguration.abi`, located in the root of your project, i.e. same level as `go.mod`. Then using [abigen](https://geth.ethereum.org/docs/tools/abigen), generate the Go bindings.\n\n    ```bash\n    abigen --abi FastUpdatesConfiguration.abi --pkg main --type FastUpdatesConfiguration --out FastUpdatesConfiguration.go\n    ```\n\n    <CodeBlock language=\"go\" title=\"ftsov2_config.go\">\n      {FtsoConfigGo}\n    </CodeBlock>\n\n  </TabItem>\n</Tabs>",
    "meta_data": {
      "title": "Query feed configuration",
      "tags": [
        "intermediate",
        "ftso",
        "python",
        "rust",
        "javascript",
        "go"
      ],
      "slug": "query-feed-configuration",
      "description": "Query feed configuration using JS, Python, Rust, or Go.",
      "keywords": [
        "ftso",
        "oracle",
        "flare-time-series-oracle",
        "flare-network",
        "smart-contracts",
        "solidity",
        "remix",
        "metamask"
      ],
      "sidebar_position": 4
    },
    "file_name": "files/hub-docs/ftso/guides/query-feed-configuration.mdx",
    "type": "answer"
  },
  {
    "content": "import Remix from \"@site/src/components/remix\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport FtsoV2ChangeQuoteFeed from \"!!raw-loader!/examples/developer-hub-solidity/FtsoV2ChangeQuoteFeed.sol\";\nimport SetEvmVersionRemix from \"/static/img/set-evm-version-remix.png\";\n\nThis guide will show you how to fetch the latest feed values for two feeds and convert them to a new quote feed while retaining the number of decimals. For example, if you need the price of `BTC/ETH`, you can fetch the latest feed values for `BTC/USD` and `ETH/USD` and calculate the price of `BTC/ETH = (BTC/USD) / (ETH/USD)`.\n\n<CodeBlock language=\"solidity\" title=\"FtsoV2ChangeQuoteFeed.sol\">\n  {FtsoV2ChangeQuoteFeed}\n</CodeBlock>\n\n{/* prettier-ignore */}\n<Remix fileName=\"FtsoV2ChangeQuoteFeed.sol\">Open in Remix</Remix>\n<br></br>\n\n:::warning[Don't use test interfaces in production]\n\nThe `TestFtsoV2Interface` is for **testing only**, with all methods as `view` to allow rapid development without gas costs or state changes. For production, use [`FtsoV2Interface`](/ftso/solidity-reference/FtsoV2Interface), which includes `payable` methods required for real transactions and state modifications.\nMake the following changes to `FtsoV2ChangeQuoteFeed.sol`:\n\n```solidity\nimport {ContractRegistry} from \"@flarenetwork/flare-periphery-contracts/coston2/ContractRegistry.sol\";\nimport {FtsoV2Interface} from \"@flarenetwork/flare-periphery-contracts/coston2/FtsoV2Interface.sol\";\n\ncontract FtsoV2ChangeQuoteFeed {\n  FtsoV2Interface internal ftsoV2;\n  constructor() {\n    ftsoV2 = ContractRegistry.getFtsoV2();\n  }\n  //...\n}\n```\n\n:::\n\n:::warning[Set EVM Version to London]\n\n- **Using Remix:** Set EVM version to `london` in the **Advanced Configurations** section of the **Solidity Compiler** tab:\n\n  {\" \"}\n\n  <img src={SetEvmVersionRemix} style={{ width: 300 }} />\n\n- **Using Hardhat or Foundry:** Set EVM version to `london` in [hardhat.config.ts](https://github.com/flare-foundation/flare-hardhat-starter/blob/master/hardhat.config.ts#L34) or [foundry.toml](https://github.com/flare-foundation/flare-foundry-starter/blob/master/foundry.toml).\n\n- **Using Standard Solidity JSON:** Set `evmVersion` to `london`:\n\n  ```json\n  {\n    \"settings\": {\n      \"optimizer\": {\n        /* ... */\n      },\n      \"evmVersion\": \"london\"\n    }\n  }\n  ```\n\n- **Using `solc` CLI:** Set `--evm-version` to `london`:\n\n  ```bash\n  solc --evm-version london <args>\n  ```\n\n:::",
    "meta_data": {
      "title": "Change quote feed",
      "tags": [
        "intermediate",
        "ftso",
        "solidity"
      ],
      "slug": "change-quote-feed",
      "description": "Change block-latency quote feeds using Solidity.",
      "keywords": [
        "ftso",
        "oracle",
        "flare-time-series-oracle",
        "flare-network",
        "smart-contracts",
        "solidity",
        "remix"
      ],
      "sidebar_position": 3
    },
    "file_name": "files/hub-docs/ftso/guides/change-quote-feed.mdx",
    "type": "answer"
  },
  {
    "content": "import TabItem from \"@theme/TabItem\";\nimport Tabs from \"@theme/Tabs\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport ReadOffhainEthersJs from \"!!raw-loader!/examples/developer-hub-javascript/ftsov2_consumer_coston2_ethers.js\";\nimport ReadOffhainWeb3Js from \"!!raw-loader!/examples/developer-hub-javascript/ftsov2_consumer_coston2_web3.js\";\nimport ReadOffhainWeb3Py from \"!!raw-loader!/examples/developer-hub-python/ftsov2_consumer_coston2.py\";\nimport ReadOffhainRust from \"!!raw-loader!/examples/developer-hub-rust/src/bin/ftsov2_consumer_coston2.rs\";\nimport ReadOffhainGo from \"!!raw-loader!/examples/developer-hub-go/ftsov2_consumer_coston2.go\";\n\nThis guide provides code examples demonstrating how to read FTSOv2 feeds offchain using various programming languages. To read a block-latency feed offchain, you need three key pieces of information:\n\n1. **RPC Endpoint URL:** The RPC Endpoint URL determines which network your code will interact with. You can use a node provider service or point to your [own RPC node](/run-node/rpc-node). A comprehensive list of public and private RPC endpoints for all Flare networks is available on the [Network Configuration](/network/overview#configuration) page.\n\n2. **Contract Address:** Feeds are served on the `FtsoV2` contract, whose address varies by network. You can obtain this address in two ways:\n\n   - **From the Solidity Reference page:** Find the `FtsoV2` address for each network on the [Solidity Reference](/ftso/solidity-reference) page.\n\n     **OR**\n\n   - **Query the FlareContractRegistry Contract:** The `FlareContractRegistry` contract has the same address across all networks. You can query it to get the `FtsoV2` contract address. Refer to the specific language guides for examples:\n     - [JavaScript](/network/guides/flare-for-javascript-developers#make-query)\n     - [Python](/network/guides/flare-for-python-developers#make-query)\n     - [Rust](/network/guides/flare-for-rust-developers#make-query)\n     - [Go](/network/guides/flare-for-go-developers#make-query)\n\n3. **Feed IDs:** The feeds you want to read are uniquely identified by their ID. A list of feed IDs is provided on the [Block-Latency Feeds](/ftso/feeds) page.\n\n:::tip\n\nAll examples in this guide are available at [developer-hub/examples](https://github.com/flare-foundation/developer-hub/tree/main/examples).\n\n:::\n\n<Tabs block>\n  <TabItem value=\"web3js\" label=\"web3.js\" default>\n\n    This example uses [web3.js](https://github.com/web3/web3.js) to retrieve FTSOv2 feed data for FLR/USD, BTC/USD, and ETH/USD on Flare Testnet Coston2.\n\n    ```bash\n    npm install web3\n    ```\n\n    <CodeBlock language=\"javascript\" title=\"ftsov2_consumer.js\">\n      {ReadOffhainWeb3Js}\n    </CodeBlock>\n\n  </TabItem>\n  <TabItem value=\"ethersjs\" label=\"ethers.js\">\n    This example uses [ethers.js](https://github.com/ethers-io/ethers.js/) to retrieve FTSOv2 feed data for FLR/USD, BTC/USD, and ETH/USD on Flare Testnet Coston2.\n\n    ```bash\n    npm install ethers\n    ```\n\n    <CodeBlock language=\"javascript\" title=\"ftsov2_consumer.js\">\n      {ReadOffhainEthersJs}\n    </CodeBlock>\n\n  </TabItem>\n  <TabItem value=\"web3py\" label=\"web3.py\">\n\n    This example uses [web3.py](https://github.com/ethereum/web3.py) to retrieve FTSOv2 feed values for FLR/USD, BTC/USD, and ETH/USD on Flare Testnet Coston2.\n\n    <Tabs groupId=\"python\">\n      <TabItem value=\"uv\" label=\"uv\" default>\n        ```bash\n        uv add web3\n        ```\n\n      </TabItem>\n      <TabItem value=\"pip\" label=\"pip\">\n        ```bash\n        pip install web3\n        ```\n\n      </TabItem>\n    </Tabs>\n\n    <CodeBlock language=\"python\" title=\"ftsov2_consumer.py\">\n      {ReadOffhainWeb3Py}\n    </CodeBlock>\n\n  </TabItem>\n  <TabItem value=\"alloyrs\" label=\"alloy-rs\">\n\n    This example uses [alloy-rs](https://github.com/alloy-rs) to retrieve FTSOv2 feed data for FLR/USD, BTC/USD, and ETH/USD on Flare Testnet Coston2.\n\n    ```bash\n    cargo add alloy eyre tokio --features alloy/full,tokio/rt,tokio/rt-multi-thread,tokio/macros\n    ```\n\n    <CodeBlock language=\"rust\" title=\"ftsov2_consumer.rs\">\n      {ReadOffhainRust}\n    </CodeBlock>\n\n  </TabItem>\n  <TabItem value=\"goethereum\" label=\"go-ethereum\">\n\n    This example uses the Go API from [Geth](https://geth.ethereum.org) to retrieve FTSOv2 feed data for FLR/USD, BTC/USD, and ETH/USD from Flare Testnet Coston2.\n\n    ```bash\n    go get github.com/ethereum/go-ethereum/ethclient\n    ```\n\n    With Go, you need to manually fetch the contract's ABI and generate the Go bindings. Copy the [FtsoV2 ABI](/ftso/solidity-reference) and paste it into a file named `FtsoV2.abi`, located in the root of your project, i.e. same level as `go.mod`. Then using [abigen](https://geth.ethereum.org/docs/tools/abigen), generate the Go bindings.\n\n    ```bash\n    abigen --abi FtsoV2.abi --pkg main --type FtsoV2 --out FtsoV2.go\n    ```\n\n    <CodeBlock language=\"go\" title=\"ftsov2_consumer.go\">\n      {ReadOffhainGo}\n    </CodeBlock>\n\n  </TabItem>\n</Tabs>",
    "meta_data": {
      "title": "Read feeds offchain",
      "tags": [
        "intermediate",
        "ftso",
        "python",
        "rust",
        "javascript",
        "go"
      ],
      "slug": "read-feeds-offchain",
      "description": "Read block-latency feeds using JS, Python, Rust, or Go.",
      "keywords": [
        "javascript",
        "python",
        "rust",
        "go",
        "ftso",
        "oracle",
        "flare-time-series-oracle",
        "flare-network"
      ],
      "sidebar_position": 2
    },
    "file_name": "files/hub-docs/ftso/guides/read-feeds-offchain.mdx",
    "type": "answer"
  },
  {
    "content": "import TabItem from \"@theme/TabItem\";\nimport Tabs from \"@theme/Tabs\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport VolIncentiveWeb3Js from \"!!raw-loader!/examples/developer-hub-javascript/volatility_incentive_coston2_web3.js\";\nimport VolIncentiveEthersJs from \"!!raw-loader!/examples/developer-hub-javascript/volatility_incentive_coston2_ethers.js\";\nimport VolIncentiveWeb3Py from \"!!raw-loader!/examples/developer-hub-python/volatility_incentive_coston2.py\";\nimport VolIncentiveRust from \"!!raw-loader!/examples/developer-hub-rust/src/bin/volatility_incentive_coston2.rs\";\nimport VolIncentiveGo from \"!!raw-loader!/examples/developer-hub-go/coston2/volatility_incentive.go\";\n\n:::info\n\nBefore reading this guide, make sure you understand [FTSOv2's Volatility Incentive Mechanism](/ftso/overview#volatility-incentive-mechanism).\n\n:::\n\nThis guide provides code examples demonstrating how to make an FTSOv2 volatility incentive offer using various programming languages. To make a volatility incentive offer, you need three key pieces of information:\n\n1. **RPC Endpoint URL:** The RPC Endpoint URL determines which network your code will interact with. You can use a node provider service or point to your [own RPC node](/run-node/rpc-node). A comprehensive list of public and private RPC endpoints for all Flare networks is available on the [Network Configuration](/network/overview#configuration) page.\n\n2. **Contract Address:** The address for the `FastUpdateIncentiveManager` contract varies by network. You can obtain this address in two ways:\n\n   - **From the Solidity Reference page:** Find the `FastUpdateIncentiveManager` address for each network on the [Solidity Reference](/ftso/solidity-reference) page.\n\n   **OR**\n\n   - **Query the FlareContractRegistry Contract:** The `FlareContractRegistry` contract has the same address across all networks. You can query it to get the `FastUpdateIncentiveManager` contract address. Refer to the specific language guides for examples:\n     - [JavaScript](/network/guides/flare-for-javascript-developers#make-query)\n     - [Python](/network/guides/flare-for-python-developers#make-query)\n     - [Rust](/network/guides/flare-for-rust-developers#make-query)\n     - [Go](/network/guides/flare-for-go-developers#make-query)\n\n3. **Cost of Increasing the Sample Size:** FTSOv2 allows you to increase the sample size, i.e., the expected number of providers who can submit a block-latency feed update. The cost for this increases dynamically with the expected sample size. A single volatility incentive lasts for a period of 8 blocks.\n\n:::tip\n\nAll examples in this guide are available at [developer-hub/examples](https://github.com/flare-foundation/developer-hub/tree/main/examples).\n\n:::\n\n<Tabs block>\n  <TabItem value=\"web3js\" label=\"web3.js\" default>\n\n    This example uses [web3.js](https://github.com/web3/web3.js) to make an FTSOv2 volatility incentive offer on Flare Testnet Coston2.\n\n    <CodeBlock language=\"javascript\" title=\"volatility_incentive.js\">\n        {VolIncentiveWeb3Js}\n    </CodeBlock>\n\n  </TabItem>\n  <TabItem value=\"ethersjs\" label=\"ethers.js\">\n\n    This example uses [ethers.js](https://github.com/ethers-io/ethers.js/) to make an FTSOv2 volatility incentive offer on Flare Testnet Coston2.\n\n    <CodeBlock language=\"javascript\" title=\"volatility_incentive.js\">\n        {VolIncentiveEthersJs}\n    </CodeBlock>\n\n  </TabItem>\n  <TabItem value=\"web3py\" label=\"web3.py\">\n\n    This example uses [web3.py](https://github.com/ethereum/web3.py) to make an FTSOv2 volatility incentive offer on Flare Testnet Coston2.\n\n    <CodeBlock language=\"python\" title=\"volatility_incentive.py\">\n        {VolIncentiveWeb3Py}\n    </CodeBlock>\n\n  </TabItem>\n  <TabItem value=\"alloyrs\" label=\"alloy-rs\">\n\n    This example uses [alloy-rs](https://github.com/ethereum/web3.py) to make an FTSOv2 volatility incentive offer on Flare Testnet Coston2.\n\n    ```bash\n    cargo add alloy eyre tokio --features alloy/full,tokio/rt,tokio/rt-multi-thread,tokio/macros\n    ```\n\n    <CodeBlock language=\"rust\" title=\"volatility_incentive.rs\">\n        {VolIncentiveRust}\n    </CodeBlock>\n\n  </TabItem>\n  <TabItem value=\"goethereum\" label=\"go-ethereum\">\n\n    This example uses the Go API from [Geth](https://geth.ethereum.org) to make an FTSOv2 volatility incentive offer on Flare Testnet Coston2.\n\n    ```bash\n    go get github.com/ethereum/go-ethereum/ethclient\n    go get github.com/ethereum/go-ethereum/accounts\n    ```\n\n    The project structure should look like:\n\n    ```plaintext\n    developer-hub-go/\n    \u251c\u2500\u2500 coston2/\n    \u2502   \u2514\u2500\u2500 *.go\n    \u251c\u2500\u2500 flare/\n    \u2502   \u2514\u2500\u2500 *.go\n    \u251c\u2500\u2500 main.go\n    \u251c\u2500\u2500 go.mod\n    \u2514\u2500\u2500 go.sum\n    ```\n\n    With Go, you need to manually fetch the contract's ABI and generate the Go bindings. Copy the [FastUpdatesIncentiveManager ABI](https://api.routescan.io/v2/network/testnet/evm/114/etherscan/api?module=contract&action=getabi&address=0x003e9bD18f73e0B25BED0DC8382Bde6aa999525c&format=raw) and paste it into a file named `FastUpdatesIncentiveManager.abi`, located in the root of your project, i.e. same level as `go.mod`. Then using [abigen](https://geth.ethereum.org/docs/tools/abigen), generate the Go bindings.\n\n    ```bash\n    abigen --abi FastUpdatesIncentiveManager.abi --pkg coston2 --type FastUpdatesIncentiveManager --out coston2/FastUpdatesIncentiveManager.go\n    ```\n\n    <CodeBlock language=\"go\" title=\"coston2/volatility_incentive.go\">\n        {VolIncentiveGo}\n    </CodeBlock>\n\n  </TabItem>\n</Tabs>",
    "meta_data": {
      "title": "Make a volatility incentive",
      "tags": [
        "intermediate",
        "ftso",
        "javascript",
        "python",
        "rust",
        "go"
      ],
      "slug": "make-volatility-incentive",
      "description": "Make a volatility incentive using JS, Python, Rust, or Go.",
      "keywords": [
        "javascript",
        "python",
        "rust",
        "go",
        "ftso",
        "oracle",
        "flare-time-series-oracle",
        "flare-network"
      ],
      "sidebar_position": 5
    },
    "file_name": "files/hub-docs/ftso/guides/make-volatility-incentive.mdx",
    "type": "answer"
  },
  {
    "content": "Interface for making volatility incentive offers.\n\nSourced from `IFastUpdateIncentiveManager.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IFastUpdateIncentiveManager.sol).\n\nInterface for making volatility incentive offers.\n\nSourced from `IFastUpdateIncentiveManager.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IFastUpdateIncentiveManager.sol).\n\nInterface for making volatility incentive offers.\n\nSourced from `IFastUpdateIncentiveManager.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IFastUpdateIncentiveManager.sol).\n\nInterface for making volatility incentive offers.\n\nSourced from `IFastUpdateIncentiveManager.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IFastUpdateIncentiveManager.sol).",
    "file_name": "files/hub-docs/ftso/solidity-reference/IFastUpdateIncentiveManager.md",
    "meta_data": {
      "title": "IFastUpdateIncentiveManager",
      "sidebar_position": 6,
      "description": "Interface for making volatility incentive offers."
    },
    "type": "answer"
  },
  {
    "content": "Interface for converting feed names to feed ids.\n\nSourced from `IFtsoFeedIdConverter.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IFtsoFeedIdConverter.sol).\n\nInterface for converting feed names to feed ids.\n\nSourced from `IFtsoFeedIdConverter.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IFtsoFeedIdConverter.sol).",
    "file_name": "files/hub-docs/ftso/solidity-reference/IFtsoFeedIdConverter.md",
    "meta_data": {
      "title": "IFtsoFeedIdConverter",
      "description": "Interface for converting feed names to feed ids.",
      "sidebar_position": 3
    },
    "type": "answer"
  },
  {
    "content": "import Remix from \"@site/src/components/remix\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport FTSOV2FeedById from \"!!raw-loader!/examples/developer-hub-solidity/FTSOV2FeedById.sol\";\nimport FTSOV2FeedByIdWei from \"!!raw-loader!/examples/developer-hub-solidity/FTSOV2FeedByIdWei.sol\";\nimport FTSOV2FeedsById from \"!!raw-loader!/examples/developer-hub-solidity/FTSOV2FeedsById.sol\";\nimport FTSOV2FeedsByIdWei from \"!!raw-loader!/examples/developer-hub-solidity/FTSOV2FeedsByIdWei.sol\";\nimport FTSOV2VerifyProof from \"!!raw-loader!/examples/developer-hub-solidity/FTSOV2VerifyProof.sol\";\n\nPrimary interface for interacting with FTSOv2. This is a long-term support (LTS) interface, designed to ensure continuity even as underlying contracts evolve or protocols migrate to new versions.\n\nSourced from `FtsoV2Interface.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/LTS/FtsoV2Interface.sol).\n\nimport Remix from \"@site/src/components/remix\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport FTSOV2FeedById from \"!!raw-loader!/examples/developer-hub-solidity/FTSOV2FeedById.sol\";\nimport FTSOV2FeedByIdWei from \"!!raw-loader!/examples/developer-hub-solidity/FTSOV2FeedByIdWei.sol\";\nimport FTSOV2FeedsById from \"!!raw-loader!/examples/developer-hub-solidity/FTSOV2FeedsById.sol\";\nimport FTSOV2FeedsByIdWei from \"!!raw-loader!/examples/developer-hub-solidity/FTSOV2FeedsByIdWei.sol\";\nimport FTSOV2VerifyProof from \"!!raw-loader!/examples/developer-hub-solidity/FTSOV2VerifyProof.sol\";\n\nPrimary interface for interacting with FTSOv2. This is a long-term support (LTS) interface, designed to ensure continuity even as underlying contracts evolve or protocols migrate to new versions.\n\nSourced from `FtsoV2Interface.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/LTS/FtsoV2Interface.sol).\n\nimport Remix from \"@site/src/components/remix\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport FTSOV2FeedById from \"!!raw-loader!/examples/developer-hub-solidity/FTSOV2FeedById.sol\";\nimport FTSOV2FeedByIdWei from \"!!raw-loader!/examples/developer-hub-solidity/FTSOV2FeedByIdWei.sol\";\nimport FTSOV2FeedsById from \"!!raw-loader!/examples/developer-hub-solidity/FTSOV2FeedsById.sol\";\nimport FTSOV2FeedsByIdWei from \"!!raw-loader!/examples/developer-hub-solidity/FTSOV2FeedsByIdWei.sol\";\nimport FTSOV2VerifyProof from \"!!raw-loader!/examples/developer-hub-solidity/FTSOV2VerifyProof.sol\";\n\nPrimary interface for interacting with FTSOv2. This is a long-term support (LTS) interface, designed to ensure continuity even as underlying contracts evolve or protocols migrate to new versions.\n\nSourced from `FtsoV2Interface.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/LTS/FtsoV2Interface.sol).",
    "file_name": "files/hub-docs/ftso/solidity-reference/FtsoV2Interface.md",
    "meta_data": {
      "title": "FtsoV2Interface",
      "sidebar_position": 1,
      "description": "Primary interface for interacting with FTSOv2."
    },
    "type": "answer"
  },
  {
    "content": "Interface for updating block-latency feeds.\n\nSourced from `IFastUpdater.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IFastUpdater.sol).\n\nInterface for updating block-latency feeds.\n\nSourced from `IFastUpdater.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IFastUpdater.sol).\n\nInterface for updating block-latency feeds.\n\nSourced from `IFastUpdater.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IFastUpdater.sol).\n\nInterface for updating block-latency feeds.\n\nSourced from `IFastUpdater.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IFastUpdater.sol).",
    "file_name": "files/hub-docs/ftso/solidity-reference/IFastUpdater.md",
    "meta_data": {
      "title": "IFastUpdater",
      "sidebar_position": 4,
      "description": "Interface for updating block-latency feeds."
    },
    "type": "answer"
  },
  {
    "content": "Interface for calculating block-latency feed fees.\n\nSourced from `IFeeCalculator.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IFeeCalculator.sol).\n\nInterface for calculating block-latency feed fees.\n\nSourced from `IFeeCalculator.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IFeeCalculator.sol).",
    "file_name": "files/hub-docs/ftso/solidity-reference/IFeeCalculator.md",
    "meta_data": {
      "title": "IFeeCalculator",
      "description": "Interface for calculating block-latency feed fees.",
      "sidebar_position": 2
    },
    "type": "answer"
  },
  {
    "content": "Interface for the block-latency feed configuration.\n\nSourced from `IFastUpdatesConfiguration.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IFastUpdatesConfiguration.sol).\n\nInterface for the block-latency feed configuration.\n\nSourced from `IFastUpdatesConfiguration.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IFastUpdatesConfiguration.sol).\n\nInterface for the block-latency feed configuration.\n\nSourced from `IFastUpdatesConfiguration.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IFastUpdatesConfiguration.sol).\n\nInterface for the block-latency feed configuration.\n\nSourced from `IFastUpdatesConfiguration.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IFastUpdatesConfiguration.sol).",
    "file_name": "files/hub-docs/ftso/solidity-reference/IFastUpdatesConfiguration.md",
    "meta_data": {
      "title": "IFastUpdatesConfiguration",
      "sidebar_position": 5,
      "description": "Interface for the block-latency feed configuration."
    },
    "type": "answer"
  },
  {
    "content": "import CodeBlock from \"@theme/CodeBlock\";\nimport TabItem from \"@theme/TabItem\";\nimport Tabs from \"@theme/Tabs\";\nimport Remix from \"@site/src/components/remix\";\nimport FetchAnchorFeedsJs from \"!!raw-loader!/examples/developer-hub-javascript/fetch_anchor_feeds.js\";\nimport FetchAnchorFeedsPy from \"!!raw-loader!/examples/developer-hub-python/fetch_anchor_feeds.py\";\nimport FetchAnchorFeedsGo from \"!!raw-loader!/examples/developer-hub-go/flare/fetch_anchor_feeds.go\";\nimport FetchAnchorFeedsRs from \"!!raw-loader!/examples/developer-hub-rust/src/bin/fetch_anchor_feeds.rs\";\nimport FetchAndVerifyAnchorOnchainJs from \"!!raw-loader!/examples/developer-hub-javascript/fetch_and_verify_anchor_onchain.js\";\nimport FetchAndVerifyAnchorOnchainPy from \"!!raw-loader!/examples/developer-hub-python/fetch_and_verify_anchor_onchain.py\";\nimport FetchAndVerifyAnchorOnchainRs from \"!!raw-loader!/examples/developer-hub-rust/src/bin/fetch_and_verify_anchor_onchain.rs\";\nimport FetchAndVerifyAnchorOnchainGo from \"!!raw-loader!/examples/developer-hub-go/flare/fetch_and_verify_anchor_onchain.go\";\nimport FtsoV2AnchorFeedConsumer from \"!!raw-loader!/examples/developer-hub-solidity/FtsoV2AnchorFeedConsumer.sol\";\n\nScaling enables offchain access to anchor feeds by leveraging Flare's network of 100 independent data providers and a robust commit-reveal process every 90 seconds.\n\nTo read anchor feeds on Flare, follow these key steps:\n\n1. **Fetch anchor feed data offchain:**\n\n   Use the Data Availability (DA) Layer API to retrieve anchor feeds and their associated cryptographic proofs.\n\n2. **Verify the proof onchain:**\n\n   Validate the provided proof onchain to ensure the data matches the finalized version committed by [Scaling](/ftso/scaling/overview).\n\n3. **Use the feed data onchain:**\n\n   After verification, integrate the feed data into your onchain application logic.\n\nScaling only stores **commitments to feed data** onchain. Complete feed data resides offchain but can be verified against an onchain Merkle root, ensuring data integrity and tamper resistance.\n\nimport CodeBlock from \"@theme/CodeBlock\";\nimport TabItem from \"@theme/TabItem\";\nimport Tabs from \"@theme/Tabs\";\nimport Remix from \"@site/src/components/remix\";\nimport FetchAnchorFeedsJs from \"!!raw-loader!/examples/developer-hub-javascript/fetch_anchor_feeds.js\";\nimport FetchAnchorFeedsPy from \"!!raw-loader!/examples/developer-hub-python/fetch_anchor_feeds.py\";\nimport FetchAnchorFeedsGo from \"!!raw-loader!/examples/developer-hub-go/flare/fetch_anchor_feeds.go\";\nimport FetchAnchorFeedsRs from \"!!raw-loader!/examples/developer-hub-rust/src/bin/fetch_anchor_feeds.rs\";\nimport FetchAndVerifyAnchorOnchainJs from \"!!raw-loader!/examples/developer-hub-javascript/fetch_and_verify_anchor_onchain.js\";\nimport FetchAndVerifyAnchorOnchainPy from \"!!raw-loader!/examples/developer-hub-python/fetch_and_verify_anchor_onchain.py\";\nimport FetchAndVerifyAnchorOnchainRs from \"!!raw-loader!/examples/developer-hub-rust/src/bin/fetch_and_verify_anchor_onchain.rs\";\nimport FetchAndVerifyAnchorOnchainGo from \"!!raw-loader!/examples/developer-hub-go/flare/fetch_and_verify_anchor_onchain.go\";\nimport FtsoV2AnchorFeedConsumer from \"!!raw-loader!/examples/developer-hub-solidity/FtsoV2AnchorFeedConsumer.sol\";\n\nScaling enables offchain access to anchor feeds by leveraging Flare's network of 100 independent data providers and a robust commit-reveal process every 90 seconds.\n\nTo read anchor feeds on Flare, follow these key steps:\n\n1. **Fetch anchor feed data offchain:**\n\n   Use the Data Availability (DA) Layer API to retrieve anchor feeds and their associated cryptographic proofs.\n\n2. **Verify the proof onchain:**\n\n   Validate the provided proof onchain to ensure the data matches the finalized version committed by [Scaling](/ftso/scaling/overview).\n\n3. **Use the feed data onchain:**\n\n   After verification, integrate the feed data into your onchain application logic.\n\nScaling only stores **commitments to feed data** onchain. Complete feed data resides offchain but can be verified against an onchain Merkle root, ensuring data integrity and tamper resistance.",
    "file_name": "files/hub-docs/ftso/scaling/2-getting-started.mdx",
    "meta_data": {
      "sidebar_position": 2,
      "title": "Getting Started",
      "description": "Learn how to consume Scaling feeds on Flare.",
      "keywords": [
        "ftso",
        "oracle",
        "flare-time-series-oracle",
        "flare-network",
        "smart-contracts",
        "solidity"
      ]
    },
    "type": "answer"
  },
  {
    "content": "import CodeBlock from \"@theme/CodeBlock\";\nimport TabItem from \"@theme/TabItem\";\nimport Tabs from \"@theme/Tabs\";\nimport Remix from \"@site/src/components/remix\";\nimport FetchAnchorFeedsJs from \"!!raw-loader!/examples/developer-hub-javascript/fetch_anchor_feeds.js\";\nimport FetchAnchorFeedsPy from \"!!raw-loader!/examples/developer-hub-python/fetch_anchor_feeds.py\";\nimport FetchAnchorFeedsGo from \"!!raw-loader!/examples/developer-hub-go/flare/fetch_anchor_feeds.go\";\nimport FetchAnchorFeedsRs from \"!!raw-loader!/examples/developer-hub-rust/src/bin/fetch_anchor_feeds.rs\";\nimport FetchAndVerifyAnchorOnchainJs from \"!!raw-loader!/examples/developer-hub-javascript/fetch_and_verify_anchor_onchain.js\";\nimport FetchAndVerifyAnchorOnchainPy from \"!!raw-loader!/examples/developer-hub-python/fetch_and_verify_anchor_onchain.py\";\nimport FetchAndVerifyAnchorOnchainRs from \"!!raw-loader!/examples/developer-hub-rust/src/bin/fetch_and_verify_anchor_onchain.rs\";\nimport FetchAndVerifyAnchorOnchainGo from \"!!raw-loader!/examples/developer-hub-go/flare/fetch_and_verify_anchor_onchain.go\";\nimport FtsoV2AnchorFeedConsumer from \"!!raw-loader!/examples/developer-hub-solidity/FtsoV2AnchorFeedConsumer.sol\";\n\nScaling enables offchain access to anchor feeds by leveraging Flare's network of 100 independent data providers and a robust commit-reveal process every 90 seconds.\n\nTo read anchor feeds on Flare, follow these key steps:\n\n1. **Fetch anchor feed data offchain:**\n\n   Use the Data Availability (DA) Layer API to retrieve anchor feeds and their associated cryptographic proofs.\n\n2. **Verify the proof onchain:**\n\n   Validate the provided proof onchain to ensure the data matches the finalized version committed by [Scaling](/ftso/scaling/overview).\n\n3. **Use the feed data onchain:**\n\n   After verification, integrate the feed data into your onchain application logic.\n\nScaling only stores **commitments to feed data** onchain. Complete feed data resides offchain but can be verified against an onchain Merkle root, ensuring data integrity and tamper resistance.\n\nimport CodeBlock from \"@theme/CodeBlock\";\nimport TabItem from \"@theme/TabItem\";\nimport Tabs from \"@theme/Tabs\";\nimport Remix from \"@site/src/components/remix\";\nimport FetchAnchorFeedsJs from \"!!raw-loader!/examples/developer-hub-javascript/fetch_anchor_feeds.js\";\nimport FetchAnchorFeedsPy from \"!!raw-loader!/examples/developer-hub-python/fetch_anchor_feeds.py\";\nimport FetchAnchorFeedsGo from \"!!raw-loader!/examples/developer-hub-go/flare/fetch_anchor_feeds.go\";\nimport FetchAnchorFeedsRs from \"!!raw-loader!/examples/developer-hub-rust/src/bin/fetch_anchor_feeds.rs\";\nimport FetchAndVerifyAnchorOnchainJs from \"!!raw-loader!/examples/developer-hub-javascript/fetch_and_verify_anchor_onchain.js\";\nimport FetchAndVerifyAnchorOnchainPy from \"!!raw-loader!/examples/developer-hub-python/fetch_and_verify_anchor_onchain.py\";\nimport FetchAndVerifyAnchorOnchainRs from \"!!raw-loader!/examples/developer-hub-rust/src/bin/fetch_and_verify_anchor_onchain.rs\";\nimport FetchAndVerifyAnchorOnchainGo from \"!!raw-loader!/examples/developer-hub-go/flare/fetch_and_verify_anchor_onchain.go\";\nimport FtsoV2AnchorFeedConsumer from \"!!raw-loader!/examples/developer-hub-solidity/FtsoV2AnchorFeedConsumer.sol\";\n\nScaling enables offchain access to anchor feeds by leveraging Flare's network of 100 independent data providers and a robust commit-reveal process every 90 seconds.\n\nTo read anchor feeds on Flare, follow these key steps:\n\n1. **Fetch anchor feed data offchain:**\n\n   Use the Data Availability (DA) Layer API to retrieve anchor feeds and their associated cryptographic proofs.\n\n2. **Verify the proof onchain:**\n\n   Validate the provided proof onchain to ensure the data matches the finalized version committed by [Scaling](/ftso/scaling/overview).\n\n3. **Use the feed data onchain:**\n\n   After verification, integrate the feed data into your onchain application logic.\n\nScaling only stores **commitments to feed data** onchain. Complete feed data resides offchain but can be verified against an onchain Merkle root, ensuring data integrity and tamper resistance.",
    "file_name": "files/hub-docs/ftso/scaling/2-getting-started.mdx",
    "meta_data": {
      "sidebar_position": 2,
      "title": "Getting Started",
      "description": "Learn how to consume Scaling feeds on Flare.",
      "keywords": [
        "ftso",
        "oracle",
        "flare-time-series-oracle",
        "flare-network",
        "smart-contracts",
        "solidity"
      ]
    },
    "type": "answer"
  },
  {
    "content": "import CodeBlock from \"@theme/CodeBlock\";\nimport TabItem from \"@theme/TabItem\";\nimport Tabs from \"@theme/Tabs\";\nimport Remix from \"@site/src/components/remix\";\nimport FetchAnchorFeedsJs from \"!!raw-loader!/examples/developer-hub-javascript/fetch_anchor_feeds.js\";\nimport FetchAnchorFeedsPy from \"!!raw-loader!/examples/developer-hub-python/fetch_anchor_feeds.py\";\nimport FetchAnchorFeedsGo from \"!!raw-loader!/examples/developer-hub-go/flare/fetch_anchor_feeds.go\";\nimport FetchAnchorFeedsRs from \"!!raw-loader!/examples/developer-hub-rust/src/bin/fetch_anchor_feeds.rs\";\nimport FetchAndVerifyAnchorOnchainJs from \"!!raw-loader!/examples/developer-hub-javascript/fetch_and_verify_anchor_onchain.js\";\nimport FetchAndVerifyAnchorOnchainPy from \"!!raw-loader!/examples/developer-hub-python/fetch_and_verify_anchor_onchain.py\";\nimport FetchAndVerifyAnchorOnchainRs from \"!!raw-loader!/examples/developer-hub-rust/src/bin/fetch_and_verify_anchor_onchain.rs\";\nimport FetchAndVerifyAnchorOnchainGo from \"!!raw-loader!/examples/developer-hub-go/flare/fetch_and_verify_anchor_onchain.go\";\nimport FtsoV2AnchorFeedConsumer from \"!!raw-loader!/examples/developer-hub-solidity/FtsoV2AnchorFeedConsumer.sol\";\n\nScaling enables offchain access to anchor feeds by leveraging Flare's network of 100 independent data providers and a robust commit-reveal process every 90 seconds.\n\nTo read anchor feeds on Flare, follow these key steps:\n\n1. **Fetch anchor feed data offchain:**\n\n   Use the Data Availability (DA) Layer API to retrieve anchor feeds and their associated cryptographic proofs.\n\n2. **Verify the proof onchain:**\n\n   Validate the provided proof onchain to ensure the data matches the finalized version committed by [Scaling](/ftso/scaling/overview).\n\n3. **Use the feed data onchain:**\n\n   After verification, integrate the feed data into your onchain application logic.\n\nScaling only stores **commitments to feed data** onchain. Complete feed data resides offchain but can be verified against an onchain Merkle root, ensuring data integrity and tamper resistance.",
    "file_name": "files/hub-docs/ftso/scaling/2-getting-started.mdx",
    "meta_data": {
      "sidebar_position": 2,
      "title": "Getting Started",
      "description": "Learn how to consume Scaling feeds on Flare.",
      "keywords": [
        "ftso",
        "oracle",
        "flare-time-series-oracle",
        "flare-network",
        "smart-contracts",
        "solidity"
      ]
    },
    "type": "answer"
  },
  {
    "content": "import ThemedImage from \"@theme/ThemedImage\";\nimport useBaseUrl from \"@docusaurus/useBaseUrl\";\n\n**Scaling** is an advanced framework designed to optimize the functionality and efficiency of FTSOv2. It operates through data providers who submit feed estimates weighted by their stake in the network. These estimates are processed using a weighted median algorithm to determine consensus feed values. Scaling offers several enhancements:\n\n- Supports up to 1000 data feeds across various asset classes, including equities, commodities, and cryptocurrencies, and offers access to 2 weeks of historical data.\n\n- Uses a commit-reveal process across approximately 100 independent data providers every 90 seconds to ensure data integrity and accuracy.\n\n- Optimizes median value computation and data storage to consume less than 5% of network bandwidth at peak usage.\n\nimport ThemedImage from \"@theme/ThemedImage\";\nimport useBaseUrl from \"@docusaurus/useBaseUrl\";\n\n**Scaling** is an advanced framework designed to optimize the functionality and efficiency of FTSOv2. It operates through data providers who submit feed estimates weighted by their stake in the network. These estimates are processed using a weighted median algorithm to determine consensus feed values. Scaling offers several enhancements:\n\n- Supports up to 1000 data feeds across various asset classes, including equities, commodities, and cryptocurrencies, and offers access to 2 weeks of historical data.\n\n- Uses a commit-reveal process across approximately 100 independent data providers every 90 seconds to ensure data integrity and accuracy.\n\n- Optimizes median value computation and data storage to consume less than 5% of network bandwidth at peak usage.",
    "file_name": "files/hub-docs/ftso/scaling/1-overview.mdx",
    "meta_data": {
      "sidebar_position": 1,
      "slug": "overview",
      "title": "Scaling",
      "description": "Scaling is an advanced framework designed to optimize the functionality and efficiency of FTSOv2.",
      "keywords": [
        "ftso",
        "oracle",
        "flare-time-series-oracle",
        "flare-network"
      ]
    },
    "type": "answer"
  },
  {
    "content": "import AnchorFeeds from \"@site/src/components/DataTables/AnchorFeeds\";\nimport FeedExplanation from \"../_feed_explanation.mdx\";\n\nScaling's anchor feeds update every 90 seconds with each new voting epoch on Flare. These feeds, accessible offchain, support various asset classes including equities, commodities, and cryptocurrencies.\n\nEach anchor feed is uniquely identified by an ID composed of three components in a structured encoding process:\n\n1. **Category:** Indicates the type of asset:\n\n   - Crypto: `01`\n   - Forex: `02`\n   - Commodity: `03`\n   - Stock: `04`\n\n2. **Hex-Encoded Feed Name:** The name of the feed is converted to a hexadecimal format.\n\n3. **Zero Padding:** The combined category and hex-encoded feed name are padded with zeros to a length of 21 bytes.\n\nThe resulting string is then prefixed with `0x`.\n\n<FeedExplanation />\n\n:::warning\n\nFeed IDs are not addresses. They are `bytes21` structured encodings that combine the category and feed name to ensure each feed has a unique identifier.\n\n:::\n\n<AnchorFeeds />",
    "meta_data": {
      "sidebar_position": 3,
      "slug": "anchor-feeds",
      "title": "Anchor Feeds",
      "description": "Scaling anchor feeds update every voting epoch on Flare, approximately every 90s.",
      "keywords": [
        "ftso",
        "oracle",
        "flare-time-series-oracle",
        "flare-network",
        "feeds"
      ]
    },
    "file_name": "files/hub-docs/ftso/scaling/3-anchor-feeds.mdx",
    "type": "answer"
  },
  {
    "content": "import Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport DocCardList from \"@theme/DocCardList\";\n\nimport Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport DocCardList from \"@theme/DocCardList\";\n\nimport Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport DocCardList from \"@theme/DocCardList\";",
    "file_name": "files/hub-docs/ftso/scaling/4-solidity-reference.mdx",
    "meta_data": {
      "title": "Scaling Reference",
      "description": "Solidity reference for Scaling smart contracts.",
      "keywords": [
        "solidity",
        "reference",
        "ftso",
        "flare-time-series-oracle",
        "flare-network",
        "smart-contracts"
      ]
    },
    "type": "answer"
  },
  {
    "content": "FtsoInflationConfigurations interface.\nSourced from `IFtsoInflationConfigurations.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IFtsoInflationConfigurations.sol).\n\nFtsoInflationConfigurations interface.\nSourced from `IFtsoInflationConfigurations.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IFtsoInflationConfigurations.sol).\n\nFtsoInflationConfigurations interface.\nSourced from `IFtsoInflationConfigurations.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IFtsoInflationConfigurations.sol).",
    "file_name": "files/hub-docs/ftso/scaling/solidity-reference/IFtsoInflationConfigurations.md",
    "meta_data": {
      "title": "IFtsoInflationConfigurations"
    },
    "type": "answer"
  },
  {
    "content": "FtsoRewardOffersManager interface.\nSourced from `IFtsoRewardOffersManager.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IFtsoRewardOffersManager.sol).\n\nFtsoRewardOffersManager interface.\nSourced from `IFtsoRewardOffersManager.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IFtsoRewardOffersManager.sol).\n\nFtsoRewardOffersManager interface.\nSourced from `IFtsoRewardOffersManager.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IFtsoRewardOffersManager.sol).\n\nFtsoRewardOffersManager interface.\nSourced from `IFtsoRewardOffersManager.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IFtsoRewardOffersManager.sol).",
    "file_name": "files/hub-docs/ftso/scaling/solidity-reference/IFtsoRewardOffersManager.md",
    "meta_data": {
      "title": "IFtsoRewardOffersManager"
    },
    "type": "answer"
  },
  {
    "content": "FtsoFeedPublisher interface.\nSourced from `IFtsoFeedPublisher.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IFtsoFeedPublisher.sol).\n\nFtsoFeedPublisher interface.\nSourced from `IFtsoFeedPublisher.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IFtsoFeedPublisher.sol).\n\nFtsoFeedPublisher interface.\nSourced from `IFtsoFeedPublisher.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IFtsoFeedPublisher.sol).\n\nFtsoFeedPublisher interface.\nSourced from `IFtsoFeedPublisher.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IFtsoFeedPublisher.sol).",
    "file_name": "files/hub-docs/ftso/scaling/solidity-reference/IFtsoFeedPublisher.md",
    "meta_data": {
      "title": "IFtsoFeedPublisher"
    },
    "type": "answer"
  },
  {
    "content": "The [Handshake](/fassets/minting#handshake) in the FAsset system is an optional step where an agent verifies the minter's or redeemer's address using an external service to ensure compliance (e.g., sanctions checks) before proceeding with minting or redemption. If enabled, the agent must approve the provided address within a set time; failure to respond allows the user to cancel or proceed based on system rules.\n\nFAssets agents can establish custom handshake mechanisms for verifying minters and redeemers. The most straightforward approach is to create a separate web service that exposes an API which accepts two parameters:\n\n- API service URL\n- Address that requires verification\n\nYou need to configure the `kyc` block in the `secrets.json` file.\n\n```json\n\"kyc\": {\n    \"url\": \"\",\n    \"api_key\": \"\"\n}\n```\n\nThe `url` field represents the web service link, while the `api_key` field is sent as a custom header using the variable `Token`.\n\n:::info\n\nYou can check [`HandshakeAddressVerifier.ts`](https://github.com/flare-labs-ltd/fasset-bots/blob/main/packages/fasset-bots-core/src/actors/plugins/HandshakeAddressVerifier.ts) for implementation details related to the `ChainalysisClient` class in the [fasset-bots](https://github.com/flare-labs-ltd/fasset-bots) repo.\n\n:::",
    "meta_data": {
      "sidebar_position": 4,
      "slug": "custom-handshake",
      "title": "Implement Custom Handshake",
      "description": "Implement compliance checks for minting and redeeming.",
      "tags": [
        "intermediate",
        "fassets",
        "bitcoin",
        "dogecoin"
      ],
      "authors": [
        "fassko"
      ],
      "keywords": [
        "fassets",
        "xrp",
        "btc",
        "doge flare-network",
        "flare-network"
      ]
    },
    "file_name": "files/hub-docs/fassets/guides/4-custom-handshake.mdx",
    "type": "answer"
  },
  {
    "content": "To restart and update the FAssets agent, execute the following commands, replacing `FASSET` with the name of the FAsset (FXRP, FDOGE, or FBTC):\n\n```bash\ndocker compose down\ngit pull\ndocker compose pull\ndocker compose --profile cli run agent-bot listAgents --fasset FASSET\ndocker compose up -d\n```\n",
    "meta_data": {},
    "file_name": "files/hub-docs/fassets/guides/_restart_docker.mdx",
    "type": "answer"
  },
  {
    "content": "This guide explains how to export the private keys for the FAssets agent's underlying address by specifying the export file in the Docker container setup. This process is essential if you need to migrate your FAssets agent after full liquidation.\n\n1. Create a directory named `export` to export the private keys.\n2. Assign ownership of the directory to user ID 1000 by setting the appropriate permissions:\n\n   ```bash\n   sudo chown 1000:1000 export -R\n   ```\n\n3. Execute the following command to export the private keys and mount the export path to the Docker container:\n\n   ```bash\n   docker-compose --profile cli run -v $(pwd)/export:/export agent-bot exportPrivateKeys /export/keys.tmp --fasset FXRP\n   ```",
    "meta_data": {
      "sidebar_position": 6,
      "slug": "export-private-keys",
      "title": "Export Private Keys",
      "description": "Export private keys for minting and redeeming",
      "tags": [
        "intermediate",
        "fassets",
        "bitcoin",
        "dogecoin"
      ],
      "authors": [
        "fassko"
      ],
      "keywords": [
        "fassets",
        "xrp",
        "btc",
        "doge flare-network",
        "flare-network"
      ]
    },
    "file_name": "files/hub-docs/fassets/guides/6-export-private-keys.mdx",
    "type": "answer"
  },
  {
    "content": "import FAssetsAgentInterface from \"/static/img/fassets/fassets-agent.png\";\nimport FAssetsAgentInterfaceAddVault from \"/static/img/fassets/fassets-agent-add-vault.png\";\nimport FAssetsAgentInterfaceAddVaultForm from \"/static/img/fassets/fassets-agent-add-vault-form.png\";\nimport FAssetsAgentInterfaceVaultOperations from \"/static/img/fassets/fassets-agent-vault-operations.png\";\n\nThe FAssets Agent user interface (UI) is designed to provide a seamless and intuitive experience for users managing the FAssets agent. It allows users to monitor the agent bot and create and manage FAssets agent vaults.\n\nYou can access the FAssets Agent UI after you follow the guide how to [set up the FAssets agent](/fassets/guides/deploy-fassets-agent).\n\n<img src={FAssetsAgentInterface} />\n\nimport FAssetsAgentInterface from \"/static/img/fassets/fassets-agent.png\";\nimport FAssetsAgentInterfaceAddVault from \"/static/img/fassets/fassets-agent-add-vault.png\";\nimport FAssetsAgentInterfaceAddVaultForm from \"/static/img/fassets/fassets-agent-add-vault-form.png\";\nimport FAssetsAgentInterfaceVaultOperations from \"/static/img/fassets/fassets-agent-vault-operations.png\";\n\nThe FAssets Agent user interface (UI) is designed to provide a seamless and intuitive experience for users managing the FAssets agent. It allows users to monitor the agent bot and create and manage FAssets agent vaults.\n\nYou can access the FAssets Agent UI after you follow the guide how to [set up the FAssets agent](/fassets/guides/deploy-fassets-agent).\n\n<img src={FAssetsAgentInterface} />\n\nimport FAssetsAgentInterface from \"/static/img/fassets/fassets-agent.png\";\nimport FAssetsAgentInterfaceAddVault from \"/static/img/fassets/fassets-agent-add-vault.png\";\nimport FAssetsAgentInterfaceAddVaultForm from \"/static/img/fassets/fassets-agent-add-vault-form.png\";\nimport FAssetsAgentInterfaceVaultOperations from \"/static/img/fassets/fassets-agent-vault-operations.png\";\n\nThe FAssets Agent user interface (UI) is designed to provide a seamless and intuitive experience for users managing the FAssets agent. It allows users to monitor the agent bot and create and manage FAssets agent vaults.\n\nYou can access the FAssets Agent UI after you follow the guide how to [set up the FAssets agent](/fassets/guides/deploy-fassets-agent).\n\n<img src={FAssetsAgentInterface} />\n\nimport FAssetsAgentInterface from \"/static/img/fassets/fassets-agent.png\";\nimport FAssetsAgentInterfaceAddVault from \"/static/img/fassets/fassets-agent-add-vault.png\";\nimport FAssetsAgentInterfaceAddVaultForm from \"/static/img/fassets/fassets-agent-add-vault-form.png\";\nimport FAssetsAgentInterfaceVaultOperations from \"/static/img/fassets/fassets-agent-vault-operations.png\";\n\nThe FAssets Agent user interface (UI) is designed to provide a seamless and intuitive experience for users managing the FAssets agent. It allows users to monitor the agent bot and create and manage FAssets agent vaults.\n\nYou can access the FAssets Agent UI after you follow the guide how to [set up the FAssets agent](/fassets/guides/deploy-fassets-agent).\n\n<img src={FAssetsAgentInterface} />\n\nimport FAssetsAgentInterface from \"/static/img/fassets/fassets-agent.png\";\nimport FAssetsAgentInterfaceAddVault from \"/static/img/fassets/fassets-agent-add-vault.png\";\nimport FAssetsAgentInterfaceAddVaultForm from \"/static/img/fassets/fassets-agent-add-vault-form.png\";\nimport FAssetsAgentInterfaceVaultOperations from \"/static/img/fassets/fassets-agent-vault-operations.png\";\n\nThe FAssets Agent user interface (UI) is designed to provide a seamless and intuitive experience for users managing the FAssets agent. It allows users to monitor the agent bot and create and manage FAssets agent vaults.\n\nYou can access the FAssets Agent UI after you follow the guide how to [set up the FAssets agent](/fassets/guides/deploy-fassets-agent).\n\n<img src={FAssetsAgentInterface} />\n\nimport FAssetsAgentInterface from \"/static/img/fassets/fassets-agent.png\";\nimport FAssetsAgentInterfaceAddVault from \"/static/img/fassets/fassets-agent-add-vault.png\";\nimport FAssetsAgentInterfaceAddVaultForm from \"/static/img/fassets/fassets-agent-add-vault-form.png\";\nimport FAssetsAgentInterfaceVaultOperations from \"/static/img/fassets/fassets-agent-vault-operations.png\";\n\nThe FAssets Agent user interface (UI) is designed to provide a seamless and intuitive experience for users managing the FAssets agent. It allows users to monitor the agent bot and create and manage FAssets agent vaults.\n\nYou can access the FAssets Agent UI after you follow the guide how to [set up the FAssets agent](/fassets/guides/deploy-fassets-agent).\n\n<img src={FAssetsAgentInterface} />",
    "file_name": "files/hub-docs/fassets/guides/2-create-fasset-agent-ui.mdx",
    "meta_data": {
      "sidebar_position": 2,
      "slug": "create-fasset-agent-ui",
      "title": "Create FAssets Agent via UI",
      "description": "Set up and manage an FAssets agent using the frontend UI.",
      "tags": [
        "intermediate",
        "fassets",
        "bitcoin",
        "dogecoin"
      ],
      "authors": [
        "fassko"
      ],
      "keywords": [
        "fassets",
        "xrp",
        "btc",
        "doge flare-network",
        "flare-network"
      ]
    },
    "type": "answer"
  },
  {
    "content": "The agent bot can send notifications to a Telegram bot or API endpoint.\nIt helps monitor the health of the agent and the network.\n\nThe agent bot can send notifications to a Telegram bot or API endpoint.\nIt helps monitor the health of the agent and the network.\n\nThe agent bot can send notifications to a Telegram bot or API endpoint.\nIt helps monitor the health of the agent and the network.",
    "file_name": "files/hub-docs/fassets/guides/7-agent-bot-notifications.mdx",
    "meta_data": {
      "sidebar_position": 7,
      "slug": "agent-bot-notifications",
      "title": "Agent Bot Notifications",
      "description": "Learn how to set up agent bot notifications for FAssets.",
      "tags": [
        "intermediate",
        "fassets",
        "bitcoin",
        "dogecoin"
      ],
      "authors": [
        "fassko"
      ],
      "keywords": [
        "fassets",
        "xrp",
        "btc",
        "doge flare-network",
        "flare-network"
      ]
    },
    "type": "answer"
  },
  {
    "content": "import RestartDocker from \"./_restart_docker.mdx\";\n\nThe FAssets system by Flare enables non-smart contract tokens like BTC and XRP to interact trustlessly with smart contracts on the Flare network, unlocking their use in DeFi applications. It achieves this through collateralized minting, utilizing [Flare Data Connector (FDC)](/fdc/overview) and [Flare Time Series Oracle (FTSO)](/ftso/overview) for secure cross-chain functionality.\n\nAgents in the FAssets system facilitate the minting and redemption of FAssets by providing over-collateralized assets and managing transactions securely. A liquidator in the FAssets system monitors agent's collateralization levels to ensure the system's security and trustlessness.\n\nIn this guide, you will learn the preferred methods for setting up and managing the FAssets agents using the frontend interface and running the liquidator bot.\n\nimport RestartDocker from \"./_restart_docker.mdx\";\n\nThe FAssets system by Flare enables non-smart contract tokens like BTC and XRP to interact trustlessly with smart contracts on the Flare network, unlocking their use in DeFi applications. It achieves this through collateralized minting, utilizing [Flare Data Connector (FDC)](/fdc/overview) and [Flare Time Series Oracle (FTSO)](/ftso/overview) for secure cross-chain functionality.\n\nAgents in the FAssets system facilitate the minting and redemption of FAssets by providing over-collateralized assets and managing transactions securely. A liquidator in the FAssets system monitors agent's collateralization levels to ensure the system's security and trustlessness.\n\nIn this guide, you will learn the preferred methods for setting up and managing the FAssets agents using the frontend interface and running the liquidator bot.\n\nimport RestartDocker from \"./_restart_docker.mdx\";\n\nThe FAssets system by Flare enables non-smart contract tokens like BTC and XRP to interact trustlessly with smart contracts on the Flare network, unlocking their use in DeFi applications. It achieves this through collateralized minting, utilizing [Flare Data Connector (FDC)](/fdc/overview) and [Flare Time Series Oracle (FTSO)](/ftso/overview) for secure cross-chain functionality.\n\nAgents in the FAssets system facilitate the minting and redemption of FAssets by providing over-collateralized assets and managing transactions securely. A liquidator in the FAssets system monitors agent's collateralization levels to ensure the system's security and trustlessness.\n\nIn this guide, you will learn the preferred methods for setting up and managing the FAssets agents using the frontend interface and running the liquidator bot.\n\nimport RestartDocker from \"./_restart_docker.mdx\";\n\nThe FAssets system by Flare enables non-smart contract tokens like BTC and XRP to interact trustlessly with smart contracts on the Flare network, unlocking their use in DeFi applications. It achieves this through collateralized minting, utilizing [Flare Data Connector (FDC)](/fdc/overview) and [Flare Time Series Oracle (FTSO)](/ftso/overview) for secure cross-chain functionality.\n\nAgents in the FAssets system facilitate the minting and redemption of FAssets by providing over-collateralized assets and managing transactions securely. A liquidator in the FAssets system monitors agent's collateralization levels to ensure the system's security and trustlessness.\n\nIn this guide, you will learn the preferred methods for setting up and managing the FAssets agents using the frontend interface and running the liquidator bot.\n\nimport RestartDocker from \"./_restart_docker.mdx\";\n\nThe FAssets system by Flare enables non-smart contract tokens like BTC and XRP to interact trustlessly with smart contracts on the Flare network, unlocking their use in DeFi applications. It achieves this through collateralized minting, utilizing [Flare Data Connector (FDC)](/fdc/overview) and [Flare Time Series Oracle (FTSO)](/ftso/overview) for secure cross-chain functionality.\n\nAgents in the FAssets system facilitate the minting and redemption of FAssets by providing over-collateralized assets and managing transactions securely. A liquidator in the FAssets system monitors agent's collateralization levels to ensure the system's security and trustlessness.\n\nIn this guide, you will learn the preferred methods for setting up and managing the FAssets agents using the frontend interface and running the liquidator bot.",
    "file_name": "files/hub-docs/fassets/guides/1-deploy-fassets-agent.mdx",
    "meta_data": {
      "sidebar_position": 1,
      "slug": "deploy-fassets-agent",
      "title": "Deploy an FAssets Agent",
      "description": "Deploy and run an FAssets agent.",
      "tags": [
        "intermediate",
        "fassets",
        "bitcoin",
        "dogecoin"
      ],
      "authors": [
        "fassko"
      ],
      "keywords": [
        "fassets",
        "xrp",
        "btc",
        "doge flare-network",
        "flare-network"
      ]
    },
    "type": "answer"
  },
  {
    "content": "import RestartDocker from \"./_restart_docker.mdx\";\n\nThe FAssets system by Flare enables non-smart contract tokens like BTC and XRP to interact trustlessly with smart contracts on the Flare network, unlocking their use in DeFi applications. It achieves this through collateralized minting, utilizing [Flare Data Connector (FDC)](/fdc/overview) and [Flare Time Series Oracle (FTSO)](/ftso/overview) for secure cross-chain functionality.\n\nAgents in the FAssets system facilitate the minting and redemption of FAssets by providing over-collateralized assets and managing transactions securely. A liquidator in the FAssets system monitors agent's collateralization levels to ensure the system's security and trustlessness.\n\nIn this guide, you will learn the preferred methods for setting up and managing the FAssets agents using the frontend interface and running the liquidator bot.\n\nimport RestartDocker from \"./_restart_docker.mdx\";\n\nThe FAssets system by Flare enables non-smart contract tokens like BTC and XRP to interact trustlessly with smart contracts on the Flare network, unlocking their use in DeFi applications. It achieves this through collateralized minting, utilizing [Flare Data Connector (FDC)](/fdc/overview) and [Flare Time Series Oracle (FTSO)](/ftso/overview) for secure cross-chain functionality.\n\nAgents in the FAssets system facilitate the minting and redemption of FAssets by providing over-collateralized assets and managing transactions securely. A liquidator in the FAssets system monitors agent's collateralization levels to ensure the system's security and trustlessness.\n\nIn this guide, you will learn the preferred methods for setting up and managing the FAssets agents using the frontend interface and running the liquidator bot.\n\nimport RestartDocker from \"./_restart_docker.mdx\";\n\nThe FAssets system by Flare enables non-smart contract tokens like BTC and XRP to interact trustlessly with smart contracts on the Flare network, unlocking their use in DeFi applications. It achieves this through collateralized minting, utilizing [Flare Data Connector (FDC)](/fdc/overview) and [Flare Time Series Oracle (FTSO)](/ftso/overview) for secure cross-chain functionality.\n\nAgents in the FAssets system facilitate the minting and redemption of FAssets by providing over-collateralized assets and managing transactions securely. A liquidator in the FAssets system monitors agent's collateralization levels to ensure the system's security and trustlessness.\n\nIn this guide, you will learn the preferred methods for setting up and managing the FAssets agents using the frontend interface and running the liquidator bot.\n\nimport RestartDocker from \"./_restart_docker.mdx\";\n\nThe FAssets system by Flare enables non-smart contract tokens like BTC and XRP to interact trustlessly with smart contracts on the Flare network, unlocking their use in DeFi applications. It achieves this through collateralized minting, utilizing [Flare Data Connector (FDC)](/fdc/overview) and [Flare Time Series Oracle (FTSO)](/ftso/overview) for secure cross-chain functionality.\n\nAgents in the FAssets system facilitate the minting and redemption of FAssets by providing over-collateralized assets and managing transactions securely. A liquidator in the FAssets system monitors agent's collateralization levels to ensure the system's security and trustlessness.\n\nIn this guide, you will learn the preferred methods for setting up and managing the FAssets agents using the frontend interface and running the liquidator bot.\n\nimport RestartDocker from \"./_restart_docker.mdx\";\n\nThe FAssets system by Flare enables non-smart contract tokens like BTC and XRP to interact trustlessly with smart contracts on the Flare network, unlocking their use in DeFi applications. It achieves this through collateralized minting, utilizing [Flare Data Connector (FDC)](/fdc/overview) and [Flare Time Series Oracle (FTSO)](/ftso/overview) for secure cross-chain functionality.\n\nAgents in the FAssets system facilitate the minting and redemption of FAssets by providing over-collateralized assets and managing transactions securely. A liquidator in the FAssets system monitors agent's collateralization levels to ensure the system's security and trustlessness.\n\nIn this guide, you will learn the preferred methods for setting up and managing the FAssets agents using the frontend interface and running the liquidator bot.",
    "file_name": "files/hub-docs/fassets/guides/1-deploy-fassets-agent.mdx",
    "meta_data": {
      "sidebar_position": 1,
      "slug": "deploy-fassets-agent",
      "title": "Deploy an FAssets Agent",
      "description": "Deploy and run an FAssets agent.",
      "tags": [
        "intermediate",
        "fassets",
        "bitcoin",
        "dogecoin"
      ],
      "authors": [
        "fassko"
      ],
      "keywords": [
        "fassets",
        "xrp",
        "btc",
        "doge flare-network",
        "flare-network"
      ]
    },
    "type": "answer"
  },
  {
    "content": "import RestartDocker from \"./_restart_docker.mdx\";\n\nThe FAssets system by Flare enables non-smart contract tokens like BTC and XRP to interact trustlessly with smart contracts on the Flare network, unlocking their use in DeFi applications. It achieves this through collateralized minting, utilizing [Flare Data Connector (FDC)](/fdc/overview) and [Flare Time Series Oracle (FTSO)](/ftso/overview) for secure cross-chain functionality.\n\nAgents in the FAssets system facilitate the minting and redemption of FAssets by providing over-collateralized assets and managing transactions securely. A liquidator in the FAssets system monitors agent's collateralization levels to ensure the system's security and trustlessness.\n\nIn this guide, you will learn the preferred methods for setting up and managing the FAssets agents using the frontend interface and running the liquidator bot.\n\nimport RestartDocker from \"./_restart_docker.mdx\";\n\nThe FAssets system by Flare enables non-smart contract tokens like BTC and XRP to interact trustlessly with smart contracts on the Flare network, unlocking their use in DeFi applications. It achieves this through collateralized minting, utilizing [Flare Data Connector (FDC)](/fdc/overview) and [Flare Time Series Oracle (FTSO)](/ftso/overview) for secure cross-chain functionality.\n\nAgents in the FAssets system facilitate the minting and redemption of FAssets by providing over-collateralized assets and managing transactions securely. A liquidator in the FAssets system monitors agent's collateralization levels to ensure the system's security and trustlessness.\n\nIn this guide, you will learn the preferred methods for setting up and managing the FAssets agents using the frontend interface and running the liquidator bot.",
    "file_name": "files/hub-docs/fassets/guides/1-deploy-fassets-agent.mdx",
    "meta_data": {
      "sidebar_position": 1,
      "slug": "deploy-fassets-agent",
      "title": "Deploy an FAssets Agent",
      "description": "Deploy and run an FAssets agent.",
      "tags": [
        "intermediate",
        "fassets",
        "bitcoin",
        "dogecoin"
      ],
      "authors": [
        "fassko"
      ],
      "keywords": [
        "fassets",
        "xrp",
        "btc",
        "doge flare-network",
        "flare-network"
      ]
    },
    "type": "answer"
  },
  {
    "content": "The FAssets Bots CLI allows you to create and manage FAssets agent bots and user tools directly from the command line. It also allows you to monitor the agent bot, create FAssets agent vaults, and interact with the FAssets system efficiently.\n\nYou can access the FAssets Agent CLI after you follow the guide on how to [set up the FAssets agent](/fassets/guides/deploy-fassets-agent).\n\n:::info\n\nLearn how to use the FAssets Agent CLI as a [Docker service](/fassets/guides/deploy-fassets-agent#execute-fasset-bot-commands).\n\n:::\n\n### Configure the Agent\n\nYou need to set up your agent's parameters like name, collateral, and fund with underlying assets.\n\n1.  Prepare the agent settings `tmp.agent-settings.json` exchanging `FASSET` with `FXRP`, `FBTC` or `FDOGE` according to which underlying network you want to work on:\n\n    ```bash\n    docker compose --profile cli run agent-bot --fasset FASSET create --prepare\n    ```\n\n2.  Choose a suffix for your agent's collateral pool and fill in the `poolTokenSuffix` field in the `tmp.agent-settings.json`.\n    The `poolTokenSuffix` should only include uppercase letters, numbers, and the `-` symbol.\n    This suffix will be used for the FAsset Collateral Pool Token. For example, for `FXRP`, if you use `MY-ALPHA-AGENT-1`, it would be `FCPT-XRP-MY-ALPHA-AGENT-1`.\n\n3.  The `USDX` is used to back up the agent vault collateral.\n\n4.  In the `secrets.json` file, the `owner.XRP.address`, `owner.BTC.address`, and `owner.DOGE.address` fields represent the underlying accounts that will pay transaction fees for XRP, BTC, and DOGE, respectively.\n\n5.  Create the agent by specifying the FAsset and agent settings, noting that this operation can take up to 10 minutes because the FAssets verifies the underlying assets.\n    This command will print out your agent's address.\n    Exchange `FASSET` with `FXRP`, `FBTC` or `FDOGE` according to which underlying network you are creating the agent.\n\n        ```bash\n        docker compose --profile cli run agent-bot --fasset FASSET create tmp.agent-settings.json\n        ```\n\n### Deposit Collateral\n\nTo make your newly created agent public, it must hold enough [collateral](/fassets/collateral) to mint one lot.\nThis means its agent vault contract needs to be funded with the two collaterals (CFLR and a `USDX`) held by your `owner.native.address`.\n\nYou have two options: either deposit the vault collateral and buy pool collateral separately or use the system function to calculate the needed collateral for you.\n\n#### Deposit Collaterals Together\n\nTo deposit both vault and pool collateral together and let the tool calculate the minimum required collateral to back the lots, you can use the `depositCollateral` function to the agent, specifying your created agent address in the `AGENT_ADDRESS` and lot size in the `LOTS`, as well exchange `FASSET` with `FXRP`, `FBTC` or `FDOGE` according to which underlying network you are creating the agent:\n\n```bash\ndocker compose --profile cli run agent-bot depositCollaterals AGENT_ADDRESS LOTS --fasset FASSET\n```\n\n#### Deposit Collateral Separately\n\n1. Deposit enough vault collateral to the agent specifying your created agent address in the `AGENT_ADDRESS` and the amount of the stablecoin or wrapped ETH in the `AMOUNT` field, as well exchange `FASSET` with `FXRP`, `FBTC` or `FDOGE` according to which underlying network you are creating the agent.\n\n   ```bash\n   docker compose --profile cli run agent-bot depositVaultCollateral AGENT_ADDRESS AMOUNT --fasset FASSET\n   ```\n\n2. Buy enough pool collateral for the agent specifying your agent's address in the `AGENT_ADDRESS` and the amount of the CFLR in the `CFLR_AMOUNT` field, as well exchange `FASSET` with `FXRP`, `FBTC` or `FDOGE` according to which underlying network you are creating the agent.\n\n   ```bash\n   docker compose --profile cli run agent-bot buyPoolCollateral AGENT_ADDRESS CFLR_AMOUNT --fasset FASSET\n   ```\n\n### Register the Agent as Available\n\nYou need to make your agent available to mint and redeem FAssets.\n\n1. Register your agent as available to the network by executing this command replacing the `AGENT_ADDRESS` with your agent address, as well exchange `FASSET` with `FXRP`, `FBTC` or `FDOGE` according to which underlying network you are entering the agent:\n\n   ```bash\n   docker compose --profile cli run agent-bot enter AGENT_ADDRESS --fasset FASSET\n   ```\n\n2. If you deposited enough collateral, you should see that your agent has at least one lot available by running the command replacing `FASSET` with `FXRP`, `FBTC` or `FDOGE` according to which underlying network you are running the agent.\n\n   ```bash\n   docker compose --profile cli run user-bot agents --fasset FASSET\n   ```\n\nIf you don't have available lots, check if the vault and pool collaterals are enough.\n\n:::tip[What's next]\n\nYou can use the [FAssets Agent UI](/fassets/guides/create-fasset-agent-ui) to manage your agent vaults, monitor the agent bot, and perform various actions related to the FAssets agent.\n\n:::",
    "meta_data": {
      "sidebar_position": 3,
      "slug": "create-fasset-agent-cli",
      "title": "Create FAssets Agent via CLI",
      "description": "Set up and manage an FAssets agent using the CLI.",
      "tags": [
        "intermediate",
        "fassets",
        "bitcoin",
        "dogecoin"
      ],
      "authors": [
        "fassko"
      ],
      "keywords": [
        "fassets",
        "xrp",
        "btc",
        "doge flare-network",
        "flare-network"
      ]
    },
    "file_name": "files/hub-docs/fassets/guides/3-create-fasset-agent-cli.mdx",
    "type": "answer"
  },
  {
    "content": "import RestartDocker from \"./_restart_docker.mdx\";\n\nBy default, the FAsset bot operates on Flare infrastructure.\nThis guide explains how to configure it to utilize your own infrastructure for enhanced performance and reliability.\n\nimport RestartDocker from \"./_restart_docker.mdx\";\n\nBy default, the FAsset bot operates on Flare infrastructure.\nThis guide explains how to configure it to utilize your own infrastructure for enhanced performance and reliability.\n\nimport RestartDocker from \"./_restart_docker.mdx\";\n\nBy default, the FAsset bot operates on Flare infrastructure.\nThis guide explains how to configure it to utilize your own infrastructure for enhanced performance and reliability.",
    "file_name": "files/hub-docs/fassets/guides/8-infrastructure.mdx",
    "meta_data": {
      "sidebar_position": 8,
      "slug": "infrastructure",
      "title": "FAssets Agent Infrastructure",
      "description": "Configuring the FAsset Bot to Use Custom Infrastructure",
      "tags": [
        "intermediate",
        "fassets",
        "bitcoin",
        "dogecoin"
      ],
      "authors": [
        "fassko"
      ],
      "keywords": [
        "fassets",
        "xrp",
        "btc",
        "doge flare-network",
        "flare-network"
      ]
    },
    "type": "answer"
  },
  {
    "content": "### How to set up FAssets agent?\n\nRefer to the [FAssets Agent Setup Guide](/fassets/guides/deploy-fassets-agent).\n\n### What are the FAssets agent icon file requirements?\n\nA link to your FAssets agent icon should end with `.png`, `.jpg`, `.svg`, etc., and **must not** be the same as the example provided by the bot.\n\n### Can an agent's logo, description, or name be changed after approval?\n\nNo, it is not.\n\n### Can I register a new management address if one is already whitelisted in my Telegram account?\n\nNo, you would need a new Telegram account.\n\n### What is a management address?\n\nIt is an EVM address you control. Ensure your seed phrase remains secure.\n\n### What is an owner's address, and is it different from a work address?\n\nWork and owner addresses are the same and are referred to as `owner.native.address` in your `secrets.json` file. This address provides collateral for your vault and pool.\n\n### How can I change the agent's fees?\n\nUse the command:\n\n```bash\nupdateAgentSetting <agentVaultAddress> <agentSettingName> <agentSettingValue>\n```\n\nAlternatively, update your `tmp.agent-settings.json` file.\n\n### Do I need my agent running all the time?\n\nYes, for an agent to stay operational, it must run continuously.\n\n### What should I do if my agent database is corrupted, lost, or deleted?\n\nDo not restart the agent, as this may result in double payments.\nThe current solution is duplicating the database and launching a new agent instance.\nYou should monitor your database closely and, if access is lost, remove the agent from the available list, self-close FAssets, and backup agent keys.\n\n### Is there a minimum history needed in the Data Availability Layer for agents?\n\nNo minimum history is required; it can be set to the latest block.\nYou need to start the [Data Availability Layer](/fdc/overview#data-availability-layer) before you can participate as an FAsset agent.",
    "meta_data": {
      "sidebar_position": 5,
      "slug": "faq",
      "title": "FAssets Agent FAQs",
      "description": "Frequently Asked Questions by FAssets Agents.",
      "tags": [
        "intermediate",
        "fassets",
        "bitcoin",
        "dogecoin"
      ],
      "authors": [
        "fassko"
      ],
      "keywords": [
        "fassets",
        "xrp",
        "btc",
        "doge flare-network",
        "flare-network"
      ]
    },
    "file_name": "files/hub-docs/fassets/guides/5-faq.mdx",
    "type": "answer"
  },
  {
    "content": "Command line reference for managing and interacting with FAssets agent bots.\n\nSourced from `agent-bot.ts` on [GitHub](https://github.com/flare-labs-ltd/fasset-bots/blob/main/packages/fasset-bots-cli/src/cli/agent-bot.ts).\n\nCommand line reference for managing and interacting with FAssets agent bots.\n\nSourced from `agent-bot.ts` on [GitHub](https://github.com/flare-labs-ltd/fasset-bots/blob/main/packages/fasset-bots-cli/src/cli/agent-bot.ts).\n\nCommand line reference for managing and interacting with FAssets agent bots.\n\nSourced from `agent-bot.ts` on [GitHub](https://github.com/flare-labs-ltd/fasset-bots/blob/main/packages/fasset-bots-cli/src/cli/agent-bot.ts).\n\nCommand line reference for managing and interacting with FAssets agent bots.\n\nSourced from `agent-bot.ts` on [GitHub](https://github.com/flare-labs-ltd/fasset-bots/blob/main/packages/fasset-bots-cli/src/cli/agent-bot.ts).\n\nCommand line reference for managing and interacting with FAssets agent bots.\n\nSourced from `agent-bot.ts` on [GitHub](https://github.com/flare-labs-ltd/fasset-bots/blob/main/packages/fasset-bots-cli/src/cli/agent-bot.ts).\n\nCommand line reference for managing and interacting with FAssets agent bots.\n\nSourced from `agent-bot.ts` on [GitHub](https://github.com/flare-labs-ltd/fasset-bots/blob/main/packages/fasset-bots-cli/src/cli/agent-bot.ts).\n\nCommand line reference for managing and interacting with FAssets agent bots.\n\nSourced from `agent-bot.ts` on [GitHub](https://github.com/flare-labs-ltd/fasset-bots/blob/main/packages/fasset-bots-cli/src/cli/agent-bot.ts).\n\nCommand line reference for managing and interacting with FAssets agent bots.\n\nSourced from `agent-bot.ts` on [GitHub](https://github.com/flare-labs-ltd/fasset-bots/blob/main/packages/fasset-bots-cli/src/cli/agent-bot.ts).",
    "file_name": "files/hub-docs/fassets/reference/agent-bot.mdx",
    "meta_data": {
      "title": "Agent Bot CLI Reference",
      "description": "FAssets Agent Bot command line interface reference.",
      "keywords": [
        "fassets",
        "xrp",
        "bitcoin",
        "dogecoin",
        "flare-network"
      ]
    },
    "type": "answer"
  },
  {
    "content": "Command line reference for managing and interacting with FAssets `IAssetManager`.\n\nSourced from `IAssetManager.sol` on [GitHub](https://github.com/flare-labs-ltd/fassets/blob/main/contracts/userInterfaces/IAssetManager.sol).\n\nCommand line reference for managing and interacting with FAssets `IAssetManager`.\n\nSourced from `IAssetManager.sol` on [GitHub](https://github.com/flare-labs-ltd/fassets/blob/main/contracts/userInterfaces/IAssetManager.sol).",
    "file_name": "files/hub-docs/fassets/reference/IAssetManager.mdx",
    "meta_data": {
      "title": "IAssetManager",
      "description": "FAssets IAssetManager interface reference.",
      "keywords": [
        "fassets",
        "xrp",
        "bitcoin",
        "dogecoin",
        "flare-network"
      ]
    },
    "type": "answer"
  },
  {
    "content": "Command line reference for managing and interacting with FAssets user bot. It allows users to mint and redeem FAssets, manage collateral pools, and query system information.\n\nSourced from `user-bot.ts` on [GitHub](https://github.com/flare-labs-ltd/fasset-bots/blob/main/packages/fasset-bots-cli/src/cli/user-bot.ts).\n\nCommand line reference for managing and interacting with FAssets user bot. It allows users to mint and redeem FAssets, manage collateral pools, and query system information.\n\nSourced from `user-bot.ts` on [GitHub](https://github.com/flare-labs-ltd/fasset-bots/blob/main/packages/fasset-bots-cli/src/cli/user-bot.ts).\n\nCommand line reference for managing and interacting with FAssets user bot. It allows users to mint and redeem FAssets, manage collateral pools, and query system information.\n\nSourced from `user-bot.ts` on [GitHub](https://github.com/flare-labs-ltd/fasset-bots/blob/main/packages/fasset-bots-cli/src/cli/user-bot.ts).\n\nCommand line reference for managing and interacting with FAssets user bot. It allows users to mint and redeem FAssets, manage collateral pools, and query system information.\n\nSourced from `user-bot.ts` on [GitHub](https://github.com/flare-labs-ltd/fasset-bots/blob/main/packages/fasset-bots-cli/src/cli/user-bot.ts).\n\nCommand line reference for managing and interacting with FAssets user bot. It allows users to mint and redeem FAssets, manage collateral pools, and query system information.\n\nSourced from `user-bot.ts` on [GitHub](https://github.com/flare-labs-ltd/fasset-bots/blob/main/packages/fasset-bots-cli/src/cli/user-bot.ts).\n\nCommand line reference for managing and interacting with FAssets user bot. It allows users to mint and redeem FAssets, manage collateral pools, and query system information.\n\nSourced from `user-bot.ts` on [GitHub](https://github.com/flare-labs-ltd/fasset-bots/blob/main/packages/fasset-bots-cli/src/cli/user-bot.ts).\n\nCommand line reference for managing and interacting with FAssets user bot. It allows users to mint and redeem FAssets, manage collateral pools, and query system information.\n\nSourced from `user-bot.ts` on [GitHub](https://github.com/flare-labs-ltd/fasset-bots/blob/main/packages/fasset-bots-cli/src/cli/user-bot.ts).\n\nCommand line reference for managing and interacting with FAssets user bot. It allows users to mint and redeem FAssets, manage collateral pools, and query system information.\n\nSourced from `user-bot.ts` on [GitHub](https://github.com/flare-labs-ltd/fasset-bots/blob/main/packages/fasset-bots-cli/src/cli/user-bot.ts).\n\nCommand line reference for managing and interacting with FAssets user bot. It allows users to mint and redeem FAssets, manage collateral pools, and query system information.\n\nSourced from `user-bot.ts` on [GitHub](https://github.com/flare-labs-ltd/fasset-bots/blob/main/packages/fasset-bots-cli/src/cli/user-bot.ts).\n\nCommand line reference for managing and interacting with FAssets user bot. It allows users to mint and redeem FAssets, manage collateral pools, and query system information.\n\nSourced from `user-bot.ts` on [GitHub](https://github.com/flare-labs-ltd/fasset-bots/blob/main/packages/fasset-bots-cli/src/cli/user-bot.ts).",
    "file_name": "files/hub-docs/fassets/reference/user-bot.mdx",
    "meta_data": {
      "title": "User Bot CLI Reference",
      "description": "FAssets User Bot command line interface reference.",
      "keywords": [
        "fassets",
        "xrp",
        "bitcoin",
        "dogecoin",
        "flare-network"
      ]
    },
    "type": "answer"
  },
  {
    "content": "The [`EVMTransaction`](/fdc/attestation-types/evm-transaction) attestation type enables data collection about a transaction on an EVM chain.\nThe currently supported chain are: `ETH`, `FLR`, and `SGB`.\nYou can learn more about it in the official [specification repo](/fdc/attestation-types/evm-transaction).\n\nWe will now demonstrate how the FDC protocol can be used to collect the data of a given Ethereum transaction.\nThe transaction we will be observing has the hash `0x4e636c6590b22d8dcdade7ee3b5ae5572f42edb1878f09b3034b2f7c3362ef3c`; this is an arbitrary transaction that we acquired from the Sepolia Ethereum testnet [explorer](https://sepolia.etherscan.io/).\n\nThe same procedure works for all supported sources, `ETH`, `FLR`, and `SGB`.\nThe source then requires only a slight modification; we will remind you of that when it comes up in the guide.\n\nIn this guide, we will be following the steps outlined in the [FDC Overview](/fdc/overview).\n\nOur implementation requires handling the FDC voting round finalization process.\nTo manage this, we will create separate scripts in `script/fdcExample/EVMTransaction.s.sol` that handle different stages of the validation process:\n\n```solidity title=\"scrip/fdcExample/EVMTransaction.s.sol\"\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport {Script} from \"dependencies/forge-std-1.9.5/src/Script.sol\";\n...\n\nstring constant attestationTypeName = \"EVMTransaction\";\nstring constant dirPath = \"data/\";\n\ncontract PrepareAttestationRequest is Script {\n ...\n}\n\ncontract SubmitAttestationRequest is Script {\n ...\n}\n\ncontract RetrieveDataAndProof is Script {\n ...\n}\n\ncontract Deploy is Script {\n ...\n}\n...\n```\n\nThe names of included contracts mostly mirror the steps described in the [FDC guide](/fdc/overview).\n\nTo bridge the separate executions of the scripts, we will save the relevant data of each script to a file in the `dirPath` folder.\nEach succeeding script will then read that file to load the data.\n\nThe [`EVMTransaction`](/fdc/attestation-types/evm-transaction) attestation type enables data collection about a transaction on an EVM chain.\nThe currently supported chain are: `ETH`, `FLR`, and `SGB`.\nYou can learn more about it in the official [specification repo](/fdc/attestation-types/evm-transaction).\n\nWe will now demonstrate how the FDC protocol can be used to collect the data of a given Ethereum transaction.\nThe transaction we will be observing has the hash `0x4e636c6590b22d8dcdade7ee3b5ae5572f42edb1878f09b3034b2f7c3362ef3c`; this is an arbitrary transaction that we acquired from the Sepolia Ethereum testnet [explorer](https://sepolia.etherscan.io/).\n\nThe same procedure works for all supported sources, `ETH`, `FLR`, and `SGB`.\nThe source then requires only a slight modification; we will remind you of that when it comes up in the guide.\n\nIn this guide, we will be following the steps outlined in the [FDC Overview](/fdc/overview).\n\nOur implementation requires handling the FDC voting round finalization process.\nTo manage this, we will create separate scripts in `script/fdcExample/EVMTransaction.s.sol` that handle different stages of the validation process:\n\n```solidity title=\"scrip/fdcExample/EVMTransaction.s.sol\"\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport {Script} from \"dependencies/forge-std-1.9.5/src/Script.sol\";\n...\n\nstring constant attestationTypeName = \"EVMTransaction\";\nstring constant dirPath = \"data/\";\n\ncontract PrepareAttestationRequest is Script {\n ...\n}\n\ncontract SubmitAttestationRequest is Script {\n ...\n}\n\ncontract RetrieveDataAndProof is Script {\n ...\n}\n\ncontract Deploy is Script {\n ...\n}\n...\n```\n\nThe names of included contracts mostly mirror the steps described in the [FDC guide](/fdc/overview).\n\nTo bridge the separate executions of the scripts, we will save the relevant data of each script to a file in the `dirPath` folder.\nEach succeeding script will then read that file to load the data.",
    "file_name": "files/hub-docs/fdc/guides/evm-transaction.mdx",
    "meta_data": {
      "title": "EVM Transaction",
      "authors": [
        "lukaavbreht",
        "filipkoprivec"
      ],
      "description": "Retrieve the transaction data from Ethereum, Flare, or Songbird.",
      "tags": [
        "intermediate",
        "ethereum",
        "fdc"
      ],
      "keywords": [
        "ethereum",
        "flare-data-connector",
        "evm",
        "flare-network"
      ],
      "sidebar_position": 6,
      "unlisted": false
    },
    "type": "answer"
  },
  {
    "content": "The [`EVMTransaction`](/fdc/attestation-types/evm-transaction) attestation type enables data collection about a transaction on an EVM chain.\nThe currently supported chain are: `ETH`, `FLR`, and `SGB`.\nYou can learn more about it in the official [specification repo](/fdc/attestation-types/evm-transaction).\n\nWe will now demonstrate how the FDC protocol can be used to collect the data of a given Ethereum transaction.\nThe transaction we will be observing has the hash `0x4e636c6590b22d8dcdade7ee3b5ae5572f42edb1878f09b3034b2f7c3362ef3c`; this is an arbitrary transaction that we acquired from the Sepolia Ethereum testnet [explorer](https://sepolia.etherscan.io/).\n\nThe same procedure works for all supported sources, `ETH`, `FLR`, and `SGB`.\nThe source then requires only a slight modification; we will remind you of that when it comes up in the guide.\n\nIn this guide, we will be following the steps outlined in the [FDC Overview](/fdc/overview).\n\nOur implementation requires handling the FDC voting round finalization process.\nTo manage this, we will create separate scripts in `script/fdcExample/EVMTransaction.s.sol` that handle different stages of the validation process:\n\n```solidity title=\"scrip/fdcExample/EVMTransaction.s.sol\"\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport {Script} from \"dependencies/forge-std-1.9.5/src/Script.sol\";\n...\n\nstring constant attestationTypeName = \"EVMTransaction\";\nstring constant dirPath = \"data/\";\n\ncontract PrepareAttestationRequest is Script {\n ...\n}\n\ncontract SubmitAttestationRequest is Script {\n ...\n}\n\ncontract RetrieveDataAndProof is Script {\n ...\n}\n\ncontract Deploy is Script {\n ...\n}\n...\n```\n\nThe names of included contracts mostly mirror the steps described in the [FDC guide](/fdc/overview).\n\nTo bridge the separate executions of the scripts, we will save the relevant data of each script to a file in the `dirPath` folder.\nEach succeeding script will then read that file to load the data.\n\nThe [`EVMTransaction`](/fdc/attestation-types/evm-transaction) attestation type enables data collection about a transaction on an EVM chain.\nThe currently supported chain are: `ETH`, `FLR`, and `SGB`.\nYou can learn more about it in the official [specification repo](/fdc/attestation-types/evm-transaction).\n\nWe will now demonstrate how the FDC protocol can be used to collect the data of a given Ethereum transaction.\nThe transaction we will be observing has the hash `0x4e636c6590b22d8dcdade7ee3b5ae5572f42edb1878f09b3034b2f7c3362ef3c`; this is an arbitrary transaction that we acquired from the Sepolia Ethereum testnet [explorer](https://sepolia.etherscan.io/).\n\nThe same procedure works for all supported sources, `ETH`, `FLR`, and `SGB`.\nThe source then requires only a slight modification; we will remind you of that when it comes up in the guide.\n\nIn this guide, we will be following the steps outlined in the [FDC Overview](/fdc/overview).\n\nOur implementation requires handling the FDC voting round finalization process.\nTo manage this, we will create separate scripts in `script/fdcExample/EVMTransaction.s.sol` that handle different stages of the validation process:\n\n```solidity title=\"scrip/fdcExample/EVMTransaction.s.sol\"\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport {Script} from \"dependencies/forge-std-1.9.5/src/Script.sol\";\n...\n\nstring constant attestationTypeName = \"EVMTransaction\";\nstring constant dirPath = \"data/\";\n\ncontract PrepareAttestationRequest is Script {\n ...\n}\n\ncontract SubmitAttestationRequest is Script {\n ...\n}\n\ncontract RetrieveDataAndProof is Script {\n ...\n}\n\ncontract Deploy is Script {\n ...\n}\n...\n```\n\nThe names of included contracts mostly mirror the steps described in the [FDC guide](/fdc/overview).\n\nTo bridge the separate executions of the scripts, we will save the relevant data of each script to a file in the `dirPath` folder.\nEach succeeding script will then read that file to load the data.",
    "file_name": "files/hub-docs/fdc/guides/evm-transaction.mdx",
    "meta_data": {
      "title": "EVM Transaction",
      "authors": [
        "lukaavbreht",
        "filipkoprivec"
      ],
      "description": "Retrieve the transaction data from Ethereum, Flare, or Songbird.",
      "tags": [
        "intermediate",
        "ethereum",
        "fdc"
      ],
      "keywords": [
        "ethereum",
        "flare-data-connector",
        "evm",
        "flare-network"
      ],
      "sidebar_position": 6,
      "unlisted": false
    },
    "type": "answer"
  },
  {
    "content": "The [`EVMTransaction`](/fdc/attestation-types/evm-transaction) attestation type enables data collection about a transaction on an EVM chain.\nThe currently supported chain are: `ETH`, `FLR`, and `SGB`.\nYou can learn more about it in the official [specification repo](/fdc/attestation-types/evm-transaction).\n\nWe will now demonstrate how the FDC protocol can be used to collect the data of a given Ethereum transaction.\nThe transaction we will be observing has the hash `0x4e636c6590b22d8dcdade7ee3b5ae5572f42edb1878f09b3034b2f7c3362ef3c`; this is an arbitrary transaction that we acquired from the Sepolia Ethereum testnet [explorer](https://sepolia.etherscan.io/).\n\nThe same procedure works for all supported sources, `ETH`, `FLR`, and `SGB`.\nThe source then requires only a slight modification; we will remind you of that when it comes up in the guide.\n\nIn this guide, we will be following the steps outlined in the [FDC Overview](/fdc/overview).\n\nOur implementation requires handling the FDC voting round finalization process.\nTo manage this, we will create separate scripts in `script/fdcExample/EVMTransaction.s.sol` that handle different stages of the validation process:\n\n```solidity title=\"scrip/fdcExample/EVMTransaction.s.sol\"\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport {Script} from \"dependencies/forge-std-1.9.5/src/Script.sol\";\n...\n\nstring constant attestationTypeName = \"EVMTransaction\";\nstring constant dirPath = \"data/\";\n\ncontract PrepareAttestationRequest is Script {\n ...\n}\n\ncontract SubmitAttestationRequest is Script {\n ...\n}\n\ncontract RetrieveDataAndProof is Script {\n ...\n}\n\ncontract Deploy is Script {\n ...\n}\n...\n```\n\nThe names of included contracts mostly mirror the steps described in the [FDC guide](/fdc/overview).\n\nTo bridge the separate executions of the scripts, we will save the relevant data of each script to a file in the `dirPath` folder.\nEach succeeding script will then read that file to load the data.\n\nThe [`EVMTransaction`](/fdc/attestation-types/evm-transaction) attestation type enables data collection about a transaction on an EVM chain.\nThe currently supported chain are: `ETH`, `FLR`, and `SGB`.\nYou can learn more about it in the official [specification repo](/fdc/attestation-types/evm-transaction).\n\nWe will now demonstrate how the FDC protocol can be used to collect the data of a given Ethereum transaction.\nThe transaction we will be observing has the hash `0x4e636c6590b22d8dcdade7ee3b5ae5572f42edb1878f09b3034b2f7c3362ef3c`; this is an arbitrary transaction that we acquired from the Sepolia Ethereum testnet [explorer](https://sepolia.etherscan.io/).\n\nThe same procedure works for all supported sources, `ETH`, `FLR`, and `SGB`.\nThe source then requires only a slight modification; we will remind you of that when it comes up in the guide.\n\nIn this guide, we will be following the steps outlined in the [FDC Overview](/fdc/overview).\n\nOur implementation requires handling the FDC voting round finalization process.\nTo manage this, we will create separate scripts in `script/fdcExample/EVMTransaction.s.sol` that handle different stages of the validation process:\n\n```solidity title=\"scrip/fdcExample/EVMTransaction.s.sol\"\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport {Script} from \"dependencies/forge-std-1.9.5/src/Script.sol\";\n...\n\nstring constant attestationTypeName = \"EVMTransaction\";\nstring constant dirPath = \"data/\";\n\ncontract PrepareAttestationRequest is Script {\n ...\n}\n\ncontract SubmitAttestationRequest is Script {\n ...\n}\n\ncontract RetrieveDataAndProof is Script {\n ...\n}\n\ncontract Deploy is Script {\n ...\n}\n...\n```\n\nThe names of included contracts mostly mirror the steps described in the [FDC guide](/fdc/overview).\n\nTo bridge the separate executions of the scripts, we will save the relevant data of each script to a file in the `dirPath` folder.\nEach succeeding script will then read that file to load the data.",
    "file_name": "files/hub-docs/fdc/guides/evm-transaction.mdx",
    "meta_data": {
      "title": "EVM Transaction",
      "authors": [
        "lukaavbreht",
        "filipkoprivec"
      ],
      "description": "Retrieve the transaction data from Ethereum, Flare, or Songbird.",
      "tags": [
        "intermediate",
        "ethereum",
        "fdc"
      ],
      "keywords": [
        "ethereum",
        "flare-data-connector",
        "evm",
        "flare-network"
      ],
      "sidebar_position": 6,
      "unlisted": false
    },
    "type": "answer"
  },
  {
    "content": "The [`EVMTransaction`](/fdc/attestation-types/evm-transaction) attestation type enables data collection about a transaction on an EVM chain.\nThe currently supported chain are: `ETH`, `FLR`, and `SGB`.\nYou can learn more about it in the official [specification repo](/fdc/attestation-types/evm-transaction).\n\nWe will now demonstrate how the FDC protocol can be used to collect the data of a given Ethereum transaction.\nThe transaction we will be observing has the hash `0x4e636c6590b22d8dcdade7ee3b5ae5572f42edb1878f09b3034b2f7c3362ef3c`; this is an arbitrary transaction that we acquired from the Sepolia Ethereum testnet [explorer](https://sepolia.etherscan.io/).\n\nThe same procedure works for all supported sources, `ETH`, `FLR`, and `SGB`.\nThe source then requires only a slight modification; we will remind you of that when it comes up in the guide.\n\nIn this guide, we will be following the steps outlined in the [FDC Overview](/fdc/overview).\n\nOur implementation requires handling the FDC voting round finalization process.\nTo manage this, we will create separate scripts in `script/fdcExample/EVMTransaction.s.sol` that handle different stages of the validation process:\n\n```solidity title=\"scrip/fdcExample/EVMTransaction.s.sol\"\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport {Script} from \"dependencies/forge-std-1.9.5/src/Script.sol\";\n...\n\nstring constant attestationTypeName = \"EVMTransaction\";\nstring constant dirPath = \"data/\";\n\ncontract PrepareAttestationRequest is Script {\n ...\n}\n\ncontract SubmitAttestationRequest is Script {\n ...\n}\n\ncontract RetrieveDataAndProof is Script {\n ...\n}\n\ncontract Deploy is Script {\n ...\n}\n...\n```\n\nThe names of included contracts mostly mirror the steps described in the [FDC guide](/fdc/overview).\n\nTo bridge the separate executions of the scripts, we will save the relevant data of each script to a file in the `dirPath` folder.\nEach succeeding script will then read that file to load the data.\n\nThe [`EVMTransaction`](/fdc/attestation-types/evm-transaction) attestation type enables data collection about a transaction on an EVM chain.\nThe currently supported chain are: `ETH`, `FLR`, and `SGB`.\nYou can learn more about it in the official [specification repo](/fdc/attestation-types/evm-transaction).\n\nWe will now demonstrate how the FDC protocol can be used to collect the data of a given Ethereum transaction.\nThe transaction we will be observing has the hash `0x4e636c6590b22d8dcdade7ee3b5ae5572f42edb1878f09b3034b2f7c3362ef3c`; this is an arbitrary transaction that we acquired from the Sepolia Ethereum testnet [explorer](https://sepolia.etherscan.io/).\n\nThe same procedure works for all supported sources, `ETH`, `FLR`, and `SGB`.\nThe source then requires only a slight modification; we will remind you of that when it comes up in the guide.\n\nIn this guide, we will be following the steps outlined in the [FDC Overview](/fdc/overview).\n\nOur implementation requires handling the FDC voting round finalization process.\nTo manage this, we will create separate scripts in `script/fdcExample/EVMTransaction.s.sol` that handle different stages of the validation process:\n\n```solidity title=\"scrip/fdcExample/EVMTransaction.s.sol\"\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport {Script} from \"dependencies/forge-std-1.9.5/src/Script.sol\";\n...\n\nstring constant attestationTypeName = \"EVMTransaction\";\nstring constant dirPath = \"data/\";\n\ncontract PrepareAttestationRequest is Script {\n ...\n}\n\ncontract SubmitAttestationRequest is Script {\n ...\n}\n\ncontract RetrieveDataAndProof is Script {\n ...\n}\n\ncontract Deploy is Script {\n ...\n}\n...\n```\n\nThe names of included contracts mostly mirror the steps described in the [FDC guide](/fdc/overview).\n\nTo bridge the separate executions of the scripts, we will save the relevant data of each script to a file in the `dirPath` folder.\nEach succeeding script will then read that file to load the data.",
    "file_name": "files/hub-docs/fdc/guides/evm-transaction.mdx",
    "meta_data": {
      "title": "EVM Transaction",
      "authors": [
        "lukaavbreht",
        "filipkoprivec"
      ],
      "description": "Retrieve the transaction data from Ethereum, Flare, or Songbird.",
      "tags": [
        "intermediate",
        "ethereum",
        "fdc"
      ],
      "keywords": [
        "ethereum",
        "flare-data-connector",
        "evm",
        "flare-network"
      ],
      "sidebar_position": 6,
      "unlisted": false
    },
    "type": "answer"
  },
  {
    "content": "The [`EVMTransaction`](/fdc/attestation-types/evm-transaction) attestation type enables data collection about a transaction on an EVM chain.\nThe currently supported chain are: `ETH`, `FLR`, and `SGB`.\nYou can learn more about it in the official [specification repo](/fdc/attestation-types/evm-transaction).\n\nWe will now demonstrate how the FDC protocol can be used to collect the data of a given Ethereum transaction.\nThe transaction we will be observing has the hash `0x4e636c6590b22d8dcdade7ee3b5ae5572f42edb1878f09b3034b2f7c3362ef3c`; this is an arbitrary transaction that we acquired from the Sepolia Ethereum testnet [explorer](https://sepolia.etherscan.io/).\n\nThe same procedure works for all supported sources, `ETH`, `FLR`, and `SGB`.\nThe source then requires only a slight modification; we will remind you of that when it comes up in the guide.\n\nIn this guide, we will be following the steps outlined in the [FDC Overview](/fdc/overview).\n\nOur implementation requires handling the FDC voting round finalization process.\nTo manage this, we will create separate scripts in `script/fdcExample/EVMTransaction.s.sol` that handle different stages of the validation process:\n\n```solidity title=\"scrip/fdcExample/EVMTransaction.s.sol\"\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport {Script} from \"dependencies/forge-std-1.9.5/src/Script.sol\";\n...\n\nstring constant attestationTypeName = \"EVMTransaction\";\nstring constant dirPath = \"data/\";\n\ncontract PrepareAttestationRequest is Script {\n ...\n}\n\ncontract SubmitAttestationRequest is Script {\n ...\n}\n\ncontract RetrieveDataAndProof is Script {\n ...\n}\n\ncontract Deploy is Script {\n ...\n}\n...\n```\n\nThe names of included contracts mostly mirror the steps described in the [FDC guide](/fdc/overview).\n\nTo bridge the separate executions of the scripts, we will save the relevant data of each script to a file in the `dirPath` folder.\nEach succeeding script will then read that file to load the data.",
    "file_name": "files/hub-docs/fdc/guides/evm-transaction.mdx",
    "meta_data": {
      "title": "EVM Transaction",
      "authors": [
        "lukaavbreht",
        "filipkoprivec"
      ],
      "description": "Retrieve the transaction data from Ethereum, Flare, or Songbird.",
      "tags": [
        "intermediate",
        "ethereum",
        "fdc"
      ],
      "keywords": [
        "ethereum",
        "flare-data-connector",
        "evm",
        "flare-network"
      ],
      "sidebar_position": 6,
      "unlisted": false
    },
    "type": "answer"
  },
  {
    "content": "import Remix from \"@site/src/components/remix\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport ITypeTemplate from \"!!raw-loader!/examples/developer-hub-solidity/ITypeTemplate.sol\";\n\nThis guide is for developers who want to extend FDC by creating a new attestation type. In this guide, you will learn how to:\n\n- Setup a new attestation type definition in Solidity.\n\n- Generate a attestation type verifier server in TypeScript with controllers and services.\n\n- Create an onchain attestation verifier contract in Solidity.\n\nimport Remix from \"@site/src/components/remix\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport ITypeTemplate from \"!!raw-loader!/examples/developer-hub-solidity/ITypeTemplate.sol\";\n\nThis guide is for developers who want to extend FDC by creating a new attestation type. In this guide, you will learn how to:\n\n- Setup a new attestation type definition in Solidity.\n\n- Generate a attestation type verifier server in TypeScript with controllers and services.\n\n- Create an onchain attestation verifier contract in Solidity.\n\nimport Remix from \"@site/src/components/remix\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport ITypeTemplate from \"!!raw-loader!/examples/developer-hub-solidity/ITypeTemplate.sol\";\n\nThis guide is for developers who want to extend FDC by creating a new attestation type. In this guide, you will learn how to:\n\n- Setup a new attestation type definition in Solidity.\n\n- Generate a attestation type verifier server in TypeScript with controllers and services.\n\n- Create an onchain attestation verifier contract in Solidity.\n\nimport Remix from \"@site/src/components/remix\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport ITypeTemplate from \"!!raw-loader!/examples/developer-hub-solidity/ITypeTemplate.sol\";\n\nThis guide is for developers who want to extend FDC by creating a new attestation type. In this guide, you will learn how to:\n\n- Setup a new attestation type definition in Solidity.\n\n- Generate a attestation type verifier server in TypeScript with controllers and services.\n\n- Create an onchain attestation verifier contract in Solidity.\n\nimport Remix from \"@site/src/components/remix\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport ITypeTemplate from \"!!raw-loader!/examples/developer-hub-solidity/ITypeTemplate.sol\";\n\nThis guide is for developers who want to extend FDC by creating a new attestation type. In this guide, you will learn how to:\n\n- Setup a new attestation type definition in Solidity.\n\n- Generate a attestation type verifier server in TypeScript with controllers and services.\n\n- Create an onchain attestation verifier contract in Solidity.",
    "file_name": "files/hub-docs/fdc/guides/create-attestation-type.mdx",
    "meta_data": {
      "title": "Create Attestation Type",
      "authors": [
        "lukaavbreht",
        "dineshpinto"
      ],
      "description": "Learn how to create a new attestation type.",
      "tags": [
        "intermediate",
        "fdc"
      ],
      "keywords": [
        "intermediate",
        "flare-data-connector",
        "flare-network"
      ],
      "sidebar_position": 6,
      "unlisted": true
    },
    "type": "answer"
  },
  {
    "content": "The `JsonApi` attestation type enables data collection from an arbitrary Web2 source.\nYou can learn more about it in the official [specification repo](/fdc/attestation-types/json-api).\n\nWe will now demonstrate how the FDC protocol can be used to collect the data of a given [Star Wars API](https://swapi.dev/) request.\nThe request we will be making is `https://swapi.dev/api/peaople/3/`.\nThe same procedure works for all public APIs.\n\nIn this guide, we will follow the steps outlined in the [FDC overview](/fdc/overview).\n\nOur implementation requires handling the FDC voting round finalization process.\nTo manage this, we will create separate scripts in `script/fdcExample/JsonApi.s.sol` that handle different stages of the validation process:\n\n```solidity title=\"script/fdcExample/JsonApi.s.sol\"\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport {Script} from \"dependencies/forge-std-1.9.5/src/Script.sol\";\n...\n\nstring constant attestationTypeName = \"JsonApi\";\nstring constant dirPath = \"data/\";\n\ncontract PrepareAttestationRequest is Script {\n ...\n}\n\ncontract SubmitAttestationRequest is Script {\n ...\n}\n\ncontract RetrieveDataAndProof is Script {\n ...\n}\n\ncontract Deploy is Script {\n ...\n}\n...\n```\n\nThe names of included contracts mostly mirror the steps described in the [FDC guide](/fdc/overview).\n\nTo bridge the separate executions of the scripts, we will save the relevant data of each script to a file in the `dirPath` folder.\nEach succeeding script will then read that file to load the data.\n\nThe `JsonApi` attestation type enables data collection from an arbitrary Web2 source.\nYou can learn more about it in the official [specification repo](/fdc/attestation-types/json-api).\n\nWe will now demonstrate how the FDC protocol can be used to collect the data of a given [Star Wars API](https://swapi.dev/) request.\nThe request we will be making is `https://swapi.dev/api/peaople/3/`.\nThe same procedure works for all public APIs.\n\nIn this guide, we will follow the steps outlined in the [FDC overview](/fdc/overview).\n\nOur implementation requires handling the FDC voting round finalization process.\nTo manage this, we will create separate scripts in `script/fdcExample/JsonApi.s.sol` that handle different stages of the validation process:\n\n```solidity title=\"script/fdcExample/JsonApi.s.sol\"\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport {Script} from \"dependencies/forge-std-1.9.5/src/Script.sol\";\n...\n\nstring constant attestationTypeName = \"JsonApi\";\nstring constant dirPath = \"data/\";\n\ncontract PrepareAttestationRequest is Script {\n ...\n}\n\ncontract SubmitAttestationRequest is Script {\n ...\n}\n\ncontract RetrieveDataAndProof is Script {\n ...\n}\n\ncontract Deploy is Script {\n ...\n}\n...\n```\n\nThe names of included contracts mostly mirror the steps described in the [FDC guide](/fdc/overview).\n\nTo bridge the separate executions of the scripts, we will save the relevant data of each script to a file in the `dirPath` folder.\nEach succeeding script will then read that file to load the data.\n\nThe `JsonApi` attestation type enables data collection from an arbitrary Web2 source.\nYou can learn more about it in the official [specification repo](/fdc/attestation-types/json-api).\n\nWe will now demonstrate how the FDC protocol can be used to collect the data of a given [Star Wars API](https://swapi.dev/) request.\nThe request we will be making is `https://swapi.dev/api/peaople/3/`.\nThe same procedure works for all public APIs.\n\nIn this guide, we will follow the steps outlined in the [FDC overview](/fdc/overview).\n\nOur implementation requires handling the FDC voting round finalization process.\nTo manage this, we will create separate scripts in `script/fdcExample/JsonApi.s.sol` that handle different stages of the validation process:\n\n```solidity title=\"script/fdcExample/JsonApi.s.sol\"\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport {Script} from \"dependencies/forge-std-1.9.5/src/Script.sol\";\n...\n\nstring constant attestationTypeName = \"JsonApi\";\nstring constant dirPath = \"data/\";\n\ncontract PrepareAttestationRequest is Script {\n ...\n}\n\ncontract SubmitAttestationRequest is Script {\n ...\n}\n\ncontract RetrieveDataAndProof is Script {\n ...\n}\n\ncontract Deploy is Script {\n ...\n}\n...\n```\n\nThe names of included contracts mostly mirror the steps described in the [FDC guide](/fdc/overview).\n\nTo bridge the separate executions of the scripts, we will save the relevant data of each script to a file in the `dirPath` folder.\nEach succeeding script will then read that file to load the data.",
    "file_name": "files/hub-docs/fdc/guides/json-api.mdx",
    "meta_data": {
      "title": "Json Api",
      "authors": [
        "lukaavbreht",
        "filipkoprivec"
      ],
      "description": "Retrieve arbitrary Web2 data.",
      "tags": [
        "intermediate",
        "ethereum",
        "fdc"
      ],
      "keywords": [
        "ethereum",
        "flare-data-connector",
        "evm",
        "flare-network"
      ],
      "sidebar_position": 8,
      "unlisted": false
    },
    "type": "answer"
  },
  {
    "content": "The `JsonApi` attestation type enables data collection from an arbitrary Web2 source.\nYou can learn more about it in the official [specification repo](/fdc/attestation-types/json-api).\n\nWe will now demonstrate how the FDC protocol can be used to collect the data of a given [Star Wars API](https://swapi.dev/) request.\nThe request we will be making is `https://swapi.dev/api/peaople/3/`.\nThe same procedure works for all public APIs.\n\nIn this guide, we will follow the steps outlined in the [FDC overview](/fdc/overview).\n\nOur implementation requires handling the FDC voting round finalization process.\nTo manage this, we will create separate scripts in `script/fdcExample/JsonApi.s.sol` that handle different stages of the validation process:\n\n```solidity title=\"script/fdcExample/JsonApi.s.sol\"\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport {Script} from \"dependencies/forge-std-1.9.5/src/Script.sol\";\n...\n\nstring constant attestationTypeName = \"JsonApi\";\nstring constant dirPath = \"data/\";\n\ncontract PrepareAttestationRequest is Script {\n ...\n}\n\ncontract SubmitAttestationRequest is Script {\n ...\n}\n\ncontract RetrieveDataAndProof is Script {\n ...\n}\n\ncontract Deploy is Script {\n ...\n}\n...\n```\n\nThe names of included contracts mostly mirror the steps described in the [FDC guide](/fdc/overview).\n\nTo bridge the separate executions of the scripts, we will save the relevant data of each script to a file in the `dirPath` folder.\nEach succeeding script will then read that file to load the data.\n\nThe `JsonApi` attestation type enables data collection from an arbitrary Web2 source.\nYou can learn more about it in the official [specification repo](/fdc/attestation-types/json-api).\n\nWe will now demonstrate how the FDC protocol can be used to collect the data of a given [Star Wars API](https://swapi.dev/) request.\nThe request we will be making is `https://swapi.dev/api/peaople/3/`.\nThe same procedure works for all public APIs.\n\nIn this guide, we will follow the steps outlined in the [FDC overview](/fdc/overview).\n\nOur implementation requires handling the FDC voting round finalization process.\nTo manage this, we will create separate scripts in `script/fdcExample/JsonApi.s.sol` that handle different stages of the validation process:\n\n```solidity title=\"script/fdcExample/JsonApi.s.sol\"\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport {Script} from \"dependencies/forge-std-1.9.5/src/Script.sol\";\n...\n\nstring constant attestationTypeName = \"JsonApi\";\nstring constant dirPath = \"data/\";\n\ncontract PrepareAttestationRequest is Script {\n ...\n}\n\ncontract SubmitAttestationRequest is Script {\n ...\n}\n\ncontract RetrieveDataAndProof is Script {\n ...\n}\n\ncontract Deploy is Script {\n ...\n}\n...\n```\n\nThe names of included contracts mostly mirror the steps described in the [FDC guide](/fdc/overview).\n\nTo bridge the separate executions of the scripts, we will save the relevant data of each script to a file in the `dirPath` folder.\nEach succeeding script will then read that file to load the data.\n\nThe `JsonApi` attestation type enables data collection from an arbitrary Web2 source.\nYou can learn more about it in the official [specification repo](/fdc/attestation-types/json-api).\n\nWe will now demonstrate how the FDC protocol can be used to collect the data of a given [Star Wars API](https://swapi.dev/) request.\nThe request we will be making is `https://swapi.dev/api/peaople/3/`.\nThe same procedure works for all public APIs.\n\nIn this guide, we will follow the steps outlined in the [FDC overview](/fdc/overview).\n\nOur implementation requires handling the FDC voting round finalization process.\nTo manage this, we will create separate scripts in `script/fdcExample/JsonApi.s.sol` that handle different stages of the validation process:\n\n```solidity title=\"script/fdcExample/JsonApi.s.sol\"\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport {Script} from \"dependencies/forge-std-1.9.5/src/Script.sol\";\n...\n\nstring constant attestationTypeName = \"JsonApi\";\nstring constant dirPath = \"data/\";\n\ncontract PrepareAttestationRequest is Script {\n ...\n}\n\ncontract SubmitAttestationRequest is Script {\n ...\n}\n\ncontract RetrieveDataAndProof is Script {\n ...\n}\n\ncontract Deploy is Script {\n ...\n}\n...\n```\n\nThe names of included contracts mostly mirror the steps described in the [FDC guide](/fdc/overview).\n\nTo bridge the separate executions of the scripts, we will save the relevant data of each script to a file in the `dirPath` folder.\nEach succeeding script will then read that file to load the data.",
    "file_name": "files/hub-docs/fdc/guides/json-api.mdx",
    "meta_data": {
      "title": "Json Api",
      "authors": [
        "lukaavbreht",
        "filipkoprivec"
      ],
      "description": "Retrieve arbitrary Web2 data.",
      "tags": [
        "intermediate",
        "ethereum",
        "fdc"
      ],
      "keywords": [
        "ethereum",
        "flare-data-connector",
        "evm",
        "flare-network"
      ],
      "sidebar_position": 8,
      "unlisted": false
    },
    "type": "answer"
  },
  {
    "content": "The `JsonApi` attestation type enables data collection from an arbitrary Web2 source.\nYou can learn more about it in the official [specification repo](/fdc/attestation-types/json-api).\n\nWe will now demonstrate how the FDC protocol can be used to collect the data of a given [Star Wars API](https://swapi.dev/) request.\nThe request we will be making is `https://swapi.dev/api/peaople/3/`.\nThe same procedure works for all public APIs.\n\nIn this guide, we will follow the steps outlined in the [FDC overview](/fdc/overview).\n\nOur implementation requires handling the FDC voting round finalization process.\nTo manage this, we will create separate scripts in `script/fdcExample/JsonApi.s.sol` that handle different stages of the validation process:\n\n```solidity title=\"script/fdcExample/JsonApi.s.sol\"\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport {Script} from \"dependencies/forge-std-1.9.5/src/Script.sol\";\n...\n\nstring constant attestationTypeName = \"JsonApi\";\nstring constant dirPath = \"data/\";\n\ncontract PrepareAttestationRequest is Script {\n ...\n}\n\ncontract SubmitAttestationRequest is Script {\n ...\n}\n\ncontract RetrieveDataAndProof is Script {\n ...\n}\n\ncontract Deploy is Script {\n ...\n}\n...\n```\n\nThe names of included contracts mostly mirror the steps described in the [FDC guide](/fdc/overview).\n\nTo bridge the separate executions of the scripts, we will save the relevant data of each script to a file in the `dirPath` folder.\nEach succeeding script will then read that file to load the data.\n\nThe `JsonApi` attestation type enables data collection from an arbitrary Web2 source.\nYou can learn more about it in the official [specification repo](/fdc/attestation-types/json-api).\n\nWe will now demonstrate how the FDC protocol can be used to collect the data of a given [Star Wars API](https://swapi.dev/) request.\nThe request we will be making is `https://swapi.dev/api/peaople/3/`.\nThe same procedure works for all public APIs.\n\nIn this guide, we will follow the steps outlined in the [FDC overview](/fdc/overview).\n\nOur implementation requires handling the FDC voting round finalization process.\nTo manage this, we will create separate scripts in `script/fdcExample/JsonApi.s.sol` that handle different stages of the validation process:\n\n```solidity title=\"script/fdcExample/JsonApi.s.sol\"\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport {Script} from \"dependencies/forge-std-1.9.5/src/Script.sol\";\n...\n\nstring constant attestationTypeName = \"JsonApi\";\nstring constant dirPath = \"data/\";\n\ncontract PrepareAttestationRequest is Script {\n ...\n}\n\ncontract SubmitAttestationRequest is Script {\n ...\n}\n\ncontract RetrieveDataAndProof is Script {\n ...\n}\n\ncontract Deploy is Script {\n ...\n}\n...\n```\n\nThe names of included contracts mostly mirror the steps described in the [FDC guide](/fdc/overview).\n\nTo bridge the separate executions of the scripts, we will save the relevant data of each script to a file in the `dirPath` folder.\nEach succeeding script will then read that file to load the data.\n\nThe `JsonApi` attestation type enables data collection from an arbitrary Web2 source.\nYou can learn more about it in the official [specification repo](/fdc/attestation-types/json-api).\n\nWe will now demonstrate how the FDC protocol can be used to collect the data of a given [Star Wars API](https://swapi.dev/) request.\nThe request we will be making is `https://swapi.dev/api/peaople/3/`.\nThe same procedure works for all public APIs.\n\nIn this guide, we will follow the steps outlined in the [FDC overview](/fdc/overview).\n\nOur implementation requires handling the FDC voting round finalization process.\nTo manage this, we will create separate scripts in `script/fdcExample/JsonApi.s.sol` that handle different stages of the validation process:\n\n```solidity title=\"script/fdcExample/JsonApi.s.sol\"\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport {Script} from \"dependencies/forge-std-1.9.5/src/Script.sol\";\n...\n\nstring constant attestationTypeName = \"JsonApi\";\nstring constant dirPath = \"data/\";\n\ncontract PrepareAttestationRequest is Script {\n ...\n}\n\ncontract SubmitAttestationRequest is Script {\n ...\n}\n\ncontract RetrieveDataAndProof is Script {\n ...\n}\n\ncontract Deploy is Script {\n ...\n}\n...\n```\n\nThe names of included contracts mostly mirror the steps described in the [FDC guide](/fdc/overview).\n\nTo bridge the separate executions of the scripts, we will save the relevant data of each script to a file in the `dirPath` folder.\nEach succeeding script will then read that file to load the data.",
    "file_name": "files/hub-docs/fdc/guides/json-api.mdx",
    "meta_data": {
      "title": "Json Api",
      "authors": [
        "lukaavbreht",
        "filipkoprivec"
      ],
      "description": "Retrieve arbitrary Web2 data.",
      "tags": [
        "intermediate",
        "ethereum",
        "fdc"
      ],
      "keywords": [
        "ethereum",
        "flare-data-connector",
        "evm",
        "flare-network"
      ],
      "sidebar_position": 8,
      "unlisted": false
    },
    "type": "answer"
  },
  {
    "content": "In [Part 1](/fdc/getting-started) and [Part 2](/fdc/attestation-types) of the series, you you have learned how the Data Connector works and what kind of different attestations you can get from it. In this guide, you will:\n\n- Move from the world of UTXO chains to the world of EVM chains with a new `EVMTransaction` attestation type.\n- Understand the implications of connecting account-based chains, and the additional possibilities that smart contracts bring.\n- Connect Ethereum and Flare (or testnets Sepolia and Flare Testnet Coston2 for the Coston testnet).\n\nFrom Parts 1 and 2, the attestations that you know so far are:\n\n- Simple payment\n\n- Non-existence of a payment with reference\n\n- Balance decreasing transaction\n\n- Block height confirmation\n\n- Address validity check\n\nYou also know that the Data Connector allows Flare to connect to Bitcoin, Dogecoin, and XRP Ledger.\n\nThe information that the Data Connector provides is similar to what was provided before (sender and recipient, amount, block, timestamp, etc.), but since you are on a smart contract compatible chain now, you can also get additional things, namely, you can extract the full data about events that were emitted during the transaction, and you can also get the input data of the transaction (in case a contract was called).\n\nIn [Part 1](/fdc/getting-started) and [Part 2](/fdc/attestation-types) of the series, you you have learned how the Data Connector works and what kind of different attestations you can get from it. In this guide, you will:\n\n- Move from the world of UTXO chains to the world of EVM chains with a new `EVMTransaction` attestation type.\n- Understand the implications of connecting account-based chains, and the additional possibilities that smart contracts bring.\n- Connect Ethereum and Flare (or testnets Sepolia and Flare Testnet Coston2 for the Coston testnet).\n\nFrom Parts 1 and 2, the attestations that you know so far are:\n\n- Simple payment\n\n- Non-existence of a payment with reference\n\n- Balance decreasing transaction\n\n- Block height confirmation\n\n- Address validity check\n\nYou also know that the Data Connector allows Flare to connect to Bitcoin, Dogecoin, and XRP Ledger.\n\nThe information that the Data Connector provides is similar to what was provided before (sender and recipient, amount, block, timestamp, etc.), but since you are on a smart contract compatible chain now, you can also get additional things, namely, you can extract the full data about events that were emitted during the transaction, and you can also get the input data of the transaction (in case a contract was called).\n\nIn [Part 1](/fdc/getting-started) and [Part 2](/fdc/attestation-types) of the series, you you have learned how the Data Connector works and what kind of different attestations you can get from it. In this guide, you will:\n\n- Move from the world of UTXO chains to the world of EVM chains with a new `EVMTransaction` attestation type.\n- Understand the implications of connecting account-based chains, and the additional possibilities that smart contracts bring.\n- Connect Ethereum and Flare (or testnets Sepolia and Flare Testnet Coston2 for the Coston testnet).\n\nFrom Parts 1 and 2, the attestations that you know so far are:\n\n- Simple payment\n\n- Non-existence of a payment with reference\n\n- Balance decreasing transaction\n\n- Block height confirmation\n\n- Address validity check\n\nYou also know that the Data Connector allows Flare to connect to Bitcoin, Dogecoin, and XRP Ledger.\n\nThe information that the Data Connector provides is similar to what was provided before (sender and recipient, amount, block, timestamp, etc.), but since you are on a smart contract compatible chain now, you can also get additional things, namely, you can extract the full data about events that were emitted during the transaction, and you can also get the input data of the transaction (in case a contract was called).",
    "file_name": "files/hub-docs/fdc/guides/evm-connectivity.mdx",
    "meta_data": {
      "title": "EVM Connectivity",
      "slug": "evm-connectivity",
      "authors": [
        "lukaavbreht",
        "filipkoprivec"
      ],
      "description": "Learn how to connect EVM chains to Flare using FDC.",
      "tags": [
        "intermediate",
        "ethereum",
        "fdc"
      ],
      "keywords": [
        "ethereum",
        "flare-data-connector",
        "evm",
        "flare-network"
      ],
      "sidebar_position": 8,
      "unlisted": true
    },
    "type": "answer"
  },
  {
    "content": "In [Part 1](/fdc/getting-started) and [Part 2](/fdc/attestation-types) of the series, you you have learned how the Data Connector works and what kind of different attestations you can get from it. In this guide, you will:\n\n- Move from the world of UTXO chains to the world of EVM chains with a new `EVMTransaction` attestation type.\n- Understand the implications of connecting account-based chains, and the additional possibilities that smart contracts bring.\n- Connect Ethereum and Flare (or testnets Sepolia and Flare Testnet Coston2 for the Coston testnet).\n\nFrom Parts 1 and 2, the attestations that you know so far are:\n\n- Simple payment\n\n- Non-existence of a payment with reference\n\n- Balance decreasing transaction\n\n- Block height confirmation\n\n- Address validity check\n\nYou also know that the Data Connector allows Flare to connect to Bitcoin, Dogecoin, and XRP Ledger.\n\nThe information that the Data Connector provides is similar to what was provided before (sender and recipient, amount, block, timestamp, etc.), but since you are on a smart contract compatible chain now, you can also get additional things, namely, you can extract the full data about events that were emitted during the transaction, and you can also get the input data of the transaction (in case a contract was called).\n\nIn [Part 1](/fdc/getting-started) and [Part 2](/fdc/attestation-types) of the series, you you have learned how the Data Connector works and what kind of different attestations you can get from it. In this guide, you will:\n\n- Move from the world of UTXO chains to the world of EVM chains with a new `EVMTransaction` attestation type.\n- Understand the implications of connecting account-based chains, and the additional possibilities that smart contracts bring.\n- Connect Ethereum and Flare (or testnets Sepolia and Flare Testnet Coston2 for the Coston testnet).\n\nFrom Parts 1 and 2, the attestations that you know so far are:\n\n- Simple payment\n\n- Non-existence of a payment with reference\n\n- Balance decreasing transaction\n\n- Block height confirmation\n\n- Address validity check\n\nYou also know that the Data Connector allows Flare to connect to Bitcoin, Dogecoin, and XRP Ledger.\n\nThe information that the Data Connector provides is similar to what was provided before (sender and recipient, amount, block, timestamp, etc.), but since you are on a smart contract compatible chain now, you can also get additional things, namely, you can extract the full data about events that were emitted during the transaction, and you can also get the input data of the transaction (in case a contract was called).",
    "file_name": "files/hub-docs/fdc/guides/evm-connectivity.mdx",
    "meta_data": {
      "title": "EVM Connectivity",
      "slug": "evm-connectivity",
      "authors": [
        "lukaavbreht",
        "filipkoprivec"
      ],
      "description": "Learn how to connect EVM chains to Flare using FDC.",
      "tags": [
        "intermediate",
        "ethereum",
        "fdc"
      ],
      "keywords": [
        "ethereum",
        "flare-data-connector",
        "evm",
        "flare-network"
      ],
      "sidebar_position": 8,
      "unlisted": true
    },
    "type": "answer"
  },
  {
    "content": "This guide is for developers who want to connect to EVM chains. In this guide, you will learn how to:\n\n- Use the `EVMTransaction` attestation type.\n\n- Understand the implications of connecting account-based chains.\n\n- Relay transaction information from Ethereum Sepolia to Flare Testnet Coston2.\n\nThis guide is for developers who want to connect to EVM chains. In this guide, you will learn how to:\n\n- Use the `EVMTransaction` attestation type.\n\n- Understand the implications of connecting account-based chains.\n\n- Relay transaction information from Ethereum Sepolia to Flare Testnet Coston2.",
    "file_name": "files/hub-docs/fdc/guides/connect-evm-chains.mdx",
    "meta_data": {
      "title": "Connect to EVM Chains",
      "authors": [
        "lukaavbreht",
        "filipkoprivec"
      ],
      "description": "Relay transaction and event data from Ethereum.",
      "tags": [
        "intermediate",
        "ethereum",
        "fdc"
      ],
      "keywords": [
        "ethereum",
        "flare-data-connector",
        "evm",
        "flare-network"
      ],
      "sidebar_position": 5,
      "unlisted": true
    },
    "type": "answer"
  },
  {
    "content": "The [AddressValidity](/fdc/attestation-types/address-validity) attestation type validates whether a string represents a valid address on supported blockchain networks (`BTC`, `DOGE`, and `XRP`).\nThis validation ensures addresses meet chain-specific formatting and checksum requirements before they're used in transactions or smart contracts.\nThe full specification is available on the official [specification repo](/fdc/attestation-types/address-validity).\n\nThe primary contract interface for this attestation type is [`IAddressValidity`](/fdc/reference/IFdcHub). Let's walk through validating a Bitcoin testnet address using the FDC protocol.\nWe will use the address `mg9P9f4wr9w7c1sgFeiTC5oMLYXCc2c7hs` as an example throughout this guide.\nYou can swap this with any valid testnet address from the supported chains.\nYou can follow this tutorial with any other valid address - just make sure it is a valid testnet address.\n\nThis validation process works identically for `BTC`, `DOGE`, and `XRP` addresses, with only minor chain-specific parameter adjustments which we'll highlight throughout the guide.\n\nIn this guide, we will follow the steps outlined in the [FDC overview](/fdc/overview).\n\nOur implementation requires handling the FDC voting round finalization process.\nTo manage this, we will create separate scripts in `script/fdcExample/AddressValidity.s.sol` that handle different stages of the validation process:\n\n```solidity title=\"scrip/fdcExample/AddressValidity.s.sol\"\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport {Script} from \"dependencies/forge-std-1.9.5/src/Script.sol\";\n...\n\n// Configuration constants\nstring constant attestationTypeName = \"AddressValidity\";\nstring constant dirPath = \"data/\";\n\ncontract PrepareAttestationRequest is Script {\n ...\n}\n\ncontract SubmitAttestationRequest is Script {\n ...\n}\n\ncontract RetrieveDataAndProof is Script {\n ...\n}\n\ncontract Deploy is Script {\n ...\n}\n...\n```\n\nThe names of included contracts mostly mirror the steps described in the [FDC overview](/fdc/overview).\n\nTo bridge the separate script executions, we will save the relevant data of each script to a file in the `dirPath` folder.\nEach succeeding script will then read that file to load the data.\n\nThe [AddressValidity](/fdc/attestation-types/address-validity) attestation type validates whether a string represents a valid address on supported blockchain networks (`BTC`, `DOGE`, and `XRP`).\nThis validation ensures addresses meet chain-specific formatting and checksum requirements before they're used in transactions or smart contracts.\nThe full specification is available on the official [specification repo](/fdc/attestation-types/address-validity).\n\nThe primary contract interface for this attestation type is [`IAddressValidity`](/fdc/reference/IFdcHub). Let's walk through validating a Bitcoin testnet address using the FDC protocol.\nWe will use the address `mg9P9f4wr9w7c1sgFeiTC5oMLYXCc2c7hs` as an example throughout this guide.\nYou can swap this with any valid testnet address from the supported chains.\nYou can follow this tutorial with any other valid address - just make sure it is a valid testnet address.\n\nThis validation process works identically for `BTC`, `DOGE`, and `XRP` addresses, with only minor chain-specific parameter adjustments which we'll highlight throughout the guide.\n\nIn this guide, we will follow the steps outlined in the [FDC overview](/fdc/overview).\n\nOur implementation requires handling the FDC voting round finalization process.\nTo manage this, we will create separate scripts in `script/fdcExample/AddressValidity.s.sol` that handle different stages of the validation process:\n\n```solidity title=\"scrip/fdcExample/AddressValidity.s.sol\"\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport {Script} from \"dependencies/forge-std-1.9.5/src/Script.sol\";\n...\n\n// Configuration constants\nstring constant attestationTypeName = \"AddressValidity\";\nstring constant dirPath = \"data/\";\n\ncontract PrepareAttestationRequest is Script {\n ...\n}\n\ncontract SubmitAttestationRequest is Script {\n ...\n}\n\ncontract RetrieveDataAndProof is Script {\n ...\n}\n\ncontract Deploy is Script {\n ...\n}\n...\n```\n\nThe names of included contracts mostly mirror the steps described in the [FDC overview](/fdc/overview).\n\nTo bridge the separate script executions, we will save the relevant data of each script to a file in the `dirPath` folder.\nEach succeeding script will then read that file to load the data.",
    "file_name": "files/hub-docs/fdc/guides/check-address-validity.mdx",
    "meta_data": {
      "title": "Check Address Validity",
      "authors": [
        "lukaavbreht",
        "filipkoprivec"
      ],
      "description": "Check the validity of a Bitcoin, Dogecoin, or XRPL address.",
      "tags": [
        "intermediate",
        "ethereum",
        "fdc"
      ],
      "keywords": [
        "ethereum",
        "flare-data-connector",
        "evm",
        "flare-network"
      ],
      "sidebar_position": 3,
      "unlisted": false
    },
    "type": "answer"
  },
  {
    "content": "The [AddressValidity](/fdc/attestation-types/address-validity) attestation type validates whether a string represents a valid address on supported blockchain networks (`BTC`, `DOGE`, and `XRP`).\nThis validation ensures addresses meet chain-specific formatting and checksum requirements before they're used in transactions or smart contracts.\nThe full specification is available on the official [specification repo](/fdc/attestation-types/address-validity).\n\nThe primary contract interface for this attestation type is [`IAddressValidity`](/fdc/reference/IFdcHub). Let's walk through validating a Bitcoin testnet address using the FDC protocol.\nWe will use the address `mg9P9f4wr9w7c1sgFeiTC5oMLYXCc2c7hs` as an example throughout this guide.\nYou can swap this with any valid testnet address from the supported chains.\nYou can follow this tutorial with any other valid address - just make sure it is a valid testnet address.\n\nThis validation process works identically for `BTC`, `DOGE`, and `XRP` addresses, with only minor chain-specific parameter adjustments which we'll highlight throughout the guide.\n\nIn this guide, we will follow the steps outlined in the [FDC overview](/fdc/overview).\n\nOur implementation requires handling the FDC voting round finalization process.\nTo manage this, we will create separate scripts in `script/fdcExample/AddressValidity.s.sol` that handle different stages of the validation process:\n\n```solidity title=\"scrip/fdcExample/AddressValidity.s.sol\"\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport {Script} from \"dependencies/forge-std-1.9.5/src/Script.sol\";\n...\n\n// Configuration constants\nstring constant attestationTypeName = \"AddressValidity\";\nstring constant dirPath = \"data/\";\n\ncontract PrepareAttestationRequest is Script {\n ...\n}\n\ncontract SubmitAttestationRequest is Script {\n ...\n}\n\ncontract RetrieveDataAndProof is Script {\n ...\n}\n\ncontract Deploy is Script {\n ...\n}\n...\n```\n\nThe names of included contracts mostly mirror the steps described in the [FDC overview](/fdc/overview).\n\nTo bridge the separate script executions, we will save the relevant data of each script to a file in the `dirPath` folder.\nEach succeeding script will then read that file to load the data.\n\nThe [AddressValidity](/fdc/attestation-types/address-validity) attestation type validates whether a string represents a valid address on supported blockchain networks (`BTC`, `DOGE`, and `XRP`).\nThis validation ensures addresses meet chain-specific formatting and checksum requirements before they're used in transactions or smart contracts.\nThe full specification is available on the official [specification repo](/fdc/attestation-types/address-validity).\n\nThe primary contract interface for this attestation type is [`IAddressValidity`](/fdc/reference/IFdcHub). Let's walk through validating a Bitcoin testnet address using the FDC protocol.\nWe will use the address `mg9P9f4wr9w7c1sgFeiTC5oMLYXCc2c7hs` as an example throughout this guide.\nYou can swap this with any valid testnet address from the supported chains.\nYou can follow this tutorial with any other valid address - just make sure it is a valid testnet address.\n\nThis validation process works identically for `BTC`, `DOGE`, and `XRP` addresses, with only minor chain-specific parameter adjustments which we'll highlight throughout the guide.\n\nIn this guide, we will follow the steps outlined in the [FDC overview](/fdc/overview).\n\nOur implementation requires handling the FDC voting round finalization process.\nTo manage this, we will create separate scripts in `script/fdcExample/AddressValidity.s.sol` that handle different stages of the validation process:\n\n```solidity title=\"scrip/fdcExample/AddressValidity.s.sol\"\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport {Script} from \"dependencies/forge-std-1.9.5/src/Script.sol\";\n...\n\n// Configuration constants\nstring constant attestationTypeName = \"AddressValidity\";\nstring constant dirPath = \"data/\";\n\ncontract PrepareAttestationRequest is Script {\n ...\n}\n\ncontract SubmitAttestationRequest is Script {\n ...\n}\n\ncontract RetrieveDataAndProof is Script {\n ...\n}\n\ncontract Deploy is Script {\n ...\n}\n...\n```\n\nThe names of included contracts mostly mirror the steps described in the [FDC overview](/fdc/overview).\n\nTo bridge the separate script executions, we will save the relevant data of each script to a file in the `dirPath` folder.\nEach succeeding script will then read that file to load the data.",
    "file_name": "files/hub-docs/fdc/guides/check-address-validity.mdx",
    "meta_data": {
      "title": "Check Address Validity",
      "authors": [
        "lukaavbreht",
        "filipkoprivec"
      ],
      "description": "Check the validity of a Bitcoin, Dogecoin, or XRPL address.",
      "tags": [
        "intermediate",
        "ethereum",
        "fdc"
      ],
      "keywords": [
        "ethereum",
        "flare-data-connector",
        "evm",
        "flare-network"
      ],
      "sidebar_position": 3,
      "unlisted": false
    },
    "type": "answer"
  },
  {
    "content": "The [AddressValidity](/fdc/attestation-types/address-validity) attestation type validates whether a string represents a valid address on supported blockchain networks (`BTC`, `DOGE`, and `XRP`).\nThis validation ensures addresses meet chain-specific formatting and checksum requirements before they're used in transactions or smart contracts.\nThe full specification is available on the official [specification repo](/fdc/attestation-types/address-validity).\n\nThe primary contract interface for this attestation type is [`IAddressValidity`](/fdc/reference/IFdcHub). Let's walk through validating a Bitcoin testnet address using the FDC protocol.\nWe will use the address `mg9P9f4wr9w7c1sgFeiTC5oMLYXCc2c7hs` as an example throughout this guide.\nYou can swap this with any valid testnet address from the supported chains.\nYou can follow this tutorial with any other valid address - just make sure it is a valid testnet address.\n\nThis validation process works identically for `BTC`, `DOGE`, and `XRP` addresses, with only minor chain-specific parameter adjustments which we'll highlight throughout the guide.\n\nIn this guide, we will follow the steps outlined in the [FDC overview](/fdc/overview).\n\nOur implementation requires handling the FDC voting round finalization process.\nTo manage this, we will create separate scripts in `script/fdcExample/AddressValidity.s.sol` that handle different stages of the validation process:\n\n```solidity title=\"scrip/fdcExample/AddressValidity.s.sol\"\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport {Script} from \"dependencies/forge-std-1.9.5/src/Script.sol\";\n...\n\n// Configuration constants\nstring constant attestationTypeName = \"AddressValidity\";\nstring constant dirPath = \"data/\";\n\ncontract PrepareAttestationRequest is Script {\n ...\n}\n\ncontract SubmitAttestationRequest is Script {\n ...\n}\n\ncontract RetrieveDataAndProof is Script {\n ...\n}\n\ncontract Deploy is Script {\n ...\n}\n...\n```\n\nThe names of included contracts mostly mirror the steps described in the [FDC overview](/fdc/overview).\n\nTo bridge the separate script executions, we will save the relevant data of each script to a file in the `dirPath` folder.\nEach succeeding script will then read that file to load the data.\n\nThe [AddressValidity](/fdc/attestation-types/address-validity) attestation type validates whether a string represents a valid address on supported blockchain networks (`BTC`, `DOGE`, and `XRP`).\nThis validation ensures addresses meet chain-specific formatting and checksum requirements before they're used in transactions or smart contracts.\nThe full specification is available on the official [specification repo](/fdc/attestation-types/address-validity).\n\nThe primary contract interface for this attestation type is [`IAddressValidity`](/fdc/reference/IFdcHub). Let's walk through validating a Bitcoin testnet address using the FDC protocol.\nWe will use the address `mg9P9f4wr9w7c1sgFeiTC5oMLYXCc2c7hs` as an example throughout this guide.\nYou can swap this with any valid testnet address from the supported chains.\nYou can follow this tutorial with any other valid address - just make sure it is a valid testnet address.\n\nThis validation process works identically for `BTC`, `DOGE`, and `XRP` addresses, with only minor chain-specific parameter adjustments which we'll highlight throughout the guide.\n\nIn this guide, we will follow the steps outlined in the [FDC overview](/fdc/overview).\n\nOur implementation requires handling the FDC voting round finalization process.\nTo manage this, we will create separate scripts in `script/fdcExample/AddressValidity.s.sol` that handle different stages of the validation process:\n\n```solidity title=\"scrip/fdcExample/AddressValidity.s.sol\"\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport {Script} from \"dependencies/forge-std-1.9.5/src/Script.sol\";\n...\n\n// Configuration constants\nstring constant attestationTypeName = \"AddressValidity\";\nstring constant dirPath = \"data/\";\n\ncontract PrepareAttestationRequest is Script {\n ...\n}\n\ncontract SubmitAttestationRequest is Script {\n ...\n}\n\ncontract RetrieveDataAndProof is Script {\n ...\n}\n\ncontract Deploy is Script {\n ...\n}\n...\n```\n\nThe names of included contracts mostly mirror the steps described in the [FDC overview](/fdc/overview).\n\nTo bridge the separate script executions, we will save the relevant data of each script to a file in the `dirPath` folder.\nEach succeeding script will then read that file to load the data.",
    "file_name": "files/hub-docs/fdc/guides/check-address-validity.mdx",
    "meta_data": {
      "title": "Check Address Validity",
      "authors": [
        "lukaavbreht",
        "filipkoprivec"
      ],
      "description": "Check the validity of a Bitcoin, Dogecoin, or XRPL address.",
      "tags": [
        "intermediate",
        "ethereum",
        "fdc"
      ],
      "keywords": [
        "ethereum",
        "flare-data-connector",
        "evm",
        "flare-network"
      ],
      "sidebar_position": 3,
      "unlisted": false
    },
    "type": "answer"
  },
  {
    "content": "The [AddressValidity](/fdc/attestation-types/address-validity) attestation type validates whether a string represents a valid address on supported blockchain networks (`BTC`, `DOGE`, and `XRP`).\nThis validation ensures addresses meet chain-specific formatting and checksum requirements before they're used in transactions or smart contracts.\nThe full specification is available on the official [specification repo](/fdc/attestation-types/address-validity).\n\nThe primary contract interface for this attestation type is [`IAddressValidity`](/fdc/reference/IFdcHub). Let's walk through validating a Bitcoin testnet address using the FDC protocol.\nWe will use the address `mg9P9f4wr9w7c1sgFeiTC5oMLYXCc2c7hs` as an example throughout this guide.\nYou can swap this with any valid testnet address from the supported chains.\nYou can follow this tutorial with any other valid address - just make sure it is a valid testnet address.\n\nThis validation process works identically for `BTC`, `DOGE`, and `XRP` addresses, with only minor chain-specific parameter adjustments which we'll highlight throughout the guide.\n\nIn this guide, we will follow the steps outlined in the [FDC overview](/fdc/overview).\n\nOur implementation requires handling the FDC voting round finalization process.\nTo manage this, we will create separate scripts in `script/fdcExample/AddressValidity.s.sol` that handle different stages of the validation process:\n\n```solidity title=\"scrip/fdcExample/AddressValidity.s.sol\"\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport {Script} from \"dependencies/forge-std-1.9.5/src/Script.sol\";\n...\n\n// Configuration constants\nstring constant attestationTypeName = \"AddressValidity\";\nstring constant dirPath = \"data/\";\n\ncontract PrepareAttestationRequest is Script {\n ...\n}\n\ncontract SubmitAttestationRequest is Script {\n ...\n}\n\ncontract RetrieveDataAndProof is Script {\n ...\n}\n\ncontract Deploy is Script {\n ...\n}\n...\n```\n\nThe names of included contracts mostly mirror the steps described in the [FDC overview](/fdc/overview).\n\nTo bridge the separate script executions, we will save the relevant data of each script to a file in the `dirPath` folder.\nEach succeeding script will then read that file to load the data.\n\nThe [AddressValidity](/fdc/attestation-types/address-validity) attestation type validates whether a string represents a valid address on supported blockchain networks (`BTC`, `DOGE`, and `XRP`).\nThis validation ensures addresses meet chain-specific formatting and checksum requirements before they're used in transactions or smart contracts.\nThe full specification is available on the official [specification repo](/fdc/attestation-types/address-validity).\n\nThe primary contract interface for this attestation type is [`IAddressValidity`](/fdc/reference/IFdcHub). Let's walk through validating a Bitcoin testnet address using the FDC protocol.\nWe will use the address `mg9P9f4wr9w7c1sgFeiTC5oMLYXCc2c7hs` as an example throughout this guide.\nYou can swap this with any valid testnet address from the supported chains.\nYou can follow this tutorial with any other valid address - just make sure it is a valid testnet address.\n\nThis validation process works identically for `BTC`, `DOGE`, and `XRP` addresses, with only minor chain-specific parameter adjustments which we'll highlight throughout the guide.\n\nIn this guide, we will follow the steps outlined in the [FDC overview](/fdc/overview).\n\nOur implementation requires handling the FDC voting round finalization process.\nTo manage this, we will create separate scripts in `script/fdcExample/AddressValidity.s.sol` that handle different stages of the validation process:\n\n```solidity title=\"scrip/fdcExample/AddressValidity.s.sol\"\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport {Script} from \"dependencies/forge-std-1.9.5/src/Script.sol\";\n...\n\n// Configuration constants\nstring constant attestationTypeName = \"AddressValidity\";\nstring constant dirPath = \"data/\";\n\ncontract PrepareAttestationRequest is Script {\n ...\n}\n\ncontract SubmitAttestationRequest is Script {\n ...\n}\n\ncontract RetrieveDataAndProof is Script {\n ...\n}\n\ncontract Deploy is Script {\n ...\n}\n...\n```\n\nThe names of included contracts mostly mirror the steps described in the [FDC overview](/fdc/overview).\n\nTo bridge the separate script executions, we will save the relevant data of each script to a file in the `dirPath` folder.\nEach succeeding script will then read that file to load the data.",
    "file_name": "files/hub-docs/fdc/guides/check-address-validity.mdx",
    "meta_data": {
      "title": "Check Address Validity",
      "authors": [
        "lukaavbreht",
        "filipkoprivec"
      ],
      "description": "Check the validity of a Bitcoin, Dogecoin, or XRPL address.",
      "tags": [
        "intermediate",
        "ethereum",
        "fdc"
      ],
      "keywords": [
        "ethereum",
        "flare-data-connector",
        "evm",
        "flare-network"
      ],
      "sidebar_position": 3,
      "unlisted": false
    },
    "type": "answer"
  },
  {
    "content": "The [AddressValidity](/fdc/attestation-types/address-validity) attestation type validates whether a string represents a valid address on supported blockchain networks (`BTC`, `DOGE`, and `XRP`).\nThis validation ensures addresses meet chain-specific formatting and checksum requirements before they're used in transactions or smart contracts.\nThe full specification is available on the official [specification repo](/fdc/attestation-types/address-validity).\n\nThe primary contract interface for this attestation type is [`IAddressValidity`](/fdc/reference/IFdcHub). Let's walk through validating a Bitcoin testnet address using the FDC protocol.\nWe will use the address `mg9P9f4wr9w7c1sgFeiTC5oMLYXCc2c7hs` as an example throughout this guide.\nYou can swap this with any valid testnet address from the supported chains.\nYou can follow this tutorial with any other valid address - just make sure it is a valid testnet address.\n\nThis validation process works identically for `BTC`, `DOGE`, and `XRP` addresses, with only minor chain-specific parameter adjustments which we'll highlight throughout the guide.\n\nIn this guide, we will follow the steps outlined in the [FDC overview](/fdc/overview).\n\nOur implementation requires handling the FDC voting round finalization process.\nTo manage this, we will create separate scripts in `script/fdcExample/AddressValidity.s.sol` that handle different stages of the validation process:\n\n```solidity title=\"scrip/fdcExample/AddressValidity.s.sol\"\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport {Script} from \"dependencies/forge-std-1.9.5/src/Script.sol\";\n...\n\n// Configuration constants\nstring constant attestationTypeName = \"AddressValidity\";\nstring constant dirPath = \"data/\";\n\ncontract PrepareAttestationRequest is Script {\n ...\n}\n\ncontract SubmitAttestationRequest is Script {\n ...\n}\n\ncontract RetrieveDataAndProof is Script {\n ...\n}\n\ncontract Deploy is Script {\n ...\n}\n...\n```\n\nThe names of included contracts mostly mirror the steps described in the [FDC overview](/fdc/overview).\n\nTo bridge the separate script executions, we will save the relevant data of each script to a file in the `dirPath` folder.\nEach succeeding script will then read that file to load the data.",
    "file_name": "files/hub-docs/fdc/guides/check-address-validity.mdx",
    "meta_data": {
      "title": "Check Address Validity",
      "authors": [
        "lukaavbreht",
        "filipkoprivec"
      ],
      "description": "Check the validity of a Bitcoin, Dogecoin, or XRPL address.",
      "tags": [
        "intermediate",
        "ethereum",
        "fdc"
      ],
      "keywords": [
        "ethereum",
        "flare-data-connector",
        "evm",
        "flare-network"
      ],
      "sidebar_position": 3,
      "unlisted": false
    },
    "type": "answer"
  },
  {
    "content": "The `Payment` attestation type enables data collection about a transaction, classified as payment on the native chain.\nThe currently supported chain are: `BTC`, `DOGE`, and `XRP`.\nYou can learn more about it in the official [specification repo](/fdc/attestation-types/payment).\n\nWe will now demonstrate how the FDC protocol can be used to collect the data of a given XRLP payment transaction.\nThe transaction we will be observing has the id `2A3E7C7F6077B4D12207A9F063515EACE70FBBF3C55514CD8BD659D4AB721447`; this is an arbitrary transaction that we acquired from the XRPL testnet [explorer](https://testnet.xrpl.org/).\n\nThe same procedure works for all supported sources, `BTC`, `DOGE`, and `XRP`.\nThe source then requires only a slight modification; we will remind you of that when it comes up in the guide.\n\nIn this guide, we will follow the steps outlined in the [FDC overview](/fdc/overview).\n\nOur implementation requires handling the FDC voting round finalization process.\nTo manage this, we will create separate scripts in `script/fdcExample/Payment.s.sol` that handle different stages of the validation process:\n\n```solidity title=\"scrip/fdcExample/Payment.s.sol\"\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport {Script} from \"dependencies/forge-std-1.9.5/src/Script.sol\";\n...\n\nstring constant attestationTypeName = \"Payment\";\nstring constant dirPath = \"data/\";\n\ncontract PrepareAttestationRequest is Script {\n ...\n}\n\ncontract SubmitAttestationRequest is Script {\n ...\n}\n\ncontract RetrieveDataAndProof is Script {\n ...\n}\n\ncontract Deploy is Script {\n ...\n}\n...\n```\n\nThe names of included contracts mostly mirror the steps described in the [FDC guide](/fdc/overview).\n\nTo bridge the separate executions of the scripts, we will save the relevant data of each script to a file in the `dirPath` folder.\nEach succeeding script will then read that file to load the data.\n\nThe `Payment` attestation type enables data collection about a transaction, classified as payment on the native chain.\nThe currently supported chain are: `BTC`, `DOGE`, and `XRP`.\nYou can learn more about it in the official [specification repo](/fdc/attestation-types/payment).\n\nWe will now demonstrate how the FDC protocol can be used to collect the data of a given XRLP payment transaction.\nThe transaction we will be observing has the id `2A3E7C7F6077B4D12207A9F063515EACE70FBBF3C55514CD8BD659D4AB721447`; this is an arbitrary transaction that we acquired from the XRPL testnet [explorer](https://testnet.xrpl.org/).\n\nThe same procedure works for all supported sources, `BTC`, `DOGE`, and `XRP`.\nThe source then requires only a slight modification; we will remind you of that when it comes up in the guide.\n\nIn this guide, we will follow the steps outlined in the [FDC overview](/fdc/overview).\n\nOur implementation requires handling the FDC voting round finalization process.\nTo manage this, we will create separate scripts in `script/fdcExample/Payment.s.sol` that handle different stages of the validation process:\n\n```solidity title=\"scrip/fdcExample/Payment.s.sol\"\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport {Script} from \"dependencies/forge-std-1.9.5/src/Script.sol\";\n...\n\nstring constant attestationTypeName = \"Payment\";\nstring constant dirPath = \"data/\";\n\ncontract PrepareAttestationRequest is Script {\n ...\n}\n\ncontract SubmitAttestationRequest is Script {\n ...\n}\n\ncontract RetrieveDataAndProof is Script {\n ...\n}\n\ncontract Deploy is Script {\n ...\n}\n...\n```\n\nThe names of included contracts mostly mirror the steps described in the [FDC guide](/fdc/overview).\n\nTo bridge the separate executions of the scripts, we will save the relevant data of each script to a file in the `dirPath` folder.\nEach succeeding script will then read that file to load the data.",
    "file_name": "files/hub-docs/fdc/guides/payment.mdx",
    "meta_data": {
      "title": "Payment",
      "authors": [
        "lukaavbreht",
        "filipkoprivec"
      ],
      "description": "Retrieve a Payment transaction data from Bitcoin, Dogecoin, or XRPL.",
      "tags": [
        "intermediate",
        "ethereum",
        "fdc"
      ],
      "keywords": [
        "ethereum",
        "flare-data-connector",
        "evm",
        "flare-network"
      ],
      "sidebar_position": 8,
      "unlisted": false
    },
    "type": "answer"
  },
  {
    "content": "The `Payment` attestation type enables data collection about a transaction, classified as payment on the native chain.\nThe currently supported chain are: `BTC`, `DOGE`, and `XRP`.\nYou can learn more about it in the official [specification repo](/fdc/attestation-types/payment).\n\nWe will now demonstrate how the FDC protocol can be used to collect the data of a given XRLP payment transaction.\nThe transaction we will be observing has the id `2A3E7C7F6077B4D12207A9F063515EACE70FBBF3C55514CD8BD659D4AB721447`; this is an arbitrary transaction that we acquired from the XRPL testnet [explorer](https://testnet.xrpl.org/).\n\nThe same procedure works for all supported sources, `BTC`, `DOGE`, and `XRP`.\nThe source then requires only a slight modification; we will remind you of that when it comes up in the guide.\n\nIn this guide, we will follow the steps outlined in the [FDC overview](/fdc/overview).\n\nOur implementation requires handling the FDC voting round finalization process.\nTo manage this, we will create separate scripts in `script/fdcExample/Payment.s.sol` that handle different stages of the validation process:\n\n```solidity title=\"scrip/fdcExample/Payment.s.sol\"\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport {Script} from \"dependencies/forge-std-1.9.5/src/Script.sol\";\n...\n\nstring constant attestationTypeName = \"Payment\";\nstring constant dirPath = \"data/\";\n\ncontract PrepareAttestationRequest is Script {\n ...\n}\n\ncontract SubmitAttestationRequest is Script {\n ...\n}\n\ncontract RetrieveDataAndProof is Script {\n ...\n}\n\ncontract Deploy is Script {\n ...\n}\n...\n```\n\nThe names of included contracts mostly mirror the steps described in the [FDC guide](/fdc/overview).\n\nTo bridge the separate executions of the scripts, we will save the relevant data of each script to a file in the `dirPath` folder.\nEach succeeding script will then read that file to load the data.\n\nThe `Payment` attestation type enables data collection about a transaction, classified as payment on the native chain.\nThe currently supported chain are: `BTC`, `DOGE`, and `XRP`.\nYou can learn more about it in the official [specification repo](/fdc/attestation-types/payment).\n\nWe will now demonstrate how the FDC protocol can be used to collect the data of a given XRLP payment transaction.\nThe transaction we will be observing has the id `2A3E7C7F6077B4D12207A9F063515EACE70FBBF3C55514CD8BD659D4AB721447`; this is an arbitrary transaction that we acquired from the XRPL testnet [explorer](https://testnet.xrpl.org/).\n\nThe same procedure works for all supported sources, `BTC`, `DOGE`, and `XRP`.\nThe source then requires only a slight modification; we will remind you of that when it comes up in the guide.\n\nIn this guide, we will follow the steps outlined in the [FDC overview](/fdc/overview).\n\nOur implementation requires handling the FDC voting round finalization process.\nTo manage this, we will create separate scripts in `script/fdcExample/Payment.s.sol` that handle different stages of the validation process:\n\n```solidity title=\"scrip/fdcExample/Payment.s.sol\"\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport {Script} from \"dependencies/forge-std-1.9.5/src/Script.sol\";\n...\n\nstring constant attestationTypeName = \"Payment\";\nstring constant dirPath = \"data/\";\n\ncontract PrepareAttestationRequest is Script {\n ...\n}\n\ncontract SubmitAttestationRequest is Script {\n ...\n}\n\ncontract RetrieveDataAndProof is Script {\n ...\n}\n\ncontract Deploy is Script {\n ...\n}\n...\n```\n\nThe names of included contracts mostly mirror the steps described in the [FDC guide](/fdc/overview).\n\nTo bridge the separate executions of the scripts, we will save the relevant data of each script to a file in the `dirPath` folder.\nEach succeeding script will then read that file to load the data.",
    "file_name": "files/hub-docs/fdc/guides/payment.mdx",
    "meta_data": {
      "title": "Payment",
      "authors": [
        "lukaavbreht",
        "filipkoprivec"
      ],
      "description": "Retrieve a Payment transaction data from Bitcoin, Dogecoin, or XRPL.",
      "tags": [
        "intermediate",
        "ethereum",
        "fdc"
      ],
      "keywords": [
        "ethereum",
        "flare-data-connector",
        "evm",
        "flare-network"
      ],
      "sidebar_position": 8,
      "unlisted": false
    },
    "type": "answer"
  },
  {
    "content": "The `Payment` attestation type enables data collection about a transaction, classified as payment on the native chain.\nThe currently supported chain are: `BTC`, `DOGE`, and `XRP`.\nYou can learn more about it in the official [specification repo](/fdc/attestation-types/payment).\n\nWe will now demonstrate how the FDC protocol can be used to collect the data of a given XRLP payment transaction.\nThe transaction we will be observing has the id `2A3E7C7F6077B4D12207A9F063515EACE70FBBF3C55514CD8BD659D4AB721447`; this is an arbitrary transaction that we acquired from the XRPL testnet [explorer](https://testnet.xrpl.org/).\n\nThe same procedure works for all supported sources, `BTC`, `DOGE`, and `XRP`.\nThe source then requires only a slight modification; we will remind you of that when it comes up in the guide.\n\nIn this guide, we will follow the steps outlined in the [FDC overview](/fdc/overview).\n\nOur implementation requires handling the FDC voting round finalization process.\nTo manage this, we will create separate scripts in `script/fdcExample/Payment.s.sol` that handle different stages of the validation process:\n\n```solidity title=\"scrip/fdcExample/Payment.s.sol\"\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport {Script} from \"dependencies/forge-std-1.9.5/src/Script.sol\";\n...\n\nstring constant attestationTypeName = \"Payment\";\nstring constant dirPath = \"data/\";\n\ncontract PrepareAttestationRequest is Script {\n ...\n}\n\ncontract SubmitAttestationRequest is Script {\n ...\n}\n\ncontract RetrieveDataAndProof is Script {\n ...\n}\n\ncontract Deploy is Script {\n ...\n}\n...\n```\n\nThe names of included contracts mostly mirror the steps described in the [FDC guide](/fdc/overview).\n\nTo bridge the separate executions of the scripts, we will save the relevant data of each script to a file in the `dirPath` folder.\nEach succeeding script will then read that file to load the data.\n\nThe `Payment` attestation type enables data collection about a transaction, classified as payment on the native chain.\nThe currently supported chain are: `BTC`, `DOGE`, and `XRP`.\nYou can learn more about it in the official [specification repo](/fdc/attestation-types/payment).\n\nWe will now demonstrate how the FDC protocol can be used to collect the data of a given XRLP payment transaction.\nThe transaction we will be observing has the id `2A3E7C7F6077B4D12207A9F063515EACE70FBBF3C55514CD8BD659D4AB721447`; this is an arbitrary transaction that we acquired from the XRPL testnet [explorer](https://testnet.xrpl.org/).\n\nThe same procedure works for all supported sources, `BTC`, `DOGE`, and `XRP`.\nThe source then requires only a slight modification; we will remind you of that when it comes up in the guide.\n\nIn this guide, we will follow the steps outlined in the [FDC overview](/fdc/overview).\n\nOur implementation requires handling the FDC voting round finalization process.\nTo manage this, we will create separate scripts in `script/fdcExample/Payment.s.sol` that handle different stages of the validation process:\n\n```solidity title=\"scrip/fdcExample/Payment.s.sol\"\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport {Script} from \"dependencies/forge-std-1.9.5/src/Script.sol\";\n...\n\nstring constant attestationTypeName = \"Payment\";\nstring constant dirPath = \"data/\";\n\ncontract PrepareAttestationRequest is Script {\n ...\n}\n\ncontract SubmitAttestationRequest is Script {\n ...\n}\n\ncontract RetrieveDataAndProof is Script {\n ...\n}\n\ncontract Deploy is Script {\n ...\n}\n...\n```\n\nThe names of included contracts mostly mirror the steps described in the [FDC guide](/fdc/overview).\n\nTo bridge the separate executions of the scripts, we will save the relevant data of each script to a file in the `dirPath` folder.\nEach succeeding script will then read that file to load the data.",
    "file_name": "files/hub-docs/fdc/guides/payment.mdx",
    "meta_data": {
      "title": "Payment",
      "authors": [
        "lukaavbreht",
        "filipkoprivec"
      ],
      "description": "Retrieve a Payment transaction data from Bitcoin, Dogecoin, or XRPL.",
      "tags": [
        "intermediate",
        "ethereum",
        "fdc"
      ],
      "keywords": [
        "ethereum",
        "flare-data-connector",
        "evm",
        "flare-network"
      ],
      "sidebar_position": 8,
      "unlisted": false
    },
    "type": "answer"
  },
  {
    "content": "The `Payment` attestation type enables data collection about a transaction, classified as payment on the native chain.\nThe currently supported chain are: `BTC`, `DOGE`, and `XRP`.\nYou can learn more about it in the official [specification repo](/fdc/attestation-types/payment).\n\nWe will now demonstrate how the FDC protocol can be used to collect the data of a given XRLP payment transaction.\nThe transaction we will be observing has the id `2A3E7C7F6077B4D12207A9F063515EACE70FBBF3C55514CD8BD659D4AB721447`; this is an arbitrary transaction that we acquired from the XRPL testnet [explorer](https://testnet.xrpl.org/).\n\nThe same procedure works for all supported sources, `BTC`, `DOGE`, and `XRP`.\nThe source then requires only a slight modification; we will remind you of that when it comes up in the guide.\n\nIn this guide, we will follow the steps outlined in the [FDC overview](/fdc/overview).\n\nOur implementation requires handling the FDC voting round finalization process.\nTo manage this, we will create separate scripts in `script/fdcExample/Payment.s.sol` that handle different stages of the validation process:\n\n```solidity title=\"scrip/fdcExample/Payment.s.sol\"\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport {Script} from \"dependencies/forge-std-1.9.5/src/Script.sol\";\n...\n\nstring constant attestationTypeName = \"Payment\";\nstring constant dirPath = \"data/\";\n\ncontract PrepareAttestationRequest is Script {\n ...\n}\n\ncontract SubmitAttestationRequest is Script {\n ...\n}\n\ncontract RetrieveDataAndProof is Script {\n ...\n}\n\ncontract Deploy is Script {\n ...\n}\n...\n```\n\nThe names of included contracts mostly mirror the steps described in the [FDC guide](/fdc/overview).\n\nTo bridge the separate executions of the scripts, we will save the relevant data of each script to a file in the `dirPath` folder.\nEach succeeding script will then read that file to load the data.\n\nThe `Payment` attestation type enables data collection about a transaction, classified as payment on the native chain.\nThe currently supported chain are: `BTC`, `DOGE`, and `XRP`.\nYou can learn more about it in the official [specification repo](/fdc/attestation-types/payment).\n\nWe will now demonstrate how the FDC protocol can be used to collect the data of a given XRLP payment transaction.\nThe transaction we will be observing has the id `2A3E7C7F6077B4D12207A9F063515EACE70FBBF3C55514CD8BD659D4AB721447`; this is an arbitrary transaction that we acquired from the XRPL testnet [explorer](https://testnet.xrpl.org/).\n\nThe same procedure works for all supported sources, `BTC`, `DOGE`, and `XRP`.\nThe source then requires only a slight modification; we will remind you of that when it comes up in the guide.\n\nIn this guide, we will follow the steps outlined in the [FDC overview](/fdc/overview).\n\nOur implementation requires handling the FDC voting round finalization process.\nTo manage this, we will create separate scripts in `script/fdcExample/Payment.s.sol` that handle different stages of the validation process:\n\n```solidity title=\"scrip/fdcExample/Payment.s.sol\"\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport {Script} from \"dependencies/forge-std-1.9.5/src/Script.sol\";\n...\n\nstring constant attestationTypeName = \"Payment\";\nstring constant dirPath = \"data/\";\n\ncontract PrepareAttestationRequest is Script {\n ...\n}\n\ncontract SubmitAttestationRequest is Script {\n ...\n}\n\ncontract RetrieveDataAndProof is Script {\n ...\n}\n\ncontract Deploy is Script {\n ...\n}\n...\n```\n\nThe names of included contracts mostly mirror the steps described in the [FDC guide](/fdc/overview).\n\nTo bridge the separate executions of the scripts, we will save the relevant data of each script to a file in the `dirPath` folder.\nEach succeeding script will then read that file to load the data.",
    "file_name": "files/hub-docs/fdc/guides/payment.mdx",
    "meta_data": {
      "title": "Payment",
      "authors": [
        "lukaavbreht",
        "filipkoprivec"
      ],
      "description": "Retrieve a Payment transaction data from Bitcoin, Dogecoin, or XRPL.",
      "tags": [
        "intermediate",
        "ethereum",
        "fdc"
      ],
      "keywords": [
        "ethereum",
        "flare-data-connector",
        "evm",
        "flare-network"
      ],
      "sidebar_position": 8,
      "unlisted": false
    },
    "type": "answer"
  },
  {
    "content": "The `Payment` attestation type enables data collection about a transaction, classified as payment on the native chain.\nThe currently supported chain are: `BTC`, `DOGE`, and `XRP`.\nYou can learn more about it in the official [specification repo](/fdc/attestation-types/payment).\n\nWe will now demonstrate how the FDC protocol can be used to collect the data of a given XRLP payment transaction.\nThe transaction we will be observing has the id `2A3E7C7F6077B4D12207A9F063515EACE70FBBF3C55514CD8BD659D4AB721447`; this is an arbitrary transaction that we acquired from the XRPL testnet [explorer](https://testnet.xrpl.org/).\n\nThe same procedure works for all supported sources, `BTC`, `DOGE`, and `XRP`.\nThe source then requires only a slight modification; we will remind you of that when it comes up in the guide.\n\nIn this guide, we will follow the steps outlined in the [FDC overview](/fdc/overview).\n\nOur implementation requires handling the FDC voting round finalization process.\nTo manage this, we will create separate scripts in `script/fdcExample/Payment.s.sol` that handle different stages of the validation process:\n\n```solidity title=\"scrip/fdcExample/Payment.s.sol\"\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport {Script} from \"dependencies/forge-std-1.9.5/src/Script.sol\";\n...\n\nstring constant attestationTypeName = \"Payment\";\nstring constant dirPath = \"data/\";\n\ncontract PrepareAttestationRequest is Script {\n ...\n}\n\ncontract SubmitAttestationRequest is Script {\n ...\n}\n\ncontract RetrieveDataAndProof is Script {\n ...\n}\n\ncontract Deploy is Script {\n ...\n}\n...\n```\n\nThe names of included contracts mostly mirror the steps described in the [FDC guide](/fdc/overview).\n\nTo bridge the separate executions of the scripts, we will save the relevant data of each script to a file in the `dirPath` folder.\nEach succeeding script will then read that file to load the data.",
    "file_name": "files/hub-docs/fdc/guides/payment.mdx",
    "meta_data": {
      "title": "Payment",
      "authors": [
        "lukaavbreht",
        "filipkoprivec"
      ],
      "description": "Retrieve a Payment transaction data from Bitcoin, Dogecoin, or XRPL.",
      "tags": [
        "intermediate",
        "ethereum",
        "fdc"
      ],
      "keywords": [
        "ethereum",
        "flare-data-connector",
        "evm",
        "flare-network"
      ],
      "sidebar_position": 8,
      "unlisted": false
    },
    "type": "answer"
  },
  {
    "content": "This guide focuses on the [ConfirmedBlockHeightExists](/fdc/attestation-types/confirmed-block-height-exists) attestation type, an efficient way to assert whether a specific `blockNumber` is confirmed with additional data to compute the block production rate within a given time window.\nThe primary contract interface for this attestation type is [`IConfirmedBlockHeightExists`](/fdc/reference/IFdcHub).\n\nThis guide focuses on the [ConfirmedBlockHeightExists](/fdc/attestation-types/confirmed-block-height-exists) attestation type, an efficient way to assert whether a specific `blockNumber` is confirmed with additional data to compute the block production rate within a given time window.\nThe primary contract interface for this attestation type is [`IConfirmedBlockHeightExists`](/fdc/reference/IFdcHub).",
    "file_name": "files/hub-docs/fdc/guides/detect-balance-decrease.mdx",
    "meta_data": {
      "title": "Detect Balance Decrease",
      "authors": [
        "lukaavbreht",
        "filipkoprivec"
      ],
      "description": "Detect a UTXO or XRPL balance decreasing transaction.",
      "tags": [
        "intermediate",
        "ethereum",
        "fdc"
      ],
      "keywords": [
        "ethereum",
        "flare-data-connector",
        "evm",
        "flare-network"
      ],
      "sidebar_position": 7,
      "unlisted": true
    },
    "type": "answer"
  },
  {
    "content": "Sourced from `IReferencedPaymentNonexistence.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/fdc/IReferencedPaymentNonexistence.sol).\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\n\n/**\n * @custom:name IReferencedPaymentNonexistence\n * @custom:id 0x04\n * @custom:supported BTC, DOGE, XRP\n * @author Flare\n * @notice Assertion that an agreed-upon payment has not been made by a certain deadline.\n * A confirmed request shows that a transaction meeting certain criteria (address, amount, reference)\n * did not appear in the specified block range.\n *\n *\n * This type of attestation can be used to e.g. provide grounds to liquidate funds locked by a smart\n * contract on Flare when a payment is missed.\n *\n * @custom:verification If `firstOverflowBlock` cannot be determined or does not have a sufficient\n * number of confirmations, the attestation request is rejected.\n * If `firstOverflowBlockNumber` is higher or equal to `minimalBlockNumber`, the request is rejected.\n * The search range are blocks between heights including `minimalBlockNumber` and excluding `firstOverflowBlockNumber`.\n * If the verifier does not have a view of all blocks from `minimalBlockNumber` to `firstOverflowBlockNumber`,\n * the attestation request is rejected.\n *\n * The request is confirmed if no transaction meeting the specified criteria is found in the search range.\n * The criteria and timestamp are chain specific.\n * ### UTXO (Bitcoin and Dogecoin)\n *\n *\n * Criteria for the transaction:\n *\n *\n * - It is not coinbase transaction.\n * - The transaction has the specified standardPaymentReference.\n * - The sum of values of all outputs with the specified address minus the sum of values of all inputs with\n * the specified address is greater than `amount` (in practice the sum of all values of the inputs with the\n * specified address is zero).\n *\n *\n * Timestamp is `mediantime`.\n * ### XRPL\n *\n *\n *\n * Criteria for the transaction:\n * - The transaction is of type payment.\n * - The transaction has the specified standardPaymentReference,\n * - One of the following is true:\n *   - Transaction status is `SUCCESS` and the amount received by the specified destination address is\n * greater than the specified `value`.\n *   - Transaction status is `RECEIVER_FAILURE` and the specified destination address would receive an\n * amount greater than the specified `value` had the transaction been successful.\n *\n *\n * Timestamp is `close_time` converted to UNIX time.\n *\n * @custom:lut `minimalBlockTimestamp`\n * @custom:lutlimit `0x127500`, `0x127500`, `0x127500`\n */\ninterface IReferencedPaymentNonexistence {\n    /**\n     * @notice Toplevel request\n     * @param attestationType ID of the attestation type.\n     * @param sourceId ID of the data source.\n     * @param messageIntegrityCode `MessageIntegrityCode` that is derived from the expected response as defined.\n     * @param requestBody Data defining the request. Type and interpretation is determined by the `attestationType`.\n     */\n    struct Request {\n        bytes32 attestationType;\n        bytes32 sourceId;\n        bytes32 messageIntegrityCode;\n        RequestBody requestBody;\n    }\n\n    /**\n     * @notice Toplevel response\n     * @param attestationType Extracted from the request.\n     * @param sourceId Extracted from the request.\n     * @param votingRound The ID of the State Connector round in which the request was considered.\n     * @param lowestUsedTimestamp The lowest timestamp used to generate the response.\n     * @param requestBody Extracted from the request.\n     * @param responseBody Data defining the response. The verification rules for the construction of the response\n     * body and the type are defined per specific `attestationType`.\n     */\n    struct Response {\n        bytes32 attestationType;\n        bytes32 sourceId;\n        uint64 votingRound;\n        uint64 lowestUsedTimestamp;\n        RequestBody requestBody;\n        ResponseBody responseBody;\n    }\n\n    /**\n     * @notice Toplevel proof\n     * @param merkleProof Merkle proof corresponding to the attestation response.\n     * @param data Attestation response.\n     */\n    struct Proof {\n        bytes32[] merkleProof;\n        Response data;\n    }\n\n    /**\n     * @notice Request body for ReferencePaymentNonexistence attestation type\n     * @param minimalBlockNumber The start block of the search range.\n     * @param deadlineBlockNumber The blockNumber to be included in the search range.\n     * @param deadlineTimestamp The timestamp to be included in the search range.\n     * @param destinationAddressHash The standard address hash of the address to which the payment had to be done.\n     * @param amount The requested amount in minimal units that had to be paid.\n     * @param standardPaymentReference The requested standard payment reference.\n     * @param checkSourceAddresses If true, the source address root is checked (only full match).\n     * @param sourceAddressesRoot The root of the Merkle tree of the source addresses.\n     * @custom:below The `standardPaymentReference` should not be zero (as a 32-byte sequence).\n     */\n    struct RequestBody {\n        uint64 minimalBlockNumber;\n        uint64 deadlineBlockNumber;\n        uint64 deadlineTimestamp;\n        bytes32 destinationAddressHash;\n        uint256 amount;\n        bytes32 standardPaymentReference;\n        bool checkSourceAddresses;\n        bytes32 sourceAddressesRoot;\n    }\n\n    /**\n     * @notice Response body for ReferencePaymentNonexistence attestation type.\n     * @param minimalBlockTimestamp The timestamp of the minimalBlock.\n     * @param firstOverflowBlockNumber The height of the firstOverflowBlock.\n     * @param firstOverflowBlockTimestamp The timestamp of the firstOverflowBlock.\n     * @custom:below `firstOverflowBlock` is the first block that has block number higher than\n     * `deadlineBlockNumber` and timestamp later than `deadlineTimestamp`.\n     * The specified search range are blocks between heights including `minimalBlockNumber`\n     * and excluding `firstOverflowBlockNumber`.\n     */\n    struct ResponseBody {\n        uint64 minimalBlockTimestamp;\n        uint64 firstOverflowBlockNumber;\n        uint64 firstOverflowBlockTimestamp;\n    }\n}\n```",
    "meta_data": {
      "title": "IReferencedPaymentNonexistence",
      "sidebar_position": 11,
      "description": "Assert whether an agreed-upon payment has not been made."
    },
    "file_name": "files/hub-docs/fdc/reference/IReferencedPaymentNonexistence.mdx",
    "type": "answer"
  },
  {
    "content": "import OpenApiDoc from \"@site/src/components/OpenApiDoc/OpenApiDoc\";\n\n<OpenApiDoc url=\"openapi/data-availability-api.yaml\" />",
    "meta_data": {
      "sidebar_label": "Data Availability API",
      "hide_title": true,
      "description": "OpenAPI specification for Data Availability API.",
      "sidebar_position": 1
    },
    "file_name": "files/hub-docs/fdc/reference/data-availability-api.mdx",
    "type": "answer"
  },
  {
    "content": "Sourced from `IConfirmedBlockHeightExists.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/fdc/IConfirmedBlockHeightExists.sol).\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\n\n/**\n * @custom:name IConfirmedBlockHeightExists\n * @custom:id 0x02\n * @custom:supported BTC, DOGE, XRP\n * @author Flare\n * @notice An assertion that a block with `blockNumber` is confirmed.\n * It also provides data to compute the block production rate in the given time range.\n * @custom:verification It is checked that the block with `blockNumber` is confirmed by at\n * least `numberOfConfirmations`.\n * If it is not, the request is rejected. We note a block on the tip of the chain is confirmed by 1 block.\n * Then `lowestQueryWindowBlock` is determined and its number and timestamp are extracted.\n *\n *\n * Current confirmation heights consensus:\n *\n *\n * | `Chain` | `chainId` | `numberOfConfirmations` | `timestamp ` |\n * | ------- | --------- | ----------------------- | ------------ |\n * | `BTC`   | 0         | 6                       | mediantime   |\n * | `DOGE`  | 2         | 60                      | mediantime   |\n * | `XRP`   | 3         | 3                       | close_time   |\n *\n *\n * @custom:lut `lowestQueryWindowBlockTimestamp`\n * @custom:lutlimit `0x127500`, `0x127500`, `0x127500`\n */\ninterface IConfirmedBlockHeightExists {\n    /**\n     * @notice Toplevel request\n     * @param attestationType ID of the attestation type.\n     * @param sourceId ID of the data source.\n     * @param messageIntegrityCode `MessageIntegrityCode` that is derived from the expected response as defined.\n     * @param requestBody Data defining the request. Type and interpretation is determined by the `attestationType`.\n     */\n    struct Request {\n        bytes32 attestationType;\n        bytes32 sourceId;\n        bytes32 messageIntegrityCode;\n        RequestBody requestBody;\n    }\n\n    /**\n     * @notice Toplevel response\n     * @param attestationType Extracted from the request.\n     * @param sourceId Extracted from the request.\n     * @param votingRound The ID of the State Connector round in which the request was considered.\n     * @param lowestUsedTimestamp The lowest timestamp used to generate the response.\n     * @param requestBody Extracted from the request.\n     * @param responseBody Data defining the response. The verification rules for the construction of the\n     * response body and the type are defined per specific `attestationType`.\n     */\n    struct Response {\n        bytes32 attestationType;\n        bytes32 sourceId;\n        uint64 votingRound;\n        uint64 lowestUsedTimestamp;\n        RequestBody requestBody;\n        ResponseBody responseBody;\n    }\n\n    /**\n     * @notice Toplevel proof\n     * @param merkleProof Merkle proof corresponding to the attestation response.\n     * @param data Attestation response.\n     */\n    struct Proof {\n        bytes32[] merkleProof;\n        Response data;\n    }\n\n    /**\n     * @notice Request body for ConfirmedBlockHeightExistsType attestation type\n     * @param blockNumber The number of the block the request wants a confirmation of.\n     * @param queryWindow The length of the period in which the block production rate is to be computed.\n     */\n    struct RequestBody {\n        uint64 blockNumber;\n        uint64 queryWindow;\n    }\n\n    /**\n     * @notice Response body for ConfirmedBlockHeightExistsType attestation type\n     * @custom:below `blockNumber`, `lowestQueryWindowBlockNumber`, `blockTimestamp`, `lowestQueryWindowBlockTimestamp`\n     * can be used to compute the average block production time in the specified block range.\n     * @param blockTimestamp The timestamp of the block with `blockNumber`.\n     * @param numberOfConfirmations The depth at which a block is considered confirmed depending on the chain.\n     * All attestation providers must agree on this number.\n     * @param lowestQueryWindowBlockNumber The block number of the latest block that has a timestamp strictly smaller\n     * than `blockTimestamp` - `queryWindow`.\n     * @param lowestQueryWindowBlockTimestamp The timestamp of the block at height `lowestQueryWindowBlockNumber`.\n     */\n    struct ResponseBody {\n        uint64 blockTimestamp;\n        uint64 numberOfConfirmations;\n        uint64 lowestQueryWindowBlockNumber;\n        uint64 lowestQueryWindowBlockTimestamp;\n    }\n}\n```",
    "meta_data": {
      "title": "IConfirmedBlockHeightExists",
      "sidebar_position": 8,
      "description": "Assert that a block number is confirmed."
    },
    "file_name": "files/hub-docs/fdc/reference/IConfirmedBlockHeightExists.mdx",
    "type": "answer"
  },
  {
    "content": "Interface for verifying FDC requests.\n\nSourced from `IFdcVerification.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IFdcVerification.sol).\n\nInterface for verifying FDC requests.\n\nSourced from `IFdcVerification.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IFdcVerification.sol).",
    "file_name": "files/hub-docs/fdc/reference/IFdcVerification.md",
    "meta_data": {
      "title": "IFdcVerification",
      "sidebar_position": 3,
      "description": "Interface for verifying FDC requests."
    },
    "type": "answer"
  },
  {
    "content": "Sourced from `IBalanceDecreasingTransaction.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/fdc/IBalanceDecreasingTransaction.sol).\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\n\n/**\n * @custom:name IBalanceDecreasingTransaction\n * @custom:id 0x02\n * @custom:supported BTC, DOGE, XRP\n * @author Flare\n * @notice A detection of a transaction that either decreases the balance for some address or is\n * signed by the source address.\n * Such an attestation could prove a violation of an agreement and therefore provides grounds to liquidate\n * some funds locked by a smart contract on Flare.\n *\n * A transaction is considered \u201cbalance decreasing\u201d for the address, if the balance after the\n * transaction is lower than before or the address is among the signers of the transaction\n * (even if its balance is greater than before the transaction).\n * @custom:verification The transaction with `transactionId` is fetched from the API of the\n * source blockchain node or relevant indexer.\n * If the transaction cannot be fetched or the transaction is in a block that does not have a\n * sufficient number of confirmations, the attestation request is rejected.\n *\n * Once the transaction is received, the response fields are extracted if the transaction is balance\n * decreasing for the indicated address.\n * Some of the request and response fields are chain specific as described below.\n * The fields can be computed with the help of a balance decreasing summary.\n *\n * ### UTXO (Bitcoin and Dogecoin)\n *\n * - `sourceAddressIndicator` is the the index of the transaction input in hex padded to a 0x prefixed 32-byte string.\n * If the indicated input does not exist or the indicated input does not have the address,\n * the attestation request is rejected.\n * The `sourceAddress` is the address of the indicated transaction input.\n * - `spentAmount` is the sum of values of all inputs with sourceAddress minus the sum of\n * all outputs with `sourceAddress`.\n * Can be negative.\n * - `blockTimestamp` is the mediantime of a block.\n *\n * ### XRPL\n *\n * - `sourceAddressIndicator` is the standard address hash of the address whose balance has been decreased.\n * If the address indicated by `sourceAddressIndicator` is not among the signers of the transaction and the balance\n * of the address was not lowered in the transaction, the attestation request is rejected.\n *\n * - `spentAmount` is the difference between the balance of the indicated address after and before the transaction.\n * Can be negative.\n * - `blockTimestamp` is the close_time of a ledger converted to unix time.\n *\n * @custom:lut `blockTimestamp`\n * @custom:lutlimit `0x127500`, `0x127500`, `0x127500`\n */\ninterface IBalanceDecreasingTransaction {\n    /**\n     * @notice Toplevel request\n     * @param attestationType ID of the attestation type.\n     * @param sourceId ID of the data source.\n     * @param messageIntegrityCode `MessageIntegrityCode` that is derived from the expected response.\n     * @param requestBody Data defining the request. Type and interpretation is determined by the `attestationType`.\n     */\n    struct Request {\n        bytes32 attestationType;\n        bytes32 sourceId;\n        bytes32 messageIntegrityCode;\n        RequestBody requestBody;\n    }\n\n    /**\n     * @notice Toplevel response\n     * @param attestationType Extracted from the request.\n     * @param sourceId Extracted from the request.\n     * @param votingRound The ID of the State Connector round in which the request was considered.\n     * This is a security measure to prevent a collision of attestation hashes.\n     * @param lowestUsedTimestamp The lowest timestamp used to generate the response.\n     * @param requestBody Extracted from the request.\n     * @param responseBody Data defining the response. The verification rules for the construction of the\n     * response body and the type are defined per specific `attestationType`.\n     */\n    struct Response {\n        bytes32 attestationType;\n        bytes32 sourceId;\n        uint64 votingRound;\n        uint64 lowestUsedTimestamp;\n        RequestBody requestBody;\n        ResponseBody responseBody;\n    }\n\n    /**\n     * @notice Toplevel proof\n     * @param merkleProof Merkle proof corresponding to the attestation response.\n     * @param data Attestation response.\n     */\n    struct Proof {\n        bytes32[] merkleProof;\n        Response data;\n    }\n\n    /**\n     * @notice Request body for IBalanceDecreasingTransaction attestation type\n     * @param transactionId ID of the payment transaction.\n     * @param sourceAddressIndicator The indicator of the address whose balance has been decreased.\n     */\n    struct RequestBody {\n        bytes32 transactionId;\n        bytes32 sourceAddressIndicator;\n    }\n\n    /**\n     * @notice Response body for IBalanceDecreasingTransaction attestation type.\n     * @param blockNumber The number of the block in which the transaction is included.\n     * @param blockTimestamp The timestamp of the block in which the transaction is included.\n     * @param sourceAddressHash Standard address hash of the address indicated by the `sourceAddressIndicator`.\n     * @param spentAmount Amount spent by the source address in minimal units.\n     * @param standardPaymentReference Standard payment reference of the transaction.\n     */\n    struct ResponseBody {\n        uint64 blockNumber;\n        uint64 blockTimestamp;\n        bytes32 sourceAddressHash;\n        int256 spentAmount;\n        bytes32 standardPaymentReference;\n    }\n}\n```",
    "meta_data": {
      "title": "IBalanceDecreasingTransaction",
      "sidebar_position": 7,
      "description": "Detect a transaction that decreases an address balance."
    },
    "file_name": "files/hub-docs/fdc/reference/IBalanceDecreasingTransaction.mdx",
    "type": "answer"
  },
  {
    "content": "Primary interface for interacting with FDC.\n\nSourced from `IFdcHub.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IFdcHub.sol).\n\nPrimary interface for interacting with FDC.\n\nSourced from `IFdcHub.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IFdcHub.sol).\n\nPrimary interface for interacting with FDC.\n\nSourced from `IFdcHub.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IFdcHub.sol).",
    "file_name": "files/hub-docs/fdc/reference/IFdcHub.md",
    "meta_data": {
      "title": "IFdcHub",
      "sidebar_position": 2,
      "description": "Primary interface for interacting with FDC."
    },
    "type": "answer"
  },
  {
    "content": "Interface for managing FDC request fee configuration.\n\nSourced from `IFdcRequestFeeConfigurations.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IFdcRequestFeeConfigurations.sol).\n\nInterface for managing FDC request fee configuration.\n\nSourced from `IFdcRequestFeeConfigurations.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IFdcRequestFeeConfigurations.sol).\n\nInterface for managing FDC request fee configuration.\n\nSourced from `IFdcRequestFeeConfigurations.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IFdcRequestFeeConfigurations.sol).",
    "file_name": "files/hub-docs/fdc/reference/IFdcRequestFeeConfigurations.md",
    "meta_data": {
      "title": "IFdcRequestFeeConfigurations",
      "sidebar_position": 4,
      "description": "Interface for managing FDC request fee configuration."
    },
    "type": "answer"
  },
  {
    "content": "Interface for managing FDC inflation configuration.\n\nSourced from `IFdcInflationConfigurations.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IFdcInflationConfigurations.sol).\n\nInterface for managing FDC inflation configuration.\n\nSourced from `IFdcInflationConfigurations.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IFdcInflationConfigurations.sol).\n\nInterface for managing FDC inflation configuration.\n\nSourced from `IFdcInflationConfigurations.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IFdcInflationConfigurations.sol).",
    "file_name": "files/hub-docs/fdc/reference/IFdcInflationConfigurations.md",
    "meta_data": {
      "title": "IFdcInflationConfigurations",
      "sidebar_position": 5,
      "description": "Interface for managing FDC inflation configuration."
    },
    "type": "answer"
  },
  {
    "content": "Sourced from `IEVMTransaction.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/fdc/IEVMTransaction.sol).\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\n\n/**\n * @custom:name IEVMTransaction\n * @custom:id 0x06\n * @custom:supported ETH, FLR, SGB\n * @author Flare\n * @notice A relay of a transaction from an EVM chain.\n * This type is only relevant for EVM-compatible chains.\n * @custom:verification If a transaction with the `transactionId` is in a block on the main branch with\n * at least `requiredConfirmations`, the specified data is relayed.\n * If an indicated event does not exist, the request is rejected.\n * @custom:lut `timestamp`\n * @custom:lutlimit `0x41eb00`, `0x41eb00`, `0x41eb00`\n */\ninterface IEVMTransaction {\n    /**\n     * @notice Toplevel request\n     * @param attestationType ID of the attestation type.\n     * @param sourceId ID of the data source.\n     * @param messageIntegrityCode `MessageIntegrityCode` that is derived from the expected response.\n     * @param requestBody Data defining the request. Type (struct) and interpretation is\n     * determined by the `attestationType`.\n     */\n    struct Request {\n        bytes32 attestationType;\n        bytes32 sourceId;\n        bytes32 messageIntegrityCode;\n        RequestBody requestBody;\n    }\n\n    /**\n     * @notice Toplevel response\n     * @param attestationType Extracted from the request.\n     * @param sourceId Extracted from the request.\n     * @param votingRound The ID of the State Connector round in which the request was considered.\n     * @param lowestUsedTimestamp The lowest timestamp used to generate the response.\n     * @param requestBody Extracted from the request.\n     * @param responseBody Data defining the response. The verification rules for the construction\n     * of the response body and the type are defined per specific `attestationType`.\n     */\n    struct Response {\n        bytes32 attestationType;\n        bytes32 sourceId;\n        uint64 votingRound;\n        uint64 lowestUsedTimestamp;\n        RequestBody requestBody;\n        ResponseBody responseBody;\n    }\n\n    /**\n     * @notice Toplevel proof\n     * @param merkleProof Merkle proof corresponding to the attestation response.\n     * @param data Attestation response.\n     */\n    struct Proof {\n        bytes32[] merkleProof;\n        Response data;\n    }\n\n    /**\n     * @notice Request body for EVM transaction attestation type\n     * @custom:below Note that events (logs) are indexed in block not in each transaction.\n     * The contract that uses the attestation should specify the order of event logs as needed and the requestor should\n     * sort `logIndices` with respect to the set specifications.\n     * If possible, the contact should require one `logIndex`.\n     * @param transactionHash Hash of the transaction(transactionHash).\n     * @param requiredConfirmations The height at which a block is considered confirmed by the requestor.\n     * @param provideInput If true, \"input\" field is included in the response.\n     * @param listEvents If true, events indicated by `logIndices` are included in the response.\n     * Otherwise, no events are included in the response.\n     * @param logIndices If `listEvents` is `false`, this should be an empty list, otherwise,\n     * the request is rejected. If `listEvents` is `true`, this is the list of indices (logIndex)\n     * of the events to be relayed (sorted by the requestor). The array should contain at most 50 indices.\n     * If empty, it indicates all events in order capped by 50.\n     */\n    struct RequestBody {\n        bytes32 transactionHash;\n        uint16 requiredConfirmations;\n        bool provideInput;\n        bool listEvents;\n        uint32[] logIndices;\n    }\n\n    /**\n     * @notice Response body for EVM transaction attestation type\n     * @custom:below The fields are in line with transaction provided by EVM node.\n     * @param blockNumber Number of the block in which the transaction is included.\n     * @param timestamp Timestamp of the block in which the transaction is included.\n     * @param sourceAddress The address (from) that signed the transaction.\n     * @param isDeployment Indicate whether it is a contract creation transaction.\n     * @param receivingAddress The address (to) of the receiver of the initial transaction.\n     * Zero address if `isDeployment` is `true`.\n     * @param value The value transferred by the initial transaction in wei.\n     * @param input If `provideInput`, this is the data send along with the initial transaction.\n     * Otherwise it is the default value `0x00`.\n     * @param status Status of the transaction 1 - success, 0 - failure.\n     * @param events If `listEvents` is `true`, an array of the requested events.\n     * Sorted by the logIndex in the same order as `logIndices`. Otherwise, an empty array.\n     */\n    struct ResponseBody {\n        uint64 blockNumber;\n        uint64 timestamp;\n        address sourceAddress;\n        bool isDeployment;\n        address receivingAddress;\n        uint256 value;\n        bytes input;\n        uint8 status;\n        Event[] events;\n    }\n\n    /**\n     * @notice Event log record\n     * @custom:above An `Event` is a struct with the following fields:\n     * @custom:below The fields are in line with EVM event logs.\n     * @param logIndex The consecutive number of the event in block.\n     * @param emitterAddress The address of the contract that emitted the event.\n     * @param topics An array of up to four 32-byte strings of indexed log arguments.\n     * @param data Concatenated 32-byte strings of non-indexed log arguments. At least 32 bytes long.\n     * @param removed It is `true` if the log was removed due to a chain reorganization\n     * and `false` if it is a valid log.\n     */\n    struct Event {\n        uint32 logIndex;\n        address emitterAddress;\n        bytes32[] topics;\n        bytes data;\n        bool removed;\n    }\n}\n```",
    "meta_data": {
      "title": "IEVMTransaction",
      "sidebar_position": 9,
      "description": "Relay a transaction from an EVM chain."
    },
    "file_name": "files/hub-docs/fdc/reference/IEVMTransaction.mdx",
    "type": "answer"
  },
  {
    "content": "Sourced from `IAddressValidity.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/fdc/IAddressValidity.sol).\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\n\n/**\n * @custom:name IAddressValidity\n * @custom:id 0x05\n * @custom:supported BTC, DOGE, XRP\n * @author Flare\n * @notice An assertion whether a string represents a valid address on an external chain.\n * @custom:verification The address is checked against all validity criteria of the chain with `sourceId`.\n * Indicator of validity is provided.\n * If the address is valid, its standard form and standard hash are computed.\n * Validity criteria for each supported chain:\n * - [BTC](/specs/attestations/external-chains/address-validity/BTC.md)\n * - [DOGE](/specs/attestations/external-chains/address-validity/DOGE.md)\n * - [XRPL](/specs/attestations/external-chains/address-validity/XRPL.md)\n * @custom:lut `0xffffffffffffffff` ($2^{64}-1$ in hex)\n * @custom:lutlimit `0xffffffffffffffff`, `0xffffffffffffffff`, `0xffffffffffffffff`\n */\ninterface IAddressValidity {\n    /**\n     * @notice Toplevel request\n     * @param attestationType ID of the attestation type.\n     * @param sourceId Id of the data source.\n     * @param messageIntegrityCode `MessageIntegrityCode` that is derived from the expected response.\n     * @param requestBody Data defining the request. Type and interpretation is determined by the `attestationType`.\n     */\n    struct Request {\n        bytes32 attestationType;\n        bytes32 sourceId;\n        bytes32 messageIntegrityCode;\n        RequestBody requestBody;\n    }\n\n    /**\n     * @notice Toplevel response\n     * @param attestationType Extracted from the request.\n     * @param sourceId Extracted from the request.\n     * @param votingRound The ID of the State Connector round in which the request was considered.\n     * @param lowestUsedTimestamp The lowest timestamp used to generate the response.\n     * @param requestBody Extracted from the request.\n     * @param responseBody Data defining the response. The verification rules for the construction of the\n     * response body and the type are defined per specific `attestationType`.\n     */\n    struct Response {\n        bytes32 attestationType;\n        bytes32 sourceId;\n        uint64 votingRound;\n        uint64 lowestUsedTimestamp;\n        RequestBody requestBody;\n        ResponseBody responseBody;\n    }\n\n    /**\n     * @notice Toplevel proof\n     * @param merkleProof Merkle proof corresponding to the attestation response.\n     * @param data Attestation response.\n     */\n    struct Proof {\n        bytes32[] merkleProof;\n        Response data;\n    }\n\n    /**\n     * @notice Request body for IAddressValidity attestation type\n     * @param addressStr Address to be verified.\n     */\n    struct RequestBody {\n        string addressStr;\n    }\n\n    /**\n     * @notice Response body for IAddressValidity attestation type\n     * @param isValid Boolean indicator of the address validity.\n     * @param standardAddress If `isValid`, standard form of the validated address. Otherwise an empty string.\n     * @param standardAddressHash If `isValid`, standard address hash of the validated address.\n     * Otherwise a zero bytes32 string.\n     */\n    struct ResponseBody {\n        bool isValid;\n        string standardAddress;\n        bytes32 standardAddressHash;\n    }\n}\n```",
    "meta_data": {
      "title": "IAddressValidity",
      "sidebar_position": 6,
      "description": "Assert whether a string represents a valid address."
    },
    "file_name": "files/hub-docs/fdc/reference/IAddressValidity.mdx",
    "type": "answer"
  },
  {
    "content": "Sourced from `IPayment.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/fdc/IPayment.sol).\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\n\n/**\n * @custom:name IPayment\n * @custom:id 0x01\n * @custom:supported BTC, DOGE, XRP\n * @author Flare\n * @notice A relay of a transaction on an external chain that is considered a payment in a native currency.\n * Various blockchains support different types of native payments. For each blockchain, it is specified how a payment\n * transaction should be formed to be provable by this attestation type.\n * The provable payments emulate traditional banking payments from entity A to entity B in native currency with an\n * optional payment reference.\n * @custom:verification The transaction with `transactionId` is fetched from the API of the blockchain node or\n * relevant indexer.\n * If the transaction cannot be fetched or the transaction is in a block that does not have a sufficient\n * [number of confirmations](/specs/attestations/configs.md#finalityconfirmation), the attestation request is rejected.\n *\n * Once the transaction is received, the payment summary is computed according to the rules for the source chain.\n * If the summary is successfully calculated, the response is assembled from the summary.\n * `blockNumber` and `blockTimestamp` are retrieved from the block if they are not included in the transaction data.\n * For Bitcoin and Dogecoin, `blockTimestamp` is mediantime of the block.\n * For XRPL, `blockTimestamp` is close time of the ledger converted to UNIX time.\n *\n * If the summary is not successfully calculated, the attestation request is rejected.\n * @custom:lut `blockTimestamp`\n * @custom:lutlimit `0x127500`, `0x127500`, `0x127500`\n */\ninterface IPayment {\n    /**\n     * @notice Toplevel request\n     * @param attestationType ID of the attestation type.\n     * @param sourceId ID of the data source.\n     * @param messageIntegrityCode `MessageIntegrityCode` that is derived from the expected response.\n     * @param requestBody Data defining the request. Type (struct) and interpretation is determined\n     * by the `attestationType`.\n     */\n    struct Request {\n        bytes32 attestationType;\n        bytes32 sourceId;\n        bytes32 messageIntegrityCode;\n        RequestBody requestBody;\n    }\n\n    /**\n     * @notice Toplevel response\n     * @param attestationType Extracted from the request.\n     * @param sourceId Extracted from the request.\n     * @param votingRound The ID of the State Connector round in which the request was considered.\n     * @param lowestUsedTimestamp The lowest timestamp used to generate the response.\n     * @param requestBody Extracted from the request.\n     * @param responseBody Data defining the response. The verification rules for the construction\n     * of the response body and the type are defined per specific `attestationType`.\n     */\n    struct Response {\n        bytes32 attestationType;\n        bytes32 sourceId;\n        uint64 votingRound;\n        uint64 lowestUsedTimestamp;\n        RequestBody requestBody;\n        ResponseBody responseBody;\n    }\n\n    /**\n     * @notice Toplevel proof\n     * @param merkleProof Merkle proof corresponding to the attestation response.\n     * @param data Attestation response.\n     */\n    struct Proof {\n        bytes32[] merkleProof;\n        Response data;\n    }\n\n    /**\n     * @notice Request body for Payment attestation type\n     * @param transactionId ID of the payment transaction.\n     * @param inUtxo For UTXO chains, this is the index of the transaction input with source address.\n     * Always 0 for the non-utxo chains.\n     * @param utxo For UTXO chains, this is the index of the transaction output with receiving address.\n     * Always 0 for the non-utxo chains.\n     */\n    struct RequestBody {\n        bytes32 transactionId;\n        uint256 inUtxo;\n        uint256 utxo;\n    }\n\n    /**\n     * @notice Response body for Payment attestation type\n     * @param blockNumber Number of the block in which the transaction is included.\n     * @param blockTimestamp The timestamp of the block in which the transaction is included.\n     * @param sourceAddressHash Standard address hash of the source address.\n     * @param sourceAddressesRoot The root of the Merkle tree of the source addresses.\n     * @param receivingAddressHash Standard address hash of the receiving address.\n     * The zero 32-byte string if there is no receivingAddress (if `status` is not success).\n     * @param intendedReceivingAddressHash Standard address hash of the intended receiving address.\n     * Relevant if the transaction is unsuccessful.\n     * @param spentAmount Amount in minimal units spent by the source address.\n     * @param intendedSpentAmount Amount in minimal units to be spent by the source address.\n     * Relevant if the transaction status is unsuccessful.\n     * @param receivedAmount Amount in minimal units received by the receiving address.\n     * @param intendedReceivedAmount Amount in minimal units intended to be received by the receiving address.\n     * Relevant if the transaction is unsuccessful.\n     * @param standardPaymentReference Standard payment reference of the transaction.\n     * @param oneToOne Indicator whether only one source and one receiver are involved in the transaction.\n     * @param status Success status of the transaction: 0 - success, 1 - failed by sender's fault,\n     * 2 - failed by receiver's fault.\n     */\n    struct ResponseBody {\n        uint64 blockNumber;\n        uint64 blockTimestamp;\n        bytes32 sourceAddressHash;\n        bytes32 sourceAddressesRoot;\n        bytes32 receivingAddressHash;\n        bytes32 intendedReceivingAddressHash;\n        int256 spentAmount;\n        int256 intendedSpentAmount;\n        int256 receivedAmount;\n        int256 intendedReceivedAmount;\n        bytes32 standardPaymentReference;\n        bool oneToOne;\n        uint8 status;\n    }\n}\n```",
    "meta_data": {
      "title": "IPayment",
      "sidebar_position": 10,
      "description": "Relay a transaction in native currency."
    },
    "file_name": "files/hub-docs/fdc/reference/IPayment.mdx",
    "type": "answer"
  },
  {
    "content": "### Bitcoin\n\nAn address on Bitcoin is derived from the locking script (`pkscript`).\nOnly standard locking scripts get assigned an address.\nThere are two formats of the Bitcoin addresses, `Base58` and `Bech32(m)`.\nThe format is determined based on the type of locking script.\n\n#### `Base58`\n\nBitcoin's **Base58** format uses the following encoding dictionary:\n\n```\n123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\n```\n\n##### Address Structure\n\nDecoded addresses have the format:\n\n```\n<leadingByte><hash><checksum>\n```\n\n##### Components\n\n- **`leadingByte`**:\n  - On **mainnet**:\n    - `00` for Pay-to-PubKey (p2pk) and Pay-to-PubKey-Hash (p2pkh)\n    - `05` for Pay-to-Script-Hash (p2sh)\n  - On **testnet**:\n    - `6f` for p2pk and p2pkh\n    - `c4` for p2sh\n- **`hash`**: Represents either the public key, hash of the public key, or hash of a script.\n- **`checksum`**: The first four bytes of the double SHA-256 hash of `<leadingByte><hash>`.\n\n##### Validation Criteria\n\n1. Address contains only characters from the Base58 dictionary.\n2. Decoded hexadecimal form is exactly **25 bytes** long (address length varies between **26 to 34 characters**).\n3. Starts with a valid `leadingByte`.\n4. The checksum is valid and matches the first four bytes of the double SHA-256 hash.\n\n##### Resources\n\n- [Base58Check Encoding](https://en.bitcoin.it/wiki/Base58Check_encoding)\n- [BIP-0013](https://en.bitcoin.it/wiki/BIP_0013)\n- [BIP-0016](https://en.bitcoin.it/wiki/BIP_0016)\n\n#### `Bech32(m)`\n\nBech32 is a newer address format using the character set:\n\n```\nqpzry9x8gf2tvdw0s3jn54khce6mua7l\n```\n\n##### Address Structure\n\nA Bech32 address has the following components:\n\n- **Human-Readable Part (HRP)**:\n  - `bc` for **mainnet**\n  - `tb` for **testnet**\n- **Separator**: Always `1`\n- **Data Part**:\n  - The first character indicates the **witness version** (0-16).\n  - The last six characters form a **checksum**.\n\nThe checksum differs based on the witness version:\n\n- **Bech32** for witness version `0` ([BIP-0173](https://en.bitcoin.it/wiki/BIP_0173))\n- **Bech32m** for witness versions `1` to `16` ([BIP-0350](https://en.bitcoin.it/wiki/BIP_0350))\n\n##### Validation Criteria\n\n1. Address contains only characters from the Bech32 dictionary.\n2. All non-numeric characters must be either entirely uppercase or lowercase.\n3. Starts with a valid HRP followed by the separator (`1`).\n4. Length is between **14 to 74 characters**, with the length modulo 8 being **0, 3, or 5**.\n   - For witness version `0`, length must be **42 or 62 characters**.\n5. Checksum is validated based on the witness version.\n6. Addresses with witness versions `2` and above are unsupported and invalid.\n\n##### Resources\n\n- [Bech32](https://en.bitcoin.it/wiki/Bech32)\n- [SegWit](https://en.bitcoin.it/wiki/Segregated_Witness)\n- [BIP-0141](https://en.bitcoin.it/wiki/BIP_0141)\n- [BIP-0341](https://en.bitcoin.it/wiki/BIP_0341)\n- [BIP-0350](https://en.bitcoin.it/wiki/BIP_0350)\n\n### Dogecoin (`Base58`)\n\nDogecoin uses a **Base58** dictionary, identical to Bitcoin's:\n\n```\n123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\n```\n\n#### Address Structure\n\nDecoded addresses have the format:\n\n```\n<leadingByte><hash><checksum>\n```\n\n#### Components\n\n- **`leadingByte`**:\n  - On **mainnet**:\n    - `1e` for p2pk and p2pkh\n    - `16` for p2sh\n  - On **testnet**:\n    - `6f` for p2pk and p2pkh\n    - `71` for p2sh\n- **`hash`**: Represents either the public key, hash of the public key, or script hash.\n- **`checksum`**: First four bytes of the double SHA-256 hash of `<leadingByte><hash>`.\n\n#### Validation Criteria\n\n1. Address contains only characters from the Base58 dictionary.\n2. Length is **26 to 34 characters**. Decoded hex form is **25 bytes**.\n3. Valid leading byte:\n   - **Mainnet**: Starts with `D`, `A`, or `9`.\n   - **Testnet**: Starts with `n`, `m`, or `2`.\n4. The checksum is validated.\n\n### XRPL (`Base58`)\n\nThe XRP Ledger uses a custom **Base58** dictionary:\n\n```\nrpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz\n```\n\n#### Address Structure\n\nDecoded to hexadecimal:\n\n```\n<leadingByte><publicKeyHash><checksum>\n```\n\n#### Components\n\n- **`leadingByte`**:\n  - On **mainnet**: `00` (addresses start with `r`).\n- **`publicKeyHash`**: A **20-byte** hash of the public key.\n- **`checksum`**: The first four bytes of the double SHA-256 hash of `<leadingByte><publicKeyHash>`.\n\n#### Validation Criteria\n\n1. Address contains only characters from the XRPL Base58 dictionary.\n2. Length is **25 to 35 characters**. Decoded hex form is **25 bytes**.\n3. Address starts with `r`.\n4. The checksum is valid.\n\n#### Resources\n\n- [XRPL Base58 Encodings](https://xrpl.org/base58-encodings.html)\n- [XRPL Addresses](https://xrpl.org/accounts.html#addresses)\n",
    "meta_data": {},
    "file_name": "files/hub-docs/fdc/attestation-types/_addresses.mdx",
    "type": "answer"
  },
  {
    "content": "import IEVMTransaction from \"../reference/IEVMTransaction.mdx\";\n\nInformation about an Ethereum Virtual Machine (EVM) transaction, including details on associated events if specified.\n\nimport IEVMTransaction from \"../reference/IEVMTransaction.mdx\";\n\nInformation about an Ethereum Virtual Machine (EVM) transaction, including details on associated events if specified.\n\nimport IEVMTransaction from \"../reference/IEVMTransaction.mdx\";\n\nInformation about an Ethereum Virtual Machine (EVM) transaction, including details on associated events if specified.\n\nimport IEVMTransaction from \"../reference/IEVMTransaction.mdx\";\n\nInformation about an Ethereum Virtual Machine (EVM) transaction, including details on associated events if specified.\n\nimport IEVMTransaction from \"../reference/IEVMTransaction.mdx\";\n\nInformation about an Ethereum Virtual Machine (EVM) transaction, including details on associated events if specified.\n\nimport IEVMTransaction from \"../reference/IEVMTransaction.mdx\";\n\nInformation about an Ethereum Virtual Machine (EVM) transaction, including details on associated events if specified.",
    "file_name": "files/hub-docs/fdc/attestation-types/evm-transaction.mdx",
    "meta_data": {
      "title": "EVMTransaction",
      "description": "Information about an EVM transaction, including details on associated events if specified.",
      "keywords": [
        "fdc",
        "oracle",
        "flare-data-connector",
        "flare-network"
      ],
      "sidebar_position": 4
    },
    "type": "answer"
  },
  {
    "content": "The **standard address hash** is defined as the `keccak256` hash of the standard address as a string:\n\n```solidity\nkeccak256(standardAddress)\n```\n\n:::note[standard address]\n\nIf an address is case insensitive, the standard address is lowercase.\nIf an address is case sensitive, there is always only one (correct) form of the address.\n\n:::\n\n**Examples:**\n\n| Chain              | Standard Address                             | Standard Address Hash                                                |\n| ------------------ | -------------------------------------------- | -------------------------------------------------------------------- |\n| Bitcoin (`Base58`) | `1FWQiwK27EnGXb6BiBMRLJvunJQZZPMcGd`         | `0x8f651b6990a4754c58fcb5c5a11f4d40f8ddfdeb0e4f67cdd06c27f8d7bcbe33` |\n| Bitcoin (`Bech32`) | `bc1qrmvxmwgqfr5q4fvtvnxczwxwm966n53c4lxh4v` | `0xf75dc4b039ac72e037d67199bb92fa25db32b2210954df99637428473d47cedf` |\n| Dogecoin           | `DL2H9FuaXsxivSs1sRtuJ8uryosyAj62XX`         | `0x51064c88c6b8e9d58b2abeae37a773bf89c9b279f8a05fa0ac0e81ebe13d2f4f` |\n| XRPL               | `rDsbeomae4FXwgQTJp9Rs64Qg9vDiTCdBv`         | `0xa491aed10a1920ca31a85ff29e4bc410705d37d4dc9e690d4d500bcedfd8078f` |\n",
    "meta_data": {},
    "file_name": "files/hub-docs/fdc/attestation-types/_standard_address_hash.mdx",
    "type": "answer"
  },
  {
    "content": "An attestation request that fetches data from the given url and then edits the information with a jq transformation.\n\nAn attestation request that fetches data from the given url and then edits the information with a jq transformation.\n\nAn attestation request that fetches data from the given url and then edits the information with a jq transformation.\n\nAn attestation request that fetches data from the given url and then edits the information with a jq transformation.\n\nAn attestation request that fetches data from the given url and then edits the information with a jq transformation.\n\nAn attestation request that fetches data from the given url and then edits the information with a jq transformation.",
    "file_name": "files/hub-docs/fdc/attestation-types/json-api.mdx",
    "meta_data": {
      "title": "JsonApi",
      "description": "An attestation request that fetches data from the given url and then edits the information with a jq transformation.",
      "keywords": [
        "fdc",
        "oracle",
        "flare-data-connector",
        "flare-network"
      ],
      "sidebar_position": 1
    },
    "type": "answer"
  },
  {
    "content": "import StandardPaymentReference from \"./_standard_payment_reference.mdx\";\nimport Finality from \"./_finality.mdx\";\nimport IReferencedPaymentNonexistence from \"../reference/IReferencedPaymentNonexistence.mdx\";\n\nAssertion that a specific payment, agreed upon to be completed by a certain deadline, has **not been made**. If confirmed, it shows that no transaction meeting the specified criteria (address, amount, reference) was found within the given block range.\n\nThis Information can be used, for example, to justify the liquidation of funds locked in a smart contract on Songbird if a payment is missed.\n\n**Supported Chains**:\n\n- `BTC` (Bitcoin)\n- `DOGE` (Dogecoin)\n- `XRP` (XRP Ledger)\n- Test networks: `testBTC` (Bitcoin Testnet v3), `testDOGE`, `testXRP`\n\n### Request\n\n| Field                      | Solidity Type | Description                                                                   |\n| -------------------------- | ------------- | ----------------------------------------------------------------------------- |\n| `minimalBlockNumber`       | `uint64`      | The block number to start the search range.                                   |\n| `deadlineBlockNumber`      | `uint64`      | The block number to include as the end of the search range.                   |\n| `deadlineTimestamp`        | `uint64`      | The timestamp to include as the end of the search range.                      |\n| `destinationAddressHash`   | `bytes32`     | The standard hash of the address where the payment was expected.              |\n| `amount`                   | `uint256`     | The required payment amount in minimal units.                                 |\n| `standardPaymentReference` | `bytes32`     | The standard payment reference associated with the payment. Must not be zero. |\n| `checkSourceAddresses`     | `bool`        | If true, the source addresses root is checked.                                |\n| `sourceAddressesRoot`      | `bytes32`     | The root of the Merkle tree of the source addresses.                          |\n\n:::note\n\n**Standard Addresses Root** is the root of the Merkle tree build on double keccak256 hashes of the all source addresses of the transaction.\n\n:::\n\n### Response\n\n| Field                         | Solidity Type | Description                                                   |\n| ----------------------------- | ------------- | ------------------------------------------------------------- |\n| `minimalBlockTimestamp`       | `uint64`      | The timestamp of the block at `minimalBlockNumber`.           |\n| `firstOverflowBlockNumber`    | `uint64`      | The block number immediately after the `deadlineBlockNumber`. |\n| `firstOverflowBlockTimestamp` | `uint64`      | The timestamp of the `firstOverflowBlockNumber`.              |\n\n- **`firstOverflowBlockNumber`**: This is the first block with a height greater than `deadlineBlockNumber` and a timestamp later than `deadlineTimestamp`.\n- The search range includes blocks from `minimalBlockNumber` (inclusive) to `firstOverflowBlockNumber` (exclusive).\n\n### Verification process\n\n1. **Block Confirmation**:\n\n   - If the `firstOverflowBlock` cannot be determined or lacks the required [number of confirmations](#finality), the request is rejected.\n   - The request is also rejected if `firstOverflowBlockNumber` is less than or equal to `minimalBlockNumber`.\n\n2. **Search Range**:\n\n   - The search range includes blocks from `minimalBlockNumber` to `firstOverflowBlockNumber` (exclusive).\n   - If the verifier does not have complete visibility of all blocks in this range, the request is rejected.\n\n3. **Transaction Validation**:\n   - The request is confirmed if **no transaction** meeting the specified criteria (address, source addresses root, amount, reference) is found within the specified block range.\n   - The criteria and timestamp interpretation are specific to each chain.\n\nThe verification process is chain-specific, with details described below.\n\n#### UTXO chains (Bitcoin and Dogecoin)\n\n- **Transaction Criteria**:\n  - The transaction **must not be a coinbase transaction**.\n  - The transaction must include the specified [standard payment reference](#standard-payment-reference).\n  - If `checkSourceAddresses` is set to true, the `sourceAddressesRoot` of the transaction must match the specified `sourceAddressesRoot`.\n  - The sum of all output values sent to the specified address **minus** the sum of all input values from the same address must be **greater than the specified `amount`**.\n    - Typically, the sum of input values for the specified address is zero.\n- **Timestamp**: Uses the **mediantime** of the block.\n\n#### Account-based chains (XRPL)\n\n- **Transaction Criteria**:\n\n  - The transaction must be of type **Payment**.\n  - The transaction must include the specified [standard payment reference](#standard-payment-reference).\n  - If `checkSourceAddresses` is set to true, the `sourceAddressesRoot` of the transaction must match the specified `sourceAddressesRoot`.\n  - One of the following conditions must hold:\n    - The transaction status is `SUCCESS` and the amount received by the specified address is greater than the specified `amount`.\n    - The transaction status is `RECEIVER_FAILURE` and the specified address would have received an amount greater than the specified `amount` if the transaction had succeeded.\n\n- **Timestamp**: Uses the **close_time** of the ledger, converted to UNIX time.\n\n:::note[Lowest used timestamp]\n\nFor the `lowestUsedTimestamp` parameter, the value of `minimalBlockTimestamp` is used.\n\n:::",
    "file_name": "files/hub-docs/fdc/attestation-types/referenced-payment-nonexistence.mdx",
    "meta_data": {
      "title": "ReferencedPaymentNonexistence",
      "description": "Assertion that a payment agreed to be completed by a certain deadline, has not been made.",
      "keywords": [
        "fdc",
        "oracle",
        "flare-data-connector",
        "flare-network"
      ],
      "sidebar_position": 5
    },
    "type": "answer"
  },
  {
    "content": "import StandardPaymentReference from \"./_standard_payment_reference.mdx\";\nimport Finality from \"./_finality.mdx\";\nimport IReferencedPaymentNonexistence from \"../reference/IReferencedPaymentNonexistence.mdx\";\n\nAssertion that a specific payment, agreed upon to be completed by a certain deadline, has **not been made**. If confirmed, it shows that no transaction meeting the specified criteria (address, amount, reference) was found within the given block range.\n\nThis Information can be used, for example, to justify the liquidation of funds locked in a smart contract on Songbird if a payment is missed.\n\n**Supported Chains**:\n\n- `BTC` (Bitcoin)\n- `DOGE` (Dogecoin)\n- `XRP` (XRP Ledger)\n- Test networks: `testBTC` (Bitcoin Testnet v3), `testDOGE`, `testXRP`\n\n### Request\n\n| Field                      | Solidity Type | Description                                                                   |\n| -------------------------- | ------------- | ----------------------------------------------------------------------------- |\n| `minimalBlockNumber`       | `uint64`      | The block number to start the search range.                                   |\n| `deadlineBlockNumber`      | `uint64`      | The block number to include as the end of the search range.                   |\n| `deadlineTimestamp`        | `uint64`      | The timestamp to include as the end of the search range.                      |\n| `destinationAddressHash`   | `bytes32`     | The standard hash of the address where the payment was expected.              |\n| `amount`                   | `uint256`     | The required payment amount in minimal units.                                 |\n| `standardPaymentReference` | `bytes32`     | The standard payment reference associated with the payment. Must not be zero. |\n| `checkSourceAddresses`     | `bool`        | If true, the source addresses root is checked.                                |\n| `sourceAddressesRoot`      | `bytes32`     | The root of the Merkle tree of the source addresses.                          |\n\n:::note\n\n**Standard Addresses Root** is the root of the Merkle tree build on double keccak256 hashes of the all source addresses of the transaction.\n\n:::\n\n### Response\n\n| Field                         | Solidity Type | Description                                                   |\n| ----------------------------- | ------------- | ------------------------------------------------------------- |\n| `minimalBlockTimestamp`       | `uint64`      | The timestamp of the block at `minimalBlockNumber`.           |\n| `firstOverflowBlockNumber`    | `uint64`      | The block number immediately after the `deadlineBlockNumber`. |\n| `firstOverflowBlockTimestamp` | `uint64`      | The timestamp of the `firstOverflowBlockNumber`.              |\n\n- **`firstOverflowBlockNumber`**: This is the first block with a height greater than `deadlineBlockNumber` and a timestamp later than `deadlineTimestamp`.\n- The search range includes blocks from `minimalBlockNumber` (inclusive) to `firstOverflowBlockNumber` (exclusive).\n\n### Verification process\n\n1. **Block Confirmation**:\n\n   - If the `firstOverflowBlock` cannot be determined or lacks the required [number of confirmations](#finality), the request is rejected.\n   - The request is also rejected if `firstOverflowBlockNumber` is less than or equal to `minimalBlockNumber`.\n\n2. **Search Range**:\n\n   - The search range includes blocks from `minimalBlockNumber` to `firstOverflowBlockNumber` (exclusive).\n   - If the verifier does not have complete visibility of all blocks in this range, the request is rejected.\n\n3. **Transaction Validation**:\n   - The request is confirmed if **no transaction** meeting the specified criteria (address, source addresses root, amount, reference) is found within the specified block range.\n   - The criteria and timestamp interpretation are specific to each chain.\n\nThe verification process is chain-specific, with details described below.\n\n#### UTXO chains (Bitcoin and Dogecoin)\n\n- **Transaction Criteria**:\n  - The transaction **must not be a coinbase transaction**.\n  - The transaction must include the specified [standard payment reference](#standard-payment-reference).\n  - If `checkSourceAddresses` is set to true, the `sourceAddressesRoot` of the transaction must match the specified `sourceAddressesRoot`.\n  - The sum of all output values sent to the specified address **minus** the sum of all input values from the same address must be **greater than the specified `amount`**.\n    - Typically, the sum of input values for the specified address is zero.\n- **Timestamp**: Uses the **mediantime** of the block.\n\n#### Account-based chains (XRPL)\n\n- **Transaction Criteria**:\n\n  - The transaction must be of type **Payment**.\n  - The transaction must include the specified [standard payment reference](#standard-payment-reference).\n  - If `checkSourceAddresses` is set to true, the `sourceAddressesRoot` of the transaction must match the specified `sourceAddressesRoot`.\n  - One of the following conditions must hold:\n    - The transaction status is `SUCCESS` and the amount received by the specified address is greater than the specified `amount`.\n    - The transaction status is `RECEIVER_FAILURE` and the specified address would have received an amount greater than the specified `amount` if the transaction had succeeded.\n\n- **Timestamp**: Uses the **close_time** of the ledger, converted to UNIX time.\n\n:::note[Lowest used timestamp]\n\nFor the `lowestUsedTimestamp` parameter, the value of `minimalBlockTimestamp` is used.\n\n:::",
    "file_name": "files/hub-docs/fdc/attestation-types/referenced-payment-nonexistence.mdx",
    "meta_data": {
      "title": "ReferencedPaymentNonexistence",
      "description": "Assertion that a payment agreed to be completed by a certain deadline, has not been made.",
      "keywords": [
        "fdc",
        "oracle",
        "flare-data-connector",
        "flare-network"
      ],
      "sidebar_position": 5
    },
    "type": "answer"
  },
  {
    "content": "import StandardPaymentReference from \"./_standard_payment_reference.mdx\";\nimport Finality from \"./_finality.mdx\";\nimport IReferencedPaymentNonexistence from \"../reference/IReferencedPaymentNonexistence.mdx\";\n\nAssertion that a specific payment, agreed upon to be completed by a certain deadline, has **not been made**. If confirmed, it shows that no transaction meeting the specified criteria (address, amount, reference) was found within the given block range.\n\nThis Information can be used, for example, to justify the liquidation of funds locked in a smart contract on Songbird if a payment is missed.\n\n**Supported Chains**:\n\n- `BTC` (Bitcoin)\n- `DOGE` (Dogecoin)\n- `XRP` (XRP Ledger)\n- Test networks: `testBTC` (Bitcoin Testnet v3), `testDOGE`, `testXRP`\n\n### Request\n\n| Field                      | Solidity Type | Description                                                                   |\n| -------------------------- | ------------- | ----------------------------------------------------------------------------- |\n| `minimalBlockNumber`       | `uint64`      | The block number to start the search range.                                   |\n| `deadlineBlockNumber`      | `uint64`      | The block number to include as the end of the search range.                   |\n| `deadlineTimestamp`        | `uint64`      | The timestamp to include as the end of the search range.                      |\n| `destinationAddressHash`   | `bytes32`     | The standard hash of the address where the payment was expected.              |\n| `amount`                   | `uint256`     | The required payment amount in minimal units.                                 |\n| `standardPaymentReference` | `bytes32`     | The standard payment reference associated with the payment. Must not be zero. |\n| `checkSourceAddresses`     | `bool`        | If true, the source addresses root is checked.                                |\n| `sourceAddressesRoot`      | `bytes32`     | The root of the Merkle tree of the source addresses.                          |\n\n:::note\n\n**Standard Addresses Root** is the root of the Merkle tree build on double keccak256 hashes of the all source addresses of the transaction.\n\n:::\n\n### Response\n\n| Field                         | Solidity Type | Description                                                   |\n| ----------------------------- | ------------- | ------------------------------------------------------------- |\n| `minimalBlockTimestamp`       | `uint64`      | The timestamp of the block at `minimalBlockNumber`.           |\n| `firstOverflowBlockNumber`    | `uint64`      | The block number immediately after the `deadlineBlockNumber`. |\n| `firstOverflowBlockTimestamp` | `uint64`      | The timestamp of the `firstOverflowBlockNumber`.              |\n\n- **`firstOverflowBlockNumber`**: This is the first block with a height greater than `deadlineBlockNumber` and a timestamp later than `deadlineTimestamp`.\n- The search range includes blocks from `minimalBlockNumber` (inclusive) to `firstOverflowBlockNumber` (exclusive).\n\n### Verification process\n\n1. **Block Confirmation**:\n\n   - If the `firstOverflowBlock` cannot be determined or lacks the required [number of confirmations](#finality), the request is rejected.\n   - The request is also rejected if `firstOverflowBlockNumber` is less than or equal to `minimalBlockNumber`.\n\n2. **Search Range**:\n\n   - The search range includes blocks from `minimalBlockNumber` to `firstOverflowBlockNumber` (exclusive).\n   - If the verifier does not have complete visibility of all blocks in this range, the request is rejected.\n\n3. **Transaction Validation**:\n   - The request is confirmed if **no transaction** meeting the specified criteria (address, source addresses root, amount, reference) is found within the specified block range.\n   - The criteria and timestamp interpretation are specific to each chain.\n\nThe verification process is chain-specific, with details described below.\n\n#### UTXO chains (Bitcoin and Dogecoin)\n\n- **Transaction Criteria**:\n  - The transaction **must not be a coinbase transaction**.\n  - The transaction must include the specified [standard payment reference](#standard-payment-reference).\n  - If `checkSourceAddresses` is set to true, the `sourceAddressesRoot` of the transaction must match the specified `sourceAddressesRoot`.\n  - The sum of all output values sent to the specified address **minus** the sum of all input values from the same address must be **greater than the specified `amount`**.\n    - Typically, the sum of input values for the specified address is zero.\n- **Timestamp**: Uses the **mediantime** of the block.\n\n#### Account-based chains (XRPL)\n\n- **Transaction Criteria**:\n\n  - The transaction must be of type **Payment**.\n  - The transaction must include the specified [standard payment reference](#standard-payment-reference).\n  - If `checkSourceAddresses` is set to true, the `sourceAddressesRoot` of the transaction must match the specified `sourceAddressesRoot`.\n  - One of the following conditions must hold:\n    - The transaction status is `SUCCESS` and the amount received by the specified address is greater than the specified `amount`.\n    - The transaction status is `RECEIVER_FAILURE` and the specified address would have received an amount greater than the specified `amount` if the transaction had succeeded.\n\n- **Timestamp**: Uses the **close_time** of the ledger, converted to UNIX time.\n\n:::note[Lowest used timestamp]\n\nFor the `lowestUsedTimestamp` parameter, the value of `minimalBlockTimestamp` is used.\n\n:::",
    "file_name": "files/hub-docs/fdc/attestation-types/referenced-payment-nonexistence.mdx",
    "meta_data": {
      "title": "ReferencedPaymentNonexistence",
      "description": "Assertion that a payment agreed to be completed by a certain deadline, has not been made.",
      "keywords": [
        "fdc",
        "oracle",
        "flare-data-connector",
        "flare-network"
      ],
      "sidebar_position": 5
    },
    "type": "answer"
  },
  {
    "content": "import StandardPaymentReference from \"./_standard_payment_reference.mdx\";\nimport Finality from \"./_finality.mdx\";\nimport IReferencedPaymentNonexistence from \"../reference/IReferencedPaymentNonexistence.mdx\";\n\nAssertion that a specific payment, agreed upon to be completed by a certain deadline, has **not been made**. If confirmed, it shows that no transaction meeting the specified criteria (address, amount, reference) was found within the given block range.\n\nThis Information can be used, for example, to justify the liquidation of funds locked in a smart contract on Songbird if a payment is missed.\n\n**Supported Chains**:\n\n- `BTC` (Bitcoin)\n- `DOGE` (Dogecoin)\n- `XRP` (XRP Ledger)\n- Test networks: `testBTC` (Bitcoin Testnet v3), `testDOGE`, `testXRP`\n\n### Request\n\n| Field                      | Solidity Type | Description                                                                   |\n| -------------------------- | ------------- | ----------------------------------------------------------------------------- |\n| `minimalBlockNumber`       | `uint64`      | The block number to start the search range.                                   |\n| `deadlineBlockNumber`      | `uint64`      | The block number to include as the end of the search range.                   |\n| `deadlineTimestamp`        | `uint64`      | The timestamp to include as the end of the search range.                      |\n| `destinationAddressHash`   | `bytes32`     | The standard hash of the address where the payment was expected.              |\n| `amount`                   | `uint256`     | The required payment amount in minimal units.                                 |\n| `standardPaymentReference` | `bytes32`     | The standard payment reference associated with the payment. Must not be zero. |\n| `checkSourceAddresses`     | `bool`        | If true, the source addresses root is checked.                                |\n| `sourceAddressesRoot`      | `bytes32`     | The root of the Merkle tree of the source addresses.                          |\n\n:::note\n\n**Standard Addresses Root** is the root of the Merkle tree build on double keccak256 hashes of the all source addresses of the transaction.\n\n:::\n\n### Response\n\n| Field                         | Solidity Type | Description                                                   |\n| ----------------------------- | ------------- | ------------------------------------------------------------- |\n| `minimalBlockTimestamp`       | `uint64`      | The timestamp of the block at `minimalBlockNumber`.           |\n| `firstOverflowBlockNumber`    | `uint64`      | The block number immediately after the `deadlineBlockNumber`. |\n| `firstOverflowBlockTimestamp` | `uint64`      | The timestamp of the `firstOverflowBlockNumber`.              |\n\n- **`firstOverflowBlockNumber`**: This is the first block with a height greater than `deadlineBlockNumber` and a timestamp later than `deadlineTimestamp`.\n- The search range includes blocks from `minimalBlockNumber` (inclusive) to `firstOverflowBlockNumber` (exclusive).\n\n### Verification process\n\n1. **Block Confirmation**:\n\n   - If the `firstOverflowBlock` cannot be determined or lacks the required [number of confirmations](#finality), the request is rejected.\n   - The request is also rejected if `firstOverflowBlockNumber` is less than or equal to `minimalBlockNumber`.\n\n2. **Search Range**:\n\n   - The search range includes blocks from `minimalBlockNumber` to `firstOverflowBlockNumber` (exclusive).\n   - If the verifier does not have complete visibility of all blocks in this range, the request is rejected.\n\n3. **Transaction Validation**:\n   - The request is confirmed if **no transaction** meeting the specified criteria (address, source addresses root, amount, reference) is found within the specified block range.\n   - The criteria and timestamp interpretation are specific to each chain.\n\nThe verification process is chain-specific, with details described below.\n\n#### UTXO chains (Bitcoin and Dogecoin)\n\n- **Transaction Criteria**:\n  - The transaction **must not be a coinbase transaction**.\n  - The transaction must include the specified [standard payment reference](#standard-payment-reference).\n  - If `checkSourceAddresses` is set to true, the `sourceAddressesRoot` of the transaction must match the specified `sourceAddressesRoot`.\n  - The sum of all output values sent to the specified address **minus** the sum of all input values from the same address must be **greater than the specified `amount`**.\n    - Typically, the sum of input values for the specified address is zero.\n- **Timestamp**: Uses the **mediantime** of the block.\n\n#### Account-based chains (XRPL)\n\n- **Transaction Criteria**:\n\n  - The transaction must be of type **Payment**.\n  - The transaction must include the specified [standard payment reference](#standard-payment-reference).\n  - If `checkSourceAddresses` is set to true, the `sourceAddressesRoot` of the transaction must match the specified `sourceAddressesRoot`.\n  - One of the following conditions must hold:\n    - The transaction status is `SUCCESS` and the amount received by the specified address is greater than the specified `amount`.\n    - The transaction status is `RECEIVER_FAILURE` and the specified address would have received an amount greater than the specified `amount` if the transaction had succeeded.\n\n- **Timestamp**: Uses the **close_time** of the ledger, converted to UNIX time.\n\n:::note[Lowest used timestamp]\n\nFor the `lowestUsedTimestamp` parameter, the value of `minimalBlockTimestamp` is used.\n\n:::",
    "file_name": "files/hub-docs/fdc/attestation-types/referenced-payment-nonexistence.mdx",
    "meta_data": {
      "title": "ReferencedPaymentNonexistence",
      "description": "Assertion that a payment agreed to be completed by a certain deadline, has not been made.",
      "keywords": [
        "fdc",
        "oracle",
        "flare-data-connector",
        "flare-network"
      ],
      "sidebar_position": 5
    },
    "type": "answer"
  },
  {
    "content": "Blockchains have varying confirmation depths to consider blocks as final.\n\n| Chain    | `chainId` | Confirmations required | Confirmation time |\n| -------- | --------- | ---------------------- | ----------------- |\n| Bitcoin  | 0         | 6                      | \u224860 mins          |\n| Dogecoin | 2         | 60                     | \u224860 mins          |\n| XRPL     | 3         | 3                      | \u224812 seconds       |\n",
    "meta_data": {},
    "file_name": "files/hub-docs/fdc/attestation-types/_finality.mdx",
    "type": "answer"
  },
  {
    "content": "Transactions on different blockchains have various success statuses.\nSome blockchains may include transactions even if they failed to execute as intended.\n\n| Status             | Code |\n| ------------------ | ---- |\n| `SUCCESS`          | 0    |\n| `SENDER_FAILURE`   | 1    |\n| `RECEIVER_FAILURE` | 2    |\n\n**Bitcoin and Dogecoin**\n\nIt is not possible to include an unsuccessful transaction in a Bitcoin or Dogecoin block.\nHence, if a transaction is included on a confirmed block, its status is \"SUCCESS.\"\n\n**XRPL**\n\nOn XRPL, some transactions that failed (based on the reason for failure) can be included in a confirmed block.\n\n- **`tesSUCCESS`**: Transaction successful.\n- **`tec`-class codes**: Indicate reasons for failure, such as:\n  - `tecDST_TAG_NEEDED`: Missing required destination tag.\n  - `tecNO_DST`: Nonexistent or unfunded destination address.\n  - `tecNO_PERMISSION`: Source address lacks permission to send funds.\n",
    "meta_data": {},
    "file_name": "files/hub-docs/fdc/attestation-types/_transaction_success_status.mdx",
    "type": "answer"
  },
  {
    "content": "import StandardAddressHash from \"./_standard_address_hash.mdx\";\nimport StandardPaymentReference from \"./_standard_payment_reference.mdx\";\nimport TransactionSuccessStatus from \"./_transaction_success_status.mdx\";\nimport Finality from \"./_finality.mdx\";\nimport IPayment from \"../reference/IPayment.mdx\";\n\nInformation about a transaction on an external chain that is classified as a **native currency payment**.\nEach supported blockchain specifies how a payment transaction should be formatted to be provable using this attestation type. These provable payments mimic traditional banking transactions where entity A sends a native currency to entity B, with an optional payment reference.\n\nimport StandardAddressHash from \"./_standard_address_hash.mdx\";\nimport StandardPaymentReference from \"./_standard_payment_reference.mdx\";\nimport TransactionSuccessStatus from \"./_transaction_success_status.mdx\";\nimport Finality from \"./_finality.mdx\";\nimport IPayment from \"../reference/IPayment.mdx\";\n\nInformation about a transaction on an external chain that is classified as a **native currency payment**.\nEach supported blockchain specifies how a payment transaction should be formatted to be provable using this attestation type. These provable payments mimic traditional banking transactions where entity A sends a native currency to entity B, with an optional payment reference.\n\nimport StandardAddressHash from \"./_standard_address_hash.mdx\";\nimport StandardPaymentReference from \"./_standard_payment_reference.mdx\";\nimport TransactionSuccessStatus from \"./_transaction_success_status.mdx\";\nimport Finality from \"./_finality.mdx\";\nimport IPayment from \"../reference/IPayment.mdx\";\n\nInformation about a transaction on an external chain that is classified as a **native currency payment**.\nEach supported blockchain specifies how a payment transaction should be formatted to be provable using this attestation type. These provable payments mimic traditional banking transactions where entity A sends a native currency to entity B, with an optional payment reference.\n\nimport StandardAddressHash from \"./_standard_address_hash.mdx\";\nimport StandardPaymentReference from \"./_standard_payment_reference.mdx\";\nimport TransactionSuccessStatus from \"./_transaction_success_status.mdx\";\nimport Finality from \"./_finality.mdx\";\nimport IPayment from \"../reference/IPayment.mdx\";\n\nInformation about a transaction on an external chain that is classified as a **native currency payment**.\nEach supported blockchain specifies how a payment transaction should be formatted to be provable using this attestation type. These provable payments mimic traditional banking transactions where entity A sends a native currency to entity B, with an optional payment reference.\n\nimport StandardAddressHash from \"./_standard_address_hash.mdx\";\nimport StandardPaymentReference from \"./_standard_payment_reference.mdx\";\nimport TransactionSuccessStatus from \"./_transaction_success_status.mdx\";\nimport Finality from \"./_finality.mdx\";\nimport IPayment from \"../reference/IPayment.mdx\";\n\nInformation about a transaction on an external chain that is classified as a **native currency payment**.\nEach supported blockchain specifies how a payment transaction should be formatted to be provable using this attestation type. These provable payments mimic traditional banking transactions where entity A sends a native currency to entity B, with an optional payment reference.\n\nimport StandardAddressHash from \"./_standard_address_hash.mdx\";\nimport StandardPaymentReference from \"./_standard_payment_reference.mdx\";\nimport TransactionSuccessStatus from \"./_transaction_success_status.mdx\";\nimport Finality from \"./_finality.mdx\";\nimport IPayment from \"../reference/IPayment.mdx\";\n\nInformation about a transaction on an external chain that is classified as a **native currency payment**.\nEach supported blockchain specifies how a payment transaction should be formatted to be provable using this attestation type. These provable payments mimic traditional banking transactions where entity A sends a native currency to entity B, with an optional payment reference.\n\nimport StandardAddressHash from \"./_standard_address_hash.mdx\";\nimport StandardPaymentReference from \"./_standard_payment_reference.mdx\";\nimport TransactionSuccessStatus from \"./_transaction_success_status.mdx\";\nimport Finality from \"./_finality.mdx\";\nimport IPayment from \"../reference/IPayment.mdx\";\n\nInformation about a transaction on an external chain that is classified as a **native currency payment**.\nEach supported blockchain specifies how a payment transaction should be formatted to be provable using this attestation type. These provable payments mimic traditional banking transactions where entity A sends a native currency to entity B, with an optional payment reference.",
    "file_name": "files/hub-docs/fdc/attestation-types/payment.mdx",
    "meta_data": {
      "title": "Payment",
      "description": "Information about a transaction on an external chain that is classified as a native currency payment.",
      "keywords": [
        "fdc",
        "oracle",
        "flare-data-connector",
        "flare-network"
      ],
      "sidebar_position": 5
    },
    "type": "answer"
  },
  {
    "content": "import StandardAddressHash from \"./_standard_address_hash.mdx\";\nimport StandardPaymentReference from \"./_standard_payment_reference.mdx\";\nimport TransactionSuccessStatus from \"./_transaction_success_status.mdx\";\nimport Finality from \"./_finality.mdx\";\nimport IPayment from \"../reference/IPayment.mdx\";\n\nInformation about a transaction on an external chain that is classified as a **native currency payment**.\nEach supported blockchain specifies how a payment transaction should be formatted to be provable using this attestation type. These provable payments mimic traditional banking transactions where entity A sends a native currency to entity B, with an optional payment reference.\n\nimport StandardAddressHash from \"./_standard_address_hash.mdx\";\nimport StandardPaymentReference from \"./_standard_payment_reference.mdx\";\nimport TransactionSuccessStatus from \"./_transaction_success_status.mdx\";\nimport Finality from \"./_finality.mdx\";\nimport IPayment from \"../reference/IPayment.mdx\";\n\nInformation about a transaction on an external chain that is classified as a **native currency payment**.\nEach supported blockchain specifies how a payment transaction should be formatted to be provable using this attestation type. These provable payments mimic traditional banking transactions where entity A sends a native currency to entity B, with an optional payment reference.\n\nimport StandardAddressHash from \"./_standard_address_hash.mdx\";\nimport StandardPaymentReference from \"./_standard_payment_reference.mdx\";\nimport TransactionSuccessStatus from \"./_transaction_success_status.mdx\";\nimport Finality from \"./_finality.mdx\";\nimport IPayment from \"../reference/IPayment.mdx\";\n\nInformation about a transaction on an external chain that is classified as a **native currency payment**.\nEach supported blockchain specifies how a payment transaction should be formatted to be provable using this attestation type. These provable payments mimic traditional banking transactions where entity A sends a native currency to entity B, with an optional payment reference.\n\nimport StandardAddressHash from \"./_standard_address_hash.mdx\";\nimport StandardPaymentReference from \"./_standard_payment_reference.mdx\";\nimport TransactionSuccessStatus from \"./_transaction_success_status.mdx\";\nimport Finality from \"./_finality.mdx\";\nimport IPayment from \"../reference/IPayment.mdx\";\n\nInformation about a transaction on an external chain that is classified as a **native currency payment**.\nEach supported blockchain specifies how a payment transaction should be formatted to be provable using this attestation type. These provable payments mimic traditional banking transactions where entity A sends a native currency to entity B, with an optional payment reference.",
    "file_name": "files/hub-docs/fdc/attestation-types/payment.mdx",
    "meta_data": {
      "title": "Payment",
      "description": "Information about a transaction on an external chain that is classified as a native currency payment.",
      "keywords": [
        "fdc",
        "oracle",
        "flare-data-connector",
        "flare-network"
      ],
      "sidebar_position": 5
    },
    "type": "answer"
  },
  {
    "content": "import Finality from \"./_finality.mdx\";\nimport StandardAddressHash from \"./_standard_address_hash.mdx\";\nimport TransactionSuccessStatus from \"./_transaction_success_status.mdx\";\nimport StandardPaymentReference from \"./_standard_payment_reference.mdx\";\nimport IBalanceDecreasingTransaction from \"../reference/IBalanceDecreasingTransaction.mdx\";\n\nInformation describing a transaction that either **decreases the balance** for a specified address.\n\nA transaction is considered \u201cbalance decreasing\u201d for the specified address if:\n\n1. The balance **after the transaction** is lower than **before**.\n2. The address is among the **signers** of the transaction (even if its balance is not reduced).\n\nimport Finality from \"./_finality.mdx\";\nimport StandardAddressHash from \"./_standard_address_hash.mdx\";\nimport TransactionSuccessStatus from \"./_transaction_success_status.mdx\";\nimport StandardPaymentReference from \"./_standard_payment_reference.mdx\";\nimport IBalanceDecreasingTransaction from \"../reference/IBalanceDecreasingTransaction.mdx\";\n\nInformation describing a transaction that either **decreases the balance** for a specified address.\n\nA transaction is considered \u201cbalance decreasing\u201d for the specified address if:\n\n1. The balance **after the transaction** is lower than **before**.\n2. The address is among the **signers** of the transaction (even if its balance is not reduced).\n\nimport Finality from \"./_finality.mdx\";\nimport StandardAddressHash from \"./_standard_address_hash.mdx\";\nimport TransactionSuccessStatus from \"./_transaction_success_status.mdx\";\nimport StandardPaymentReference from \"./_standard_payment_reference.mdx\";\nimport IBalanceDecreasingTransaction from \"../reference/IBalanceDecreasingTransaction.mdx\";\n\nInformation describing a transaction that either **decreases the balance** for a specified address.\n\nA transaction is considered \u201cbalance decreasing\u201d for the specified address if:\n\n1. The balance **after the transaction** is lower than **before**.\n2. The address is among the **signers** of the transaction (even if its balance is not reduced).\n\nimport Finality from \"./_finality.mdx\";\nimport StandardAddressHash from \"./_standard_address_hash.mdx\";\nimport TransactionSuccessStatus from \"./_transaction_success_status.mdx\";\nimport StandardPaymentReference from \"./_standard_payment_reference.mdx\";\nimport IBalanceDecreasingTransaction from \"../reference/IBalanceDecreasingTransaction.mdx\";\n\nInformation describing a transaction that either **decreases the balance** for a specified address.\n\nA transaction is considered \u201cbalance decreasing\u201d for the specified address if:\n\n1. The balance **after the transaction** is lower than **before**.\n2. The address is among the **signers** of the transaction (even if its balance is not reduced).\n\nimport Finality from \"./_finality.mdx\";\nimport StandardAddressHash from \"./_standard_address_hash.mdx\";\nimport TransactionSuccessStatus from \"./_transaction_success_status.mdx\";\nimport StandardPaymentReference from \"./_standard_payment_reference.mdx\";\nimport IBalanceDecreasingTransaction from \"../reference/IBalanceDecreasingTransaction.mdx\";\n\nInformation describing a transaction that either **decreases the balance** for a specified address.\n\nA transaction is considered \u201cbalance decreasing\u201d for the specified address if:\n\n1. The balance **after the transaction** is lower than **before**.\n2. The address is among the **signers** of the transaction (even if its balance is not reduced).\n\nimport Finality from \"./_finality.mdx\";\nimport StandardAddressHash from \"./_standard_address_hash.mdx\";\nimport TransactionSuccessStatus from \"./_transaction_success_status.mdx\";\nimport StandardPaymentReference from \"./_standard_payment_reference.mdx\";\nimport IBalanceDecreasingTransaction from \"../reference/IBalanceDecreasingTransaction.mdx\";\n\nInformation describing a transaction that either **decreases the balance** for a specified address.\n\nA transaction is considered \u201cbalance decreasing\u201d for the specified address if:\n\n1. The balance **after the transaction** is lower than **before**.\n2. The address is among the **signers** of the transaction (even if its balance is not reduced).\n\nimport Finality from \"./_finality.mdx\";\nimport StandardAddressHash from \"./_standard_address_hash.mdx\";\nimport TransactionSuccessStatus from \"./_transaction_success_status.mdx\";\nimport StandardPaymentReference from \"./_standard_payment_reference.mdx\";\nimport IBalanceDecreasingTransaction from \"../reference/IBalanceDecreasingTransaction.mdx\";\n\nInformation describing a transaction that either **decreases the balance** for a specified address.\n\nA transaction is considered \u201cbalance decreasing\u201d for the specified address if:\n\n1. The balance **after the transaction** is lower than **before**.\n2. The address is among the **signers** of the transaction (even if its balance is not reduced).",
    "file_name": "files/hub-docs/fdc/attestation-types/balance-decreasing-transaction.mdx",
    "meta_data": {
      "title": "BalanceDecreasingTransaction",
      "description": "Detects a transaction that either decreases the balance of a specified address.",
      "keywords": [
        "fdc",
        "oracle",
        "flare-data-connector",
        "flare-network"
      ],
      "sidebar_position": 2
    },
    "type": "answer"
  },
  {
    "content": "import Finality from \"./_finality.mdx\";\nimport StandardAddressHash from \"./_standard_address_hash.mdx\";\nimport TransactionSuccessStatus from \"./_transaction_success_status.mdx\";\nimport StandardPaymentReference from \"./_standard_payment_reference.mdx\";\nimport IBalanceDecreasingTransaction from \"../reference/IBalanceDecreasingTransaction.mdx\";\n\nInformation describing a transaction that either **decreases the balance** for a specified address.\n\nA transaction is considered \u201cbalance decreasing\u201d for the specified address if:\n\n1. The balance **after the transaction** is lower than **before**.\n2. The address is among the **signers** of the transaction (even if its balance is not reduced).\n\nimport Finality from \"./_finality.mdx\";\nimport StandardAddressHash from \"./_standard_address_hash.mdx\";\nimport TransactionSuccessStatus from \"./_transaction_success_status.mdx\";\nimport StandardPaymentReference from \"./_standard_payment_reference.mdx\";\nimport IBalanceDecreasingTransaction from \"../reference/IBalanceDecreasingTransaction.mdx\";\n\nInformation describing a transaction that either **decreases the balance** for a specified address.\n\nA transaction is considered \u201cbalance decreasing\u201d for the specified address if:\n\n1. The balance **after the transaction** is lower than **before**.\n2. The address is among the **signers** of the transaction (even if its balance is not reduced).\n\nimport Finality from \"./_finality.mdx\";\nimport StandardAddressHash from \"./_standard_address_hash.mdx\";\nimport TransactionSuccessStatus from \"./_transaction_success_status.mdx\";\nimport StandardPaymentReference from \"./_standard_payment_reference.mdx\";\nimport IBalanceDecreasingTransaction from \"../reference/IBalanceDecreasingTransaction.mdx\";\n\nInformation describing a transaction that either **decreases the balance** for a specified address.\n\nA transaction is considered \u201cbalance decreasing\u201d for the specified address if:\n\n1. The balance **after the transaction** is lower than **before**.\n2. The address is among the **signers** of the transaction (even if its balance is not reduced).\n\nimport Finality from \"./_finality.mdx\";\nimport StandardAddressHash from \"./_standard_address_hash.mdx\";\nimport TransactionSuccessStatus from \"./_transaction_success_status.mdx\";\nimport StandardPaymentReference from \"./_standard_payment_reference.mdx\";\nimport IBalanceDecreasingTransaction from \"../reference/IBalanceDecreasingTransaction.mdx\";\n\nInformation describing a transaction that either **decreases the balance** for a specified address.\n\nA transaction is considered \u201cbalance decreasing\u201d for the specified address if:\n\n1. The balance **after the transaction** is lower than **before**.\n2. The address is among the **signers** of the transaction (even if its balance is not reduced).",
    "file_name": "files/hub-docs/fdc/attestation-types/balance-decreasing-transaction.mdx",
    "meta_data": {
      "title": "BalanceDecreasingTransaction",
      "description": "Detects a transaction that either decreases the balance of a specified address.",
      "keywords": [
        "fdc",
        "oracle",
        "flare-data-connector",
        "flare-network"
      ],
      "sidebar_position": 2
    },
    "type": "answer"
  },
  {
    "content": "import Addresses from \"./_addresses.mdx\";\nimport IAddressValidity from \"../reference/IAddressValidity.mdx\";\n\nAssertion whether a given string represents a **valid address** on an external blockchain.\n\nimport Addresses from \"./_addresses.mdx\";\nimport IAddressValidity from \"../reference/IAddressValidity.mdx\";\n\nAssertion whether a given string represents a **valid address** on an external blockchain.\n\nimport Addresses from \"./_addresses.mdx\";\nimport IAddressValidity from \"../reference/IAddressValidity.mdx\";\n\nAssertion whether a given string represents a **valid address** on an external blockchain.\n\nimport Addresses from \"./_addresses.mdx\";\nimport IAddressValidity from \"../reference/IAddressValidity.mdx\";\n\nAssertion whether a given string represents a **valid address** on an external blockchain.\n\nimport Addresses from \"./_addresses.mdx\";\nimport IAddressValidity from \"../reference/IAddressValidity.mdx\";\n\nAssertion whether a given string represents a **valid address** on an external blockchain.\n\nimport Addresses from \"./_addresses.mdx\";\nimport IAddressValidity from \"../reference/IAddressValidity.mdx\";\n\nAssertion whether a given string represents a **valid address** on an external blockchain.\n\nimport Addresses from \"./_addresses.mdx\";\nimport IAddressValidity from \"../reference/IAddressValidity.mdx\";\n\nAssertion whether a given string represents a **valid address** on an external blockchain.",
    "file_name": "files/hub-docs/fdc/attestation-types/address-validity.mdx",
    "meta_data": {
      "title": "AddressValidity",
      "description": "Assertion whether a given string represents a valid address on an external blockchain.",
      "keywords": [
        "fdc",
        "oracle",
        "flare-data-connector",
        "flare-network"
      ],
      "sidebar_position": 1
    },
    "type": "answer"
  },
  {
    "content": "A standard payment reference is defined as a 32-byte sequence that can be added to a payment transaction, in the same way that a payment reference is attached to a traditional banking transaction.\n\n### Bitcoin and Dogecoin\n\n- Uses `OP_RETURN` to store references.\n- A transaction is considered to have a `standardPaymentReference` defined if it has:\n  - Exactly one output UTXO with `OP_RETURN` script, and\n  - The script is of the form `OP_RETURN <reference\\>` or `6a<lengthOfReferenceInHex\\><reference\\> `in hex, where the length of the reference is 32 bytes.\n- Then `0x<reference\\>` is the `standardPaymentReference`.\n\n### XRPL\n\n- Uses the `memoData` field.\n- A transaction has a `standardPaymentReference` if it has:\n  - Exactly one [Memo](https://xrpl.org/transaction-common-fields.html#memos-field), and\n  - The `memoData` of this field is a hex string that represents a byte sequence of exactly 32 bytes.\n- This 32-byte sequence defines the `standardPaymentReference`.\n",
    "meta_data": {},
    "file_name": "files/hub-docs/fdc/attestation-types/_standard_payment_reference.mdx",
    "type": "answer"
  },
  {
    "content": "import Finality from \"./_finality.mdx\";\nimport IConfirmedBlockHeightExists from \"../reference/IConfirmedBlockHeightExists.mdx\";\n\nAssertion whether a block with the specified `blockNumber` is **confirmed** with additional data to compute the **block production rate** within a given time window.\n\nimport Finality from \"./_finality.mdx\";\nimport IConfirmedBlockHeightExists from \"../reference/IConfirmedBlockHeightExists.mdx\";\n\nAssertion whether a block with the specified `blockNumber` is **confirmed** with additional data to compute the **block production rate** within a given time window.\n\nimport Finality from \"./_finality.mdx\";\nimport IConfirmedBlockHeightExists from \"../reference/IConfirmedBlockHeightExists.mdx\";\n\nAssertion whether a block with the specified `blockNumber` is **confirmed** with additional data to compute the **block production rate** within a given time window.\n\nimport Finality from \"./_finality.mdx\";\nimport IConfirmedBlockHeightExists from \"../reference/IConfirmedBlockHeightExists.mdx\";\n\nAssertion whether a block with the specified `blockNumber` is **confirmed** with additional data to compute the **block production rate** within a given time window.\n\nimport Finality from \"./_finality.mdx\";\nimport IConfirmedBlockHeightExists from \"../reference/IConfirmedBlockHeightExists.mdx\";\n\nAssertion whether a block with the specified `blockNumber` is **confirmed** with additional data to compute the **block production rate** within a given time window.\n\nimport Finality from \"./_finality.mdx\";\nimport IConfirmedBlockHeightExists from \"../reference/IConfirmedBlockHeightExists.mdx\";\n\nAssertion whether a block with the specified `blockNumber` is **confirmed** with additional data to compute the **block production rate** within a given time window.\n\nimport Finality from \"./_finality.mdx\";\nimport IConfirmedBlockHeightExists from \"../reference/IConfirmedBlockHeightExists.mdx\";\n\nAssertion whether a block with the specified `blockNumber` is **confirmed** with additional data to compute the **block production rate** within a given time window.",
    "file_name": "files/hub-docs/fdc/attestation-types/confirmed-block-height-exists.mdx",
    "meta_data": {
      "title": "ConfirmedBlockHeightExists",
      "description": "Assertion whether a specified block number is confirmed.",
      "keywords": [
        "fdc",
        "oracle",
        "flare-data-connector",
        "flare-network"
      ],
      "sidebar_position": 3
    },
    "type": "answer"
  },
  {
    "content": "import Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\n\nThe starter kit includes a basic setup for configuring Hardhat and Foundry, along with examples on how to compile, test and deploy smart contracts on Flare.\n\nimport Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\n\nThe starter kit includes a basic setup for configuring Hardhat and Foundry, along with examples on how to compile, test and deploy smart contracts on Flare.\n\nimport Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\n\nThe starter kit includes a basic setup for configuring Hardhat and Foundry, along with examples on how to compile, test and deploy smart contracts on Flare.",
    "file_name": "files/hub-docs/network/guides/hardhat-foundry-starter-kit.mdx",
    "meta_data": {
      "slug": "hardhat-foundry-starter-kit",
      "title": "Hardhat and Foundry Starter Kit",
      "sidebar_label": "Hardhat & Foundry Starter Kit",
      "tags": [
        "quickstart",
        "hardhat",
        "foundry",
        "solidity"
      ],
      "authors": [
        "filipkoprivec"
      ],
      "description": "Integrate Flare into Hardhat and Foundry.",
      "keywords": [
        "hardhat",
        "foundry",
        "quickstart",
        "solidity",
        "smart-contract",
        "flare-network"
      ],
      "sidebar_position": 1
    },
    "type": "answer"
  },
  {
    "content": "[FlareDrops](https://flare.network/flaredrop-guide/) are a series of 36 monthly drops totalling 24.2 billion FLR can be claimed by active Flare community members who have wrapped their Flare tokens.\nThis guide explains how to manage FlareDrop functionality in applications.\n\n<details>\n<summary>**Understanding Personal Delegation Accounts (PDAs).**</summary>\n\nDifferences between PDAs and regular accounts:\n\n- A PDA cannot have another PDA of its own.\n- PDA addresses cannot participate in governance directly, but their owners can transfer all their votes to another address (their main account or someone else's).\n- A PDA automatically converts any FLR tokens transferred to it to wrapped Flare tokens (WFLR), which are more useful for functions such as delegation.\n- Only the owner of the main account can transfer funds from the PDA and only to the main account.\n- When an executor is configured, it will claim rewards both from the main account and the PDA, and send them to the PDA.\n\n</details>\n\n<details>\n<summary>**Understanding the Registered Claim Process.**</summary>\n\nRegistration allows accounts to list themselves onchain as registered executors and post their service fees. This simplifies the process for both users and executors: users can easily find a suitable executor, and executors benefit from automatic fee transfers when user rewards are claimed. Users pay a fee to set an executor for claiming their rewards, which are then claimed automatically without user intervention. All agreements with a registered executor occur onchain.\n\nHere is how the registered claiming process works, with applications performing these actions on behalf of executors and users:\n\n1. Executors who want to be publicly available to users register as executors by paying a registration fee, which is then burned.\n2. Registered executors post their fees for claiming rewards.\n3. Users with accrued rewards who want an executor to claim on their behalf can choose from the list of registered executors.\n4. Users pay a setup fee to enable a registered executor to claim their rewards, and this fee is sent to the executor.\n5. Executors claim rewards for one or more users, with their fees automatically deducted from the claimed rewards.\n6. Executors notify users offchain if they discontinue providing this service.\n\nThroughout the process:\n\n- Users and executors can view reports on which addresses executors are claiming for and which executors are registered.\n- Registered executors can change their fees or unregister, while users can change the registered executor claiming on their behalf or disable automatic claiming.\n\n</details>",
    "file_name": "files/hub-docs/network/guides/manage-flaredrops.mdx",
    "meta_data": {
      "slug": "manage-flaredrops",
      "title": "Manage FlareDrops",
      "tags": [
        "intermediate",
        "solidity"
      ],
      "authors": [
        "dineshpinto"
      ],
      "description": "Manage FlareDrop functionality in applications.",
      "keywords": [
        "intermediate",
        "solidity",
        "smart-contract",
        "flare-network"
      ],
      "sidebar_position": 7
    },
    "type": "answer"
  },
  {
    "content": "[FlareDrops](https://flare.network/flaredrop-guide/) are a series of 36 monthly drops totalling 24.2 billion FLR can be claimed by active Flare community members who have wrapped their Flare tokens.\nThis guide explains how to manage FlareDrop functionality in applications.\n\n<details>\n<summary>**Understanding Personal Delegation Accounts (PDAs).**</summary>\n\nDifferences between PDAs and regular accounts:\n\n- A PDA cannot have another PDA of its own.\n- PDA addresses cannot participate in governance directly, but their owners can transfer all their votes to another address (their main account or someone else's).\n- A PDA automatically converts any FLR tokens transferred to it to wrapped Flare tokens (WFLR), which are more useful for functions such as delegation.\n- Only the owner of the main account can transfer funds from the PDA and only to the main account.\n- When an executor is configured, it will claim rewards both from the main account and the PDA, and send them to the PDA.\n\n</details>\n\n<details>\n<summary>**Understanding the Registered Claim Process.**</summary>\n\nRegistration allows accounts to list themselves onchain as registered executors and post their service fees. This simplifies the process for both users and executors: users can easily find a suitable executor, and executors benefit from automatic fee transfers when user rewards are claimed. Users pay a fee to set an executor for claiming their rewards, which are then claimed automatically without user intervention. All agreements with a registered executor occur onchain.\n\nHere is how the registered claiming process works, with applications performing these actions on behalf of executors and users:\n\n1. Executors who want to be publicly available to users register as executors by paying a registration fee, which is then burned.\n2. Registered executors post their fees for claiming rewards.\n3. Users with accrued rewards who want an executor to claim on their behalf can choose from the list of registered executors.\n4. Users pay a setup fee to enable a registered executor to claim their rewards, and this fee is sent to the executor.\n5. Executors claim rewards for one or more users, with their fees automatically deducted from the claimed rewards.\n6. Executors notify users offchain if they discontinue providing this service.\n\nThroughout the process:\n\n- Users and executors can view reports on which addresses executors are claiming for and which executors are registered.\n- Registered executors can change their fees or unregister, while users can change the registered executor claiming on their behalf or disable automatic claiming.\n\n</details>",
    "file_name": "files/hub-docs/network/guides/manage-flaredrops.mdx",
    "meta_data": {
      "slug": "manage-flaredrops",
      "title": "Manage FlareDrops",
      "tags": [
        "intermediate",
        "solidity"
      ],
      "authors": [
        "dineshpinto"
      ],
      "description": "Manage FlareDrop functionality in applications.",
      "keywords": [
        "intermediate",
        "solidity",
        "smart-contract",
        "flare-network"
      ],
      "sidebar_position": 7
    },
    "type": "answer"
  },
  {
    "content": "[FlareDrops](https://flare.network/flaredrop-guide/) are a series of 36 monthly drops totalling 24.2 billion FLR can be claimed by active Flare community members who have wrapped their Flare tokens.\nThis guide explains how to manage FlareDrop functionality in applications.\n\n<details>\n<summary>**Understanding Personal Delegation Accounts (PDAs).**</summary>\n\nDifferences between PDAs and regular accounts:\n\n- A PDA cannot have another PDA of its own.\n- PDA addresses cannot participate in governance directly, but their owners can transfer all their votes to another address (their main account or someone else's).\n- A PDA automatically converts any FLR tokens transferred to it to wrapped Flare tokens (WFLR), which are more useful for functions such as delegation.\n- Only the owner of the main account can transfer funds from the PDA and only to the main account.\n- When an executor is configured, it will claim rewards both from the main account and the PDA, and send them to the PDA.\n\n</details>\n\n<details>\n<summary>**Understanding the Registered Claim Process.**</summary>\n\nRegistration allows accounts to list themselves onchain as registered executors and post their service fees. This simplifies the process for both users and executors: users can easily find a suitable executor, and executors benefit from automatic fee transfers when user rewards are claimed. Users pay a fee to set an executor for claiming their rewards, which are then claimed automatically without user intervention. All agreements with a registered executor occur onchain.\n\nHere is how the registered claiming process works, with applications performing these actions on behalf of executors and users:\n\n1. Executors who want to be publicly available to users register as executors by paying a registration fee, which is then burned.\n2. Registered executors post their fees for claiming rewards.\n3. Users with accrued rewards who want an executor to claim on their behalf can choose from the list of registered executors.\n4. Users pay a setup fee to enable a registered executor to claim their rewards, and this fee is sent to the executor.\n5. Executors claim rewards for one or more users, with their fees automatically deducted from the claimed rewards.\n6. Executors notify users offchain if they discontinue providing this service.\n\nThroughout the process:\n\n- Users and executors can view reports on which addresses executors are claiming for and which executors are registered.\n- Registered executors can change their fees or unregister, while users can change the registered executor claiming on their behalf or disable automatic claiming.\n\n</details>",
    "file_name": "files/hub-docs/network/guides/manage-flaredrops.mdx",
    "meta_data": {
      "slug": "manage-flaredrops",
      "title": "Manage FlareDrops",
      "tags": [
        "intermediate",
        "solidity"
      ],
      "authors": [
        "dineshpinto"
      ],
      "description": "Manage FlareDrop functionality in applications.",
      "keywords": [
        "intermediate",
        "solidity",
        "smart-contract",
        "flare-network"
      ],
      "sidebar_position": 7
    },
    "type": "answer"
  },
  {
    "content": "[FlareDrops](https://flare.network/flaredrop-guide/) are a series of 36 monthly drops totalling 24.2 billion FLR can be claimed by active Flare community members who have wrapped their Flare tokens.\nThis guide explains how to manage FlareDrop functionality in applications.\n\n<details>\n<summary>**Understanding Personal Delegation Accounts (PDAs).**</summary>\n\nDifferences between PDAs and regular accounts:\n\n- A PDA cannot have another PDA of its own.\n- PDA addresses cannot participate in governance directly, but their owners can transfer all their votes to another address (their main account or someone else's).\n- A PDA automatically converts any FLR tokens transferred to it to wrapped Flare tokens (WFLR), which are more useful for functions such as delegation.\n- Only the owner of the main account can transfer funds from the PDA and only to the main account.\n- When an executor is configured, it will claim rewards both from the main account and the PDA, and send them to the PDA.\n\n</details>\n\n<details>\n<summary>**Understanding the Registered Claim Process.**</summary>\n\nRegistration allows accounts to list themselves onchain as registered executors and post their service fees. This simplifies the process for both users and executors: users can easily find a suitable executor, and executors benefit from automatic fee transfers when user rewards are claimed. Users pay a fee to set an executor for claiming their rewards, which are then claimed automatically without user intervention. All agreements with a registered executor occur onchain.\n\nHere is how the registered claiming process works, with applications performing these actions on behalf of executors and users:\n\n1. Executors who want to be publicly available to users register as executors by paying a registration fee, which is then burned.\n2. Registered executors post their fees for claiming rewards.\n3. Users with accrued rewards who want an executor to claim on their behalf can choose from the list of registered executors.\n4. Users pay a setup fee to enable a registered executor to claim their rewards, and this fee is sent to the executor.\n5. Executors claim rewards for one or more users, with their fees automatically deducted from the claimed rewards.\n6. Executors notify users offchain if they discontinue providing this service.\n\nThroughout the process:\n\n- Users and executors can view reports on which addresses executors are claiming for and which executors are registered.\n- Registered executors can change their fees or unregister, while users can change the registered executor claiming on their behalf or disable automatic claiming.\n\n</details>",
    "file_name": "files/hub-docs/network/guides/manage-flaredrops.mdx",
    "meta_data": {
      "slug": "manage-flaredrops",
      "title": "Manage FlareDrops",
      "tags": [
        "intermediate",
        "solidity"
      ],
      "authors": [
        "dineshpinto"
      ],
      "description": "Manage FlareDrop functionality in applications.",
      "keywords": [
        "intermediate",
        "solidity",
        "smart-contract",
        "flare-network"
      ],
      "sidebar_position": 7
    },
    "type": "answer"
  },
  {
    "content": "import Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport FtsoV2FeedConsumerNoImports from \"!!raw-loader!/examples/developer-hub-solidity/FtsoV2FeedConsumer_no_imports.sol\";\nimport ChainIdCoston2 from \"!!raw-loader!/examples/developer-hub-go/coston2/chain_id.go\";\nimport ChainIdFlare from \"!!raw-loader!/examples/developer-hub-go/flare/chain_id.go\";\nimport MakeQueryCoston2 from \"!!raw-loader!/examples/developer-hub-go/coston2/make_query.go\";\nimport MakeQueryFlare from \"!!raw-loader!/examples/developer-hub-go/flare/make_query.go\";\nimport CreateAccount from \"!!raw-loader!/examples/developer-hub-go/create_account.go\";\nimport DeployContractCoston2 from \"!!raw-loader!/examples/developer-hub-go/coston2/deploy_contract.go\";\nimport DeployContractFlare from \"!!raw-loader!/examples/developer-hub-go/flare/deploy_contract.go\";\n\nThis guide is for developers who want to interact with Flare using Go. In this guide, using Go, you will learn how to:\n\n- Query a contract on Flare using the Go API for [Geth](https://github.com/ethereum/go-ethereum), a client that implements the full Ethereum JSON-RPC API.\n- Compile a Solidity contract using the CLI interface of [solc](https://github.com/ethereum/solidity), the Solidity compiler.\n- Deploy your compiled contract on Flare.\n\n:::tip\n\nAll examples in this guide are available at [developer-hub/examples](https://github.com/flare-foundation/developer-hub/tree/main/examples).\n\n:::\n\nimport Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport FtsoV2FeedConsumerNoImports from \"!!raw-loader!/examples/developer-hub-solidity/FtsoV2FeedConsumer_no_imports.sol\";\nimport ChainIdCoston2 from \"!!raw-loader!/examples/developer-hub-go/coston2/chain_id.go\";\nimport ChainIdFlare from \"!!raw-loader!/examples/developer-hub-go/flare/chain_id.go\";\nimport MakeQueryCoston2 from \"!!raw-loader!/examples/developer-hub-go/coston2/make_query.go\";\nimport MakeQueryFlare from \"!!raw-loader!/examples/developer-hub-go/flare/make_query.go\";\nimport CreateAccount from \"!!raw-loader!/examples/developer-hub-go/create_account.go\";\nimport DeployContractCoston2 from \"!!raw-loader!/examples/developer-hub-go/coston2/deploy_contract.go\";\nimport DeployContractFlare from \"!!raw-loader!/examples/developer-hub-go/flare/deploy_contract.go\";\n\nThis guide is for developers who want to interact with Flare using Go. In this guide, using Go, you will learn how to:\n\n- Query a contract on Flare using the Go API for [Geth](https://github.com/ethereum/go-ethereum), a client that implements the full Ethereum JSON-RPC API.\n- Compile a Solidity contract using the CLI interface of [solc](https://github.com/ethereum/solidity), the Solidity compiler.\n- Deploy your compiled contract on Flare.\n\n:::tip\n\nAll examples in this guide are available at [developer-hub/examples](https://github.com/flare-foundation/developer-hub/tree/main/examples).\n\n:::\n\nimport Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport FtsoV2FeedConsumerNoImports from \"!!raw-loader!/examples/developer-hub-solidity/FtsoV2FeedConsumer_no_imports.sol\";\nimport ChainIdCoston2 from \"!!raw-loader!/examples/developer-hub-go/coston2/chain_id.go\";\nimport ChainIdFlare from \"!!raw-loader!/examples/developer-hub-go/flare/chain_id.go\";\nimport MakeQueryCoston2 from \"!!raw-loader!/examples/developer-hub-go/coston2/make_query.go\";\nimport MakeQueryFlare from \"!!raw-loader!/examples/developer-hub-go/flare/make_query.go\";\nimport CreateAccount from \"!!raw-loader!/examples/developer-hub-go/create_account.go\";\nimport DeployContractCoston2 from \"!!raw-loader!/examples/developer-hub-go/coston2/deploy_contract.go\";\nimport DeployContractFlare from \"!!raw-loader!/examples/developer-hub-go/flare/deploy_contract.go\";\n\nThis guide is for developers who want to interact with Flare using Go. In this guide, using Go, you will learn how to:\n\n- Query a contract on Flare using the Go API for [Geth](https://github.com/ethereum/go-ethereum), a client that implements the full Ethereum JSON-RPC API.\n- Compile a Solidity contract using the CLI interface of [solc](https://github.com/ethereum/solidity), the Solidity compiler.\n- Deploy your compiled contract on Flare.\n\n:::tip\n\nAll examples in this guide are available at [developer-hub/examples](https://github.com/flare-foundation/developer-hub/tree/main/examples).\n\n:::",
    "file_name": "files/hub-docs/network/guides/flare-for-go-developers.mdx",
    "meta_data": {
      "slug": "flare-for-go-developers",
      "title": "Flare for Go Devs",
      "authors": [
        "dineshpinto"
      ],
      "tags": [
        "go",
        "quickstart",
        "solidity"
      ],
      "description": "Learn how to interact with Flare using geth.",
      "keywords": [
        "go",
        "quickstart",
        "solidity",
        "smart-contract",
        "flare-network"
      ],
      "sidebar_position": 5
    },
    "type": "answer"
  },
  {
    "content": "import Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport FtsoV2FeedConsumerNoImports from \"!!raw-loader!/examples/developer-hub-solidity/FtsoV2FeedConsumer_no_imports.sol\";\nimport ChainIdCoston2 from \"!!raw-loader!/examples/developer-hub-go/coston2/chain_id.go\";\nimport ChainIdFlare from \"!!raw-loader!/examples/developer-hub-go/flare/chain_id.go\";\nimport MakeQueryCoston2 from \"!!raw-loader!/examples/developer-hub-go/coston2/make_query.go\";\nimport MakeQueryFlare from \"!!raw-loader!/examples/developer-hub-go/flare/make_query.go\";\nimport CreateAccount from \"!!raw-loader!/examples/developer-hub-go/create_account.go\";\nimport DeployContractCoston2 from \"!!raw-loader!/examples/developer-hub-go/coston2/deploy_contract.go\";\nimport DeployContractFlare from \"!!raw-loader!/examples/developer-hub-go/flare/deploy_contract.go\";\n\nThis guide is for developers who want to interact with Flare using Go. In this guide, using Go, you will learn how to:\n\n- Query a contract on Flare using the Go API for [Geth](https://github.com/ethereum/go-ethereum), a client that implements the full Ethereum JSON-RPC API.\n- Compile a Solidity contract using the CLI interface of [solc](https://github.com/ethereum/solidity), the Solidity compiler.\n- Deploy your compiled contract on Flare.\n\n:::tip\n\nAll examples in this guide are available at [developer-hub/examples](https://github.com/flare-foundation/developer-hub/tree/main/examples).\n\n:::\n\nimport Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport FtsoV2FeedConsumerNoImports from \"!!raw-loader!/examples/developer-hub-solidity/FtsoV2FeedConsumer_no_imports.sol\";\nimport ChainIdCoston2 from \"!!raw-loader!/examples/developer-hub-go/coston2/chain_id.go\";\nimport ChainIdFlare from \"!!raw-loader!/examples/developer-hub-go/flare/chain_id.go\";\nimport MakeQueryCoston2 from \"!!raw-loader!/examples/developer-hub-go/coston2/make_query.go\";\nimport MakeQueryFlare from \"!!raw-loader!/examples/developer-hub-go/flare/make_query.go\";\nimport CreateAccount from \"!!raw-loader!/examples/developer-hub-go/create_account.go\";\nimport DeployContractCoston2 from \"!!raw-loader!/examples/developer-hub-go/coston2/deploy_contract.go\";\nimport DeployContractFlare from \"!!raw-loader!/examples/developer-hub-go/flare/deploy_contract.go\";\n\nThis guide is for developers who want to interact with Flare using Go. In this guide, using Go, you will learn how to:\n\n- Query a contract on Flare using the Go API for [Geth](https://github.com/ethereum/go-ethereum), a client that implements the full Ethereum JSON-RPC API.\n- Compile a Solidity contract using the CLI interface of [solc](https://github.com/ethereum/solidity), the Solidity compiler.\n- Deploy your compiled contract on Flare.\n\n:::tip\n\nAll examples in this guide are available at [developer-hub/examples](https://github.com/flare-foundation/developer-hub/tree/main/examples).\n\n:::\n\nimport Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport FtsoV2FeedConsumerNoImports from \"!!raw-loader!/examples/developer-hub-solidity/FtsoV2FeedConsumer_no_imports.sol\";\nimport ChainIdCoston2 from \"!!raw-loader!/examples/developer-hub-go/coston2/chain_id.go\";\nimport ChainIdFlare from \"!!raw-loader!/examples/developer-hub-go/flare/chain_id.go\";\nimport MakeQueryCoston2 from \"!!raw-loader!/examples/developer-hub-go/coston2/make_query.go\";\nimport MakeQueryFlare from \"!!raw-loader!/examples/developer-hub-go/flare/make_query.go\";\nimport CreateAccount from \"!!raw-loader!/examples/developer-hub-go/create_account.go\";\nimport DeployContractCoston2 from \"!!raw-loader!/examples/developer-hub-go/coston2/deploy_contract.go\";\nimport DeployContractFlare from \"!!raw-loader!/examples/developer-hub-go/flare/deploy_contract.go\";\n\nThis guide is for developers who want to interact with Flare using Go. In this guide, using Go, you will learn how to:\n\n- Query a contract on Flare using the Go API for [Geth](https://github.com/ethereum/go-ethereum), a client that implements the full Ethereum JSON-RPC API.\n- Compile a Solidity contract using the CLI interface of [solc](https://github.com/ethereum/solidity), the Solidity compiler.\n- Deploy your compiled contract on Flare.\n\n:::tip\n\nAll examples in this guide are available at [developer-hub/examples](https://github.com/flare-foundation/developer-hub/tree/main/examples).\n\n:::",
    "file_name": "files/hub-docs/network/guides/flare-for-go-developers.mdx",
    "meta_data": {
      "slug": "flare-for-go-developers",
      "title": "Flare for Go Devs",
      "authors": [
        "dineshpinto"
      ],
      "tags": [
        "go",
        "quickstart",
        "solidity"
      ],
      "description": "Learn how to interact with Flare using geth.",
      "keywords": [
        "go",
        "quickstart",
        "solidity",
        "smart-contract",
        "flare-network"
      ],
      "sidebar_position": 5
    },
    "type": "answer"
  },
  {
    "content": "Staking works by locking funds for a period of time to support a specific network validator. The guide details out how to stake using the [flare-stake-tool](https://github.com/flare-foundation/flare-stake-tool) CLI.\n\n<details>\n<summary>Understand staking on Flare.</summary>\n\nWhen validator owners stake to their own nodes they **self-bond**, whereas all other participants are said to **delegate** their stake to that validator.\nNote that delegating your stake to a validator is different from FTSO delegation.\n\nParticipants choose how much to stake and for how long their stake will be locked.\nThe minimum values are:\n\n|                  | Self-bond | Delegation |\n| ---------------- | --------: | ---------: |\n| Minimum amount   |    1M FLR |    50K FLR |\n| Minimum duration |   60 days |    14 days |\n\nAt the end of every reward epoch (i.e. 3.5 days on Flare Mainnet), participants are rewarded according to how well their chosen validator performed in that period.\n\n**Limits**\n\nThe amount that you can stake and the rewards you can gain by staking are restricted by these limits:\n\n- **Delegation factor**: Limits the total amount that can be staked to a validator to its self-bond, which is the amount validators stake to their own nodes, times the delegation factor, which is 15.\n  For example, if a validator has a self-bond stake of 1M FLR, the total sum of all stakes, including delegations, cannot exceed 15M FLR.\n  This limit allows for 14M FLR of delegations.\n\n- **Staking cap**: Limits the reward performance of individual validators to **5% of the total staked amount**.\n  If you stake your funds on a validator with more than 5% of the total staked amount, you receive less FLR in reward.\n  To maximize your reward, delegate your staking funds to a validator with less than 5% of the total staked amount of FLR.\n\n- **Maximum number of validators**: You can stake to any number of validators, but rewards, FlareDrops, and governance vote power only apply for up to 3 different validators.\n\nGiven that the Flare network uses two independent underlying chains, there is one extra step that must be considered.\nFunds must be transferred from the C-chain, where smart contracts run, to the P-chain, where staking happens.\nAfter the staking period expires and funds are unlocked, they can be transferred back to the C-chain.\n\n</details>\n\nStaking works by locking funds for a period of time to support a specific network validator. The guide details out how to stake using the [flare-stake-tool](https://github.com/flare-foundation/flare-stake-tool) CLI.\n\n<details>\n<summary>Understand staking on Flare.</summary>\n\nWhen validator owners stake to their own nodes they **self-bond**, whereas all other participants are said to **delegate** their stake to that validator.\nNote that delegating your stake to a validator is different from FTSO delegation.\n\nParticipants choose how much to stake and for how long their stake will be locked.\nThe minimum values are:\n\n|                  | Self-bond | Delegation |\n| ---------------- | --------: | ---------: |\n| Minimum amount   |    1M FLR |    50K FLR |\n| Minimum duration |   60 days |    14 days |\n\nAt the end of every reward epoch (i.e. 3.5 days on Flare Mainnet), participants are rewarded according to how well their chosen validator performed in that period.\n\n**Limits**\n\nThe amount that you can stake and the rewards you can gain by staking are restricted by these limits:\n\n- **Delegation factor**: Limits the total amount that can be staked to a validator to its self-bond, which is the amount validators stake to their own nodes, times the delegation factor, which is 15.\n  For example, if a validator has a self-bond stake of 1M FLR, the total sum of all stakes, including delegations, cannot exceed 15M FLR.\n  This limit allows for 14M FLR of delegations.\n\n- **Staking cap**: Limits the reward performance of individual validators to **5% of the total staked amount**.\n  If you stake your funds on a validator with more than 5% of the total staked amount, you receive less FLR in reward.\n  To maximize your reward, delegate your staking funds to a validator with less than 5% of the total staked amount of FLR.\n\n- **Maximum number of validators**: You can stake to any number of validators, but rewards, FlareDrops, and governance vote power only apply for up to 3 different validators.\n\nGiven that the Flare network uses two independent underlying chains, there is one extra step that must be considered.\nFunds must be transferred from the C-chain, where smart contracts run, to the P-chain, where staking happens.\nAfter the staking period expires and funds are unlocked, they can be transferred back to the C-chain.\n\n</details>",
    "file_name": "files/hub-docs/network/guides/using-flare-stake-tool.mdx",
    "meta_data": {
      "title": "Using Flare Stake Tool",
      "tags": [
        "intermediate",
        "solidity"
      ],
      "authors": [
        "dineshpinto"
      ],
      "description": "Stake FLR using flare-stake-tool CLI.",
      "keywords": [
        "intermediate",
        "solidity",
        "smart-contract",
        "flare-network"
      ],
      "sidebar_position": 8
    },
    "type": "answer"
  },
  {
    "content": "Staking works by locking funds for a period of time to support a specific network validator. The guide details out how to stake using the [flare-stake-tool](https://github.com/flare-foundation/flare-stake-tool) CLI.\n\n<details>\n<summary>Understand staking on Flare.</summary>\n\nWhen validator owners stake to their own nodes they **self-bond**, whereas all other participants are said to **delegate** their stake to that validator.\nNote that delegating your stake to a validator is different from FTSO delegation.\n\nParticipants choose how much to stake and for how long their stake will be locked.\nThe minimum values are:\n\n|                  | Self-bond | Delegation |\n| ---------------- | --------: | ---------: |\n| Minimum amount   |    1M FLR |    50K FLR |\n| Minimum duration |   60 days |    14 days |\n\nAt the end of every reward epoch (i.e. 3.5 days on Flare Mainnet), participants are rewarded according to how well their chosen validator performed in that period.\n\n**Limits**\n\nThe amount that you can stake and the rewards you can gain by staking are restricted by these limits:\n\n- **Delegation factor**: Limits the total amount that can be staked to a validator to its self-bond, which is the amount validators stake to their own nodes, times the delegation factor, which is 15.\n  For example, if a validator has a self-bond stake of 1M FLR, the total sum of all stakes, including delegations, cannot exceed 15M FLR.\n  This limit allows for 14M FLR of delegations.\n\n- **Staking cap**: Limits the reward performance of individual validators to **5% of the total staked amount**.\n  If you stake your funds on a validator with more than 5% of the total staked amount, you receive less FLR in reward.\n  To maximize your reward, delegate your staking funds to a validator with less than 5% of the total staked amount of FLR.\n\n- **Maximum number of validators**: You can stake to any number of validators, but rewards, FlareDrops, and governance vote power only apply for up to 3 different validators.\n\nGiven that the Flare network uses two independent underlying chains, there is one extra step that must be considered.\nFunds must be transferred from the C-chain, where smart contracts run, to the P-chain, where staking happens.\nAfter the staking period expires and funds are unlocked, they can be transferred back to the C-chain.\n\n</details>\n\nStaking works by locking funds for a period of time to support a specific network validator. The guide details out how to stake using the [flare-stake-tool](https://github.com/flare-foundation/flare-stake-tool) CLI.\n\n<details>\n<summary>Understand staking on Flare.</summary>\n\nWhen validator owners stake to their own nodes they **self-bond**, whereas all other participants are said to **delegate** their stake to that validator.\nNote that delegating your stake to a validator is different from FTSO delegation.\n\nParticipants choose how much to stake and for how long their stake will be locked.\nThe minimum values are:\n\n|                  | Self-bond | Delegation |\n| ---------------- | --------: | ---------: |\n| Minimum amount   |    1M FLR |    50K FLR |\n| Minimum duration |   60 days |    14 days |\n\nAt the end of every reward epoch (i.e. 3.5 days on Flare Mainnet), participants are rewarded according to how well their chosen validator performed in that period.\n\n**Limits**\n\nThe amount that you can stake and the rewards you can gain by staking are restricted by these limits:\n\n- **Delegation factor**: Limits the total amount that can be staked to a validator to its self-bond, which is the amount validators stake to their own nodes, times the delegation factor, which is 15.\n  For example, if a validator has a self-bond stake of 1M FLR, the total sum of all stakes, including delegations, cannot exceed 15M FLR.\n  This limit allows for 14M FLR of delegations.\n\n- **Staking cap**: Limits the reward performance of individual validators to **5% of the total staked amount**.\n  If you stake your funds on a validator with more than 5% of the total staked amount, you receive less FLR in reward.\n  To maximize your reward, delegate your staking funds to a validator with less than 5% of the total staked amount of FLR.\n\n- **Maximum number of validators**: You can stake to any number of validators, but rewards, FlareDrops, and governance vote power only apply for up to 3 different validators.\n\nGiven that the Flare network uses two independent underlying chains, there is one extra step that must be considered.\nFunds must be transferred from the C-chain, where smart contracts run, to the P-chain, where staking happens.\nAfter the staking period expires and funds are unlocked, they can be transferred back to the C-chain.\n\n</details>",
    "file_name": "files/hub-docs/network/guides/using-flare-stake-tool.mdx",
    "meta_data": {
      "title": "Using Flare Stake Tool",
      "tags": [
        "intermediate",
        "solidity"
      ],
      "authors": [
        "dineshpinto"
      ],
      "description": "Stake FLR using flare-stake-tool CLI.",
      "keywords": [
        "intermediate",
        "solidity",
        "smart-contract",
        "flare-network"
      ],
      "sidebar_position": 8
    },
    "type": "answer"
  },
  {
    "content": "Staking works by locking funds for a period of time to support a specific network validator. The guide details out how to stake using the [flare-stake-tool](https://github.com/flare-foundation/flare-stake-tool) CLI.\n\n<details>\n<summary>Understand staking on Flare.</summary>\n\nWhen validator owners stake to their own nodes they **self-bond**, whereas all other participants are said to **delegate** their stake to that validator.\nNote that delegating your stake to a validator is different from FTSO delegation.\n\nParticipants choose how much to stake and for how long their stake will be locked.\nThe minimum values are:\n\n|                  | Self-bond | Delegation |\n| ---------------- | --------: | ---------: |\n| Minimum amount   |    1M FLR |    50K FLR |\n| Minimum duration |   60 days |    14 days |\n\nAt the end of every reward epoch (i.e. 3.5 days on Flare Mainnet), participants are rewarded according to how well their chosen validator performed in that period.\n\n**Limits**\n\nThe amount that you can stake and the rewards you can gain by staking are restricted by these limits:\n\n- **Delegation factor**: Limits the total amount that can be staked to a validator to its self-bond, which is the amount validators stake to their own nodes, times the delegation factor, which is 15.\n  For example, if a validator has a self-bond stake of 1M FLR, the total sum of all stakes, including delegations, cannot exceed 15M FLR.\n  This limit allows for 14M FLR of delegations.\n\n- **Staking cap**: Limits the reward performance of individual validators to **5% of the total staked amount**.\n  If you stake your funds on a validator with more than 5% of the total staked amount, you receive less FLR in reward.\n  To maximize your reward, delegate your staking funds to a validator with less than 5% of the total staked amount of FLR.\n\n- **Maximum number of validators**: You can stake to any number of validators, but rewards, FlareDrops, and governance vote power only apply for up to 3 different validators.\n\nGiven that the Flare network uses two independent underlying chains, there is one extra step that must be considered.\nFunds must be transferred from the C-chain, where smart contracts run, to the P-chain, where staking happens.\nAfter the staking period expires and funds are unlocked, they can be transferred back to the C-chain.\n\n</details>\n\nStaking works by locking funds for a period of time to support a specific network validator. The guide details out how to stake using the [flare-stake-tool](https://github.com/flare-foundation/flare-stake-tool) CLI.\n\n<details>\n<summary>Understand staking on Flare.</summary>\n\nWhen validator owners stake to their own nodes they **self-bond**, whereas all other participants are said to **delegate** their stake to that validator.\nNote that delegating your stake to a validator is different from FTSO delegation.\n\nParticipants choose how much to stake and for how long their stake will be locked.\nThe minimum values are:\n\n|                  | Self-bond | Delegation |\n| ---------------- | --------: | ---------: |\n| Minimum amount   |    1M FLR |    50K FLR |\n| Minimum duration |   60 days |    14 days |\n\nAt the end of every reward epoch (i.e. 3.5 days on Flare Mainnet), participants are rewarded according to how well their chosen validator performed in that period.\n\n**Limits**\n\nThe amount that you can stake and the rewards you can gain by staking are restricted by these limits:\n\n- **Delegation factor**: Limits the total amount that can be staked to a validator to its self-bond, which is the amount validators stake to their own nodes, times the delegation factor, which is 15.\n  For example, if a validator has a self-bond stake of 1M FLR, the total sum of all stakes, including delegations, cannot exceed 15M FLR.\n  This limit allows for 14M FLR of delegations.\n\n- **Staking cap**: Limits the reward performance of individual validators to **5% of the total staked amount**.\n  If you stake your funds on a validator with more than 5% of the total staked amount, you receive less FLR in reward.\n  To maximize your reward, delegate your staking funds to a validator with less than 5% of the total staked amount of FLR.\n\n- **Maximum number of validators**: You can stake to any number of validators, but rewards, FlareDrops, and governance vote power only apply for up to 3 different validators.\n\nGiven that the Flare network uses two independent underlying chains, there is one extra step that must be considered.\nFunds must be transferred from the C-chain, where smart contracts run, to the P-chain, where staking happens.\nAfter the staking period expires and funds are unlocked, they can be transferred back to the C-chain.\n\n</details>",
    "file_name": "files/hub-docs/network/guides/using-flare-stake-tool.mdx",
    "meta_data": {
      "title": "Using Flare Stake Tool",
      "tags": [
        "intermediate",
        "solidity"
      ],
      "authors": [
        "dineshpinto"
      ],
      "description": "Stake FLR using flare-stake-tool CLI.",
      "keywords": [
        "intermediate",
        "solidity",
        "smart-contract",
        "flare-network"
      ],
      "sidebar_position": 8
    },
    "type": "answer"
  },
  {
    "content": "Staking works by locking funds for a period of time to support a specific network validator. The guide details out how to stake using the [flare-stake-tool](https://github.com/flare-foundation/flare-stake-tool) CLI.\n\n<details>\n<summary>Understand staking on Flare.</summary>\n\nWhen validator owners stake to their own nodes they **self-bond**, whereas all other participants are said to **delegate** their stake to that validator.\nNote that delegating your stake to a validator is different from FTSO delegation.\n\nParticipants choose how much to stake and for how long their stake will be locked.\nThe minimum values are:\n\n|                  | Self-bond | Delegation |\n| ---------------- | --------: | ---------: |\n| Minimum amount   |    1M FLR |    50K FLR |\n| Minimum duration |   60 days |    14 days |\n\nAt the end of every reward epoch (i.e. 3.5 days on Flare Mainnet), participants are rewarded according to how well their chosen validator performed in that period.\n\n**Limits**\n\nThe amount that you can stake and the rewards you can gain by staking are restricted by these limits:\n\n- **Delegation factor**: Limits the total amount that can be staked to a validator to its self-bond, which is the amount validators stake to their own nodes, times the delegation factor, which is 15.\n  For example, if a validator has a self-bond stake of 1M FLR, the total sum of all stakes, including delegations, cannot exceed 15M FLR.\n  This limit allows for 14M FLR of delegations.\n\n- **Staking cap**: Limits the reward performance of individual validators to **5% of the total staked amount**.\n  If you stake your funds on a validator with more than 5% of the total staked amount, you receive less FLR in reward.\n  To maximize your reward, delegate your staking funds to a validator with less than 5% of the total staked amount of FLR.\n\n- **Maximum number of validators**: You can stake to any number of validators, but rewards, FlareDrops, and governance vote power only apply for up to 3 different validators.\n\nGiven that the Flare network uses two independent underlying chains, there is one extra step that must be considered.\nFunds must be transferred from the C-chain, where smart contracts run, to the P-chain, where staking happens.\nAfter the staking period expires and funds are unlocked, they can be transferred back to the C-chain.\n\n</details>\n\nStaking works by locking funds for a period of time to support a specific network validator. The guide details out how to stake using the [flare-stake-tool](https://github.com/flare-foundation/flare-stake-tool) CLI.\n\n<details>\n<summary>Understand staking on Flare.</summary>\n\nWhen validator owners stake to their own nodes they **self-bond**, whereas all other participants are said to **delegate** their stake to that validator.\nNote that delegating your stake to a validator is different from FTSO delegation.\n\nParticipants choose how much to stake and for how long their stake will be locked.\nThe minimum values are:\n\n|                  | Self-bond | Delegation |\n| ---------------- | --------: | ---------: |\n| Minimum amount   |    1M FLR |    50K FLR |\n| Minimum duration |   60 days |    14 days |\n\nAt the end of every reward epoch (i.e. 3.5 days on Flare Mainnet), participants are rewarded according to how well their chosen validator performed in that period.\n\n**Limits**\n\nThe amount that you can stake and the rewards you can gain by staking are restricted by these limits:\n\n- **Delegation factor**: Limits the total amount that can be staked to a validator to its self-bond, which is the amount validators stake to their own nodes, times the delegation factor, which is 15.\n  For example, if a validator has a self-bond stake of 1M FLR, the total sum of all stakes, including delegations, cannot exceed 15M FLR.\n  This limit allows for 14M FLR of delegations.\n\n- **Staking cap**: Limits the reward performance of individual validators to **5% of the total staked amount**.\n  If you stake your funds on a validator with more than 5% of the total staked amount, you receive less FLR in reward.\n  To maximize your reward, delegate your staking funds to a validator with less than 5% of the total staked amount of FLR.\n\n- **Maximum number of validators**: You can stake to any number of validators, but rewards, FlareDrops, and governance vote power only apply for up to 3 different validators.\n\nGiven that the Flare network uses two independent underlying chains, there is one extra step that must be considered.\nFunds must be transferred from the C-chain, where smart contracts run, to the P-chain, where staking happens.\nAfter the staking period expires and funds are unlocked, they can be transferred back to the C-chain.\n\n</details>",
    "file_name": "files/hub-docs/network/guides/using-flare-stake-tool.mdx",
    "meta_data": {
      "title": "Using Flare Stake Tool",
      "tags": [
        "intermediate",
        "solidity"
      ],
      "authors": [
        "dineshpinto"
      ],
      "description": "Stake FLR using flare-stake-tool CLI.",
      "keywords": [
        "intermediate",
        "solidity",
        "smart-contract",
        "flare-network"
      ],
      "sidebar_position": 8
    },
    "type": "answer"
  },
  {
    "content": "Staking works by locking funds for a period of time to support a specific network validator. The guide details out how to stake using the [flare-stake-tool](https://github.com/flare-foundation/flare-stake-tool) CLI.\n\n<details>\n<summary>Understand staking on Flare.</summary>\n\nWhen validator owners stake to their own nodes they **self-bond**, whereas all other participants are said to **delegate** their stake to that validator.\nNote that delegating your stake to a validator is different from FTSO delegation.\n\nParticipants choose how much to stake and for how long their stake will be locked.\nThe minimum values are:\n\n|                  | Self-bond | Delegation |\n| ---------------- | --------: | ---------: |\n| Minimum amount   |    1M FLR |    50K FLR |\n| Minimum duration |   60 days |    14 days |\n\nAt the end of every reward epoch (i.e. 3.5 days on Flare Mainnet), participants are rewarded according to how well their chosen validator performed in that period.\n\n**Limits**\n\nThe amount that you can stake and the rewards you can gain by staking are restricted by these limits:\n\n- **Delegation factor**: Limits the total amount that can be staked to a validator to its self-bond, which is the amount validators stake to their own nodes, times the delegation factor, which is 15.\n  For example, if a validator has a self-bond stake of 1M FLR, the total sum of all stakes, including delegations, cannot exceed 15M FLR.\n  This limit allows for 14M FLR of delegations.\n\n- **Staking cap**: Limits the reward performance of individual validators to **5% of the total staked amount**.\n  If you stake your funds on a validator with more than 5% of the total staked amount, you receive less FLR in reward.\n  To maximize your reward, delegate your staking funds to a validator with less than 5% of the total staked amount of FLR.\n\n- **Maximum number of validators**: You can stake to any number of validators, but rewards, FlareDrops, and governance vote power only apply for up to 3 different validators.\n\nGiven that the Flare network uses two independent underlying chains, there is one extra step that must be considered.\nFunds must be transferred from the C-chain, where smart contracts run, to the P-chain, where staking happens.\nAfter the staking period expires and funds are unlocked, they can be transferred back to the C-chain.\n\n</details>",
    "file_name": "files/hub-docs/network/guides/using-flare-stake-tool.mdx",
    "meta_data": {
      "title": "Using Flare Stake Tool",
      "tags": [
        "intermediate",
        "solidity"
      ],
      "authors": [
        "dineshpinto"
      ],
      "description": "Stake FLR using flare-stake-tool CLI.",
      "keywords": [
        "intermediate",
        "solidity",
        "smart-contract",
        "flare-network"
      ],
      "sidebar_position": 8
    },
    "type": "answer"
  },
  {
    "content": "import Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport FtsoV2FeedConsumerNoImports from \"!!raw-loader!/examples/developer-hub-solidity/FtsoV2FeedConsumer_no_imports.sol\";\nimport ChainIdCoston2 from \"!!raw-loader!/examples/developer-hub-javascript/chain_id_coston2.js\";\nimport ChainIdFlare from \"!!raw-loader!/examples/developer-hub-javascript/chain_id_flare.js\";\nimport FetchAbiCoston2 from \"!!raw-loader!/examples/developer-hub-javascript/fetch_abi_coston2.js\";\nimport FetchAbiFlare from \"!!raw-loader!/examples/developer-hub-javascript/fetch_abi_flare.js\";\nimport MakeQueryCoston2 from \"!!raw-loader!/examples/developer-hub-javascript/make_query_coston2.js\";\nimport MakeQueryFlare from \"!!raw-loader!/examples/developer-hub-javascript/make_query_flare.js\";\nimport CreateAccount from \"!!raw-loader!/examples/developer-hub-javascript/create_account.js\";\nimport DeployContractCoston2 from \"!!raw-loader!/examples/developer-hub-javascript/deploy_contract_coston2.js\";\nimport DeployContractFlare from \"!!raw-loader!/examples/developer-hub-javascript/deploy_contract_flare.js\";\n\nThis guide is for developers who want to interact with Flare using JavaScript. In this guide, using JavaScript, you will learn how to:\n\n- Query a contract on Flare using [web3.js](https://github.com/web3/web3.js), an async/sync library for interacting with Ethereum-like chains.\n- Compile a Solidity contract using the CLI interface of [solc](https://github.com/ethereum/solidity), the Solidity compiler.\n- Deploy your compiled contract on Flare.\n\n:::tip\n\nAll examples in this guide are available at [developer-hub/examples](https://github.com/flare-foundation/developer-hub/tree/main/examples).\n\n:::\n\nimport Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport FtsoV2FeedConsumerNoImports from \"!!raw-loader!/examples/developer-hub-solidity/FtsoV2FeedConsumer_no_imports.sol\";\nimport ChainIdCoston2 from \"!!raw-loader!/examples/developer-hub-javascript/chain_id_coston2.js\";\nimport ChainIdFlare from \"!!raw-loader!/examples/developer-hub-javascript/chain_id_flare.js\";\nimport FetchAbiCoston2 from \"!!raw-loader!/examples/developer-hub-javascript/fetch_abi_coston2.js\";\nimport FetchAbiFlare from \"!!raw-loader!/examples/developer-hub-javascript/fetch_abi_flare.js\";\nimport MakeQueryCoston2 from \"!!raw-loader!/examples/developer-hub-javascript/make_query_coston2.js\";\nimport MakeQueryFlare from \"!!raw-loader!/examples/developer-hub-javascript/make_query_flare.js\";\nimport CreateAccount from \"!!raw-loader!/examples/developer-hub-javascript/create_account.js\";\nimport DeployContractCoston2 from \"!!raw-loader!/examples/developer-hub-javascript/deploy_contract_coston2.js\";\nimport DeployContractFlare from \"!!raw-loader!/examples/developer-hub-javascript/deploy_contract_flare.js\";\n\nThis guide is for developers who want to interact with Flare using JavaScript. In this guide, using JavaScript, you will learn how to:\n\n- Query a contract on Flare using [web3.js](https://github.com/web3/web3.js), an async/sync library for interacting with Ethereum-like chains.\n- Compile a Solidity contract using the CLI interface of [solc](https://github.com/ethereum/solidity), the Solidity compiler.\n- Deploy your compiled contract on Flare.\n\n:::tip\n\nAll examples in this guide are available at [developer-hub/examples](https://github.com/flare-foundation/developer-hub/tree/main/examples).\n\n:::",
    "file_name": "files/hub-docs/network/guides/flare-for-javascript-developers.mdx",
    "meta_data": {
      "slug": "flare-for-javascript-developers",
      "title": "Flare for JavaScript Devs",
      "authors": [
        "dineshpinto"
      ],
      "description": "Learn how to interact with Flare using web3.js.",
      "tags": [
        "javascript",
        "quickstart",
        "solidity"
      ],
      "keywords": [
        "javascript",
        "web3.js",
        "ethers.js",
        "quickstart",
        "solidity",
        "smart-contract",
        "flare-network"
      ],
      "sidebar_position": 2
    },
    "type": "answer"
  },
  {
    "content": "import Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport FtsoV2FeedConsumerNoImports from \"!!raw-loader!/examples/developer-hub-solidity/FtsoV2FeedConsumer_no_imports.sol\";\nimport ChainIdCoston2 from \"!!raw-loader!/examples/developer-hub-javascript/chain_id_coston2.js\";\nimport ChainIdFlare from \"!!raw-loader!/examples/developer-hub-javascript/chain_id_flare.js\";\nimport FetchAbiCoston2 from \"!!raw-loader!/examples/developer-hub-javascript/fetch_abi_coston2.js\";\nimport FetchAbiFlare from \"!!raw-loader!/examples/developer-hub-javascript/fetch_abi_flare.js\";\nimport MakeQueryCoston2 from \"!!raw-loader!/examples/developer-hub-javascript/make_query_coston2.js\";\nimport MakeQueryFlare from \"!!raw-loader!/examples/developer-hub-javascript/make_query_flare.js\";\nimport CreateAccount from \"!!raw-loader!/examples/developer-hub-javascript/create_account.js\";\nimport DeployContractCoston2 from \"!!raw-loader!/examples/developer-hub-javascript/deploy_contract_coston2.js\";\nimport DeployContractFlare from \"!!raw-loader!/examples/developer-hub-javascript/deploy_contract_flare.js\";\n\nThis guide is for developers who want to interact with Flare using JavaScript. In this guide, using JavaScript, you will learn how to:\n\n- Query a contract on Flare using [web3.js](https://github.com/web3/web3.js), an async/sync library for interacting with Ethereum-like chains.\n- Compile a Solidity contract using the CLI interface of [solc](https://github.com/ethereum/solidity), the Solidity compiler.\n- Deploy your compiled contract on Flare.\n\n:::tip\n\nAll examples in this guide are available at [developer-hub/examples](https://github.com/flare-foundation/developer-hub/tree/main/examples).\n\n:::\n\nimport Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport FtsoV2FeedConsumerNoImports from \"!!raw-loader!/examples/developer-hub-solidity/FtsoV2FeedConsumer_no_imports.sol\";\nimport ChainIdCoston2 from \"!!raw-loader!/examples/developer-hub-javascript/chain_id_coston2.js\";\nimport ChainIdFlare from \"!!raw-loader!/examples/developer-hub-javascript/chain_id_flare.js\";\nimport FetchAbiCoston2 from \"!!raw-loader!/examples/developer-hub-javascript/fetch_abi_coston2.js\";\nimport FetchAbiFlare from \"!!raw-loader!/examples/developer-hub-javascript/fetch_abi_flare.js\";\nimport MakeQueryCoston2 from \"!!raw-loader!/examples/developer-hub-javascript/make_query_coston2.js\";\nimport MakeQueryFlare from \"!!raw-loader!/examples/developer-hub-javascript/make_query_flare.js\";\nimport CreateAccount from \"!!raw-loader!/examples/developer-hub-javascript/create_account.js\";\nimport DeployContractCoston2 from \"!!raw-loader!/examples/developer-hub-javascript/deploy_contract_coston2.js\";\nimport DeployContractFlare from \"!!raw-loader!/examples/developer-hub-javascript/deploy_contract_flare.js\";\n\nThis guide is for developers who want to interact with Flare using JavaScript. In this guide, using JavaScript, you will learn how to:\n\n- Query a contract on Flare using [web3.js](https://github.com/web3/web3.js), an async/sync library for interacting with Ethereum-like chains.\n- Compile a Solidity contract using the CLI interface of [solc](https://github.com/ethereum/solidity), the Solidity compiler.\n- Deploy your compiled contract on Flare.\n\n:::tip\n\nAll examples in this guide are available at [developer-hub/examples](https://github.com/flare-foundation/developer-hub/tree/main/examples).\n\n:::",
    "file_name": "files/hub-docs/network/guides/flare-for-javascript-developers.mdx",
    "meta_data": {
      "slug": "flare-for-javascript-developers",
      "title": "Flare for JavaScript Devs",
      "authors": [
        "dineshpinto"
      ],
      "description": "Learn how to interact with Flare using web3.js.",
      "tags": [
        "javascript",
        "quickstart",
        "solidity"
      ],
      "keywords": [
        "javascript",
        "web3.js",
        "ethers.js",
        "quickstart",
        "solidity",
        "smart-contract",
        "flare-network"
      ],
      "sidebar_position": 2
    },
    "type": "answer"
  },
  {
    "content": "import Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport FtsoV2FeedConsumerNoImports from \"!!raw-loader!/examples/developer-hub-solidity/FtsoV2FeedConsumer_no_imports.sol\";\nimport ChainIdCoston2 from \"!!raw-loader!/examples/developer-hub-javascript/chain_id_coston2.js\";\nimport ChainIdFlare from \"!!raw-loader!/examples/developer-hub-javascript/chain_id_flare.js\";\nimport FetchAbiCoston2 from \"!!raw-loader!/examples/developer-hub-javascript/fetch_abi_coston2.js\";\nimport FetchAbiFlare from \"!!raw-loader!/examples/developer-hub-javascript/fetch_abi_flare.js\";\nimport MakeQueryCoston2 from \"!!raw-loader!/examples/developer-hub-javascript/make_query_coston2.js\";\nimport MakeQueryFlare from \"!!raw-loader!/examples/developer-hub-javascript/make_query_flare.js\";\nimport CreateAccount from \"!!raw-loader!/examples/developer-hub-javascript/create_account.js\";\nimport DeployContractCoston2 from \"!!raw-loader!/examples/developer-hub-javascript/deploy_contract_coston2.js\";\nimport DeployContractFlare from \"!!raw-loader!/examples/developer-hub-javascript/deploy_contract_flare.js\";\n\nThis guide is for developers who want to interact with Flare using JavaScript. In this guide, using JavaScript, you will learn how to:\n\n- Query a contract on Flare using [web3.js](https://github.com/web3/web3.js), an async/sync library for interacting with Ethereum-like chains.\n- Compile a Solidity contract using the CLI interface of [solc](https://github.com/ethereum/solidity), the Solidity compiler.\n- Deploy your compiled contract on Flare.\n\n:::tip\n\nAll examples in this guide are available at [developer-hub/examples](https://github.com/flare-foundation/developer-hub/tree/main/examples).\n\n:::\n\nimport Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport FtsoV2FeedConsumerNoImports from \"!!raw-loader!/examples/developer-hub-solidity/FtsoV2FeedConsumer_no_imports.sol\";\nimport ChainIdCoston2 from \"!!raw-loader!/examples/developer-hub-javascript/chain_id_coston2.js\";\nimport ChainIdFlare from \"!!raw-loader!/examples/developer-hub-javascript/chain_id_flare.js\";\nimport FetchAbiCoston2 from \"!!raw-loader!/examples/developer-hub-javascript/fetch_abi_coston2.js\";\nimport FetchAbiFlare from \"!!raw-loader!/examples/developer-hub-javascript/fetch_abi_flare.js\";\nimport MakeQueryCoston2 from \"!!raw-loader!/examples/developer-hub-javascript/make_query_coston2.js\";\nimport MakeQueryFlare from \"!!raw-loader!/examples/developer-hub-javascript/make_query_flare.js\";\nimport CreateAccount from \"!!raw-loader!/examples/developer-hub-javascript/create_account.js\";\nimport DeployContractCoston2 from \"!!raw-loader!/examples/developer-hub-javascript/deploy_contract_coston2.js\";\nimport DeployContractFlare from \"!!raw-loader!/examples/developer-hub-javascript/deploy_contract_flare.js\";\n\nThis guide is for developers who want to interact with Flare using JavaScript. In this guide, using JavaScript, you will learn how to:\n\n- Query a contract on Flare using [web3.js](https://github.com/web3/web3.js), an async/sync library for interacting with Ethereum-like chains.\n- Compile a Solidity contract using the CLI interface of [solc](https://github.com/ethereum/solidity), the Solidity compiler.\n- Deploy your compiled contract on Flare.\n\n:::tip\n\nAll examples in this guide are available at [developer-hub/examples](https://github.com/flare-foundation/developer-hub/tree/main/examples).\n\n:::",
    "file_name": "files/hub-docs/network/guides/flare-for-javascript-developers.mdx",
    "meta_data": {
      "slug": "flare-for-javascript-developers",
      "title": "Flare for JavaScript Devs",
      "authors": [
        "dineshpinto"
      ],
      "description": "Learn how to interact with Flare using web3.js.",
      "tags": [
        "javascript",
        "quickstart",
        "solidity"
      ],
      "keywords": [
        "javascript",
        "web3.js",
        "ethers.js",
        "quickstart",
        "solidity",
        "smart-contract",
        "flare-network"
      ],
      "sidebar_position": 2
    },
    "type": "answer"
  },
  {
    "content": "import Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport FtsoV2FeedConsumerNoImports from \"!!raw-loader!/examples/developer-hub-solidity/FtsoV2FeedConsumer_no_imports.sol\";\nimport ChainIdCoston2 from \"!!raw-loader!/examples/developer-hub-rust/src/bin/chain_id_coston2.rs\";\nimport ChainIdFlare from \"!!raw-loader!/examples/developer-hub-rust/src/bin/chain_id_flare.rs\";\nimport CreateAccount from \"!!raw-loader!/examples/developer-hub-rust/src/bin/create_account.rs\";\nimport MakeQueryCoston2 from \"!!raw-loader!/examples/developer-hub-rust/src/bin/make_query_coston2.rs\";\nimport MakeQueryFlare from \"!!raw-loader!/examples/developer-hub-rust/src/bin/make_query_flare.rs\";\nimport DeployContractCoston2 from \"!!raw-loader!/examples/developer-hub-rust/src/bin/deploy_contract_coston2.rs\";\nimport DeployContractFlare from \"!!raw-loader!/examples/developer-hub-rust/src/bin/deploy_contract_flare.rs\";\nimport Config from \"!!raw-loader!/examples/developer-hub-rust/config.json\";\n\nThis guide is for developers who want to interact with Flare using Rust. In this guide, using Rust, you will learn how to:\n\n- Query a contract on Flare using [alloy-rs](https://github.com/alloy-rs), an async library for interacting with Ethereum-like chains.\n- Compile a Solidity contract using the CLI interface of [solc](https://github.com/ethereum/solidity), the Solidity compiler.\n- Deploy your compiled contract on Flare.\n\n:::tip\n\nAll examples in this guide are available at [developer-hub/examples](https://github.com/flare-foundation/developer-hub/tree/main/examples).\n\n:::\n\nimport Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport FtsoV2FeedConsumerNoImports from \"!!raw-loader!/examples/developer-hub-solidity/FtsoV2FeedConsumer_no_imports.sol\";\nimport ChainIdCoston2 from \"!!raw-loader!/examples/developer-hub-rust/src/bin/chain_id_coston2.rs\";\nimport ChainIdFlare from \"!!raw-loader!/examples/developer-hub-rust/src/bin/chain_id_flare.rs\";\nimport CreateAccount from \"!!raw-loader!/examples/developer-hub-rust/src/bin/create_account.rs\";\nimport MakeQueryCoston2 from \"!!raw-loader!/examples/developer-hub-rust/src/bin/make_query_coston2.rs\";\nimport MakeQueryFlare from \"!!raw-loader!/examples/developer-hub-rust/src/bin/make_query_flare.rs\";\nimport DeployContractCoston2 from \"!!raw-loader!/examples/developer-hub-rust/src/bin/deploy_contract_coston2.rs\";\nimport DeployContractFlare from \"!!raw-loader!/examples/developer-hub-rust/src/bin/deploy_contract_flare.rs\";\nimport Config from \"!!raw-loader!/examples/developer-hub-rust/config.json\";\n\nThis guide is for developers who want to interact with Flare using Rust. In this guide, using Rust, you will learn how to:\n\n- Query a contract on Flare using [alloy-rs](https://github.com/alloy-rs), an async library for interacting with Ethereum-like chains.\n- Compile a Solidity contract using the CLI interface of [solc](https://github.com/ethereum/solidity), the Solidity compiler.\n- Deploy your compiled contract on Flare.\n\n:::tip\n\nAll examples in this guide are available at [developer-hub/examples](https://github.com/flare-foundation/developer-hub/tree/main/examples).\n\n:::\n\nimport Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport FtsoV2FeedConsumerNoImports from \"!!raw-loader!/examples/developer-hub-solidity/FtsoV2FeedConsumer_no_imports.sol\";\nimport ChainIdCoston2 from \"!!raw-loader!/examples/developer-hub-rust/src/bin/chain_id_coston2.rs\";\nimport ChainIdFlare from \"!!raw-loader!/examples/developer-hub-rust/src/bin/chain_id_flare.rs\";\nimport CreateAccount from \"!!raw-loader!/examples/developer-hub-rust/src/bin/create_account.rs\";\nimport MakeQueryCoston2 from \"!!raw-loader!/examples/developer-hub-rust/src/bin/make_query_coston2.rs\";\nimport MakeQueryFlare from \"!!raw-loader!/examples/developer-hub-rust/src/bin/make_query_flare.rs\";\nimport DeployContractCoston2 from \"!!raw-loader!/examples/developer-hub-rust/src/bin/deploy_contract_coston2.rs\";\nimport DeployContractFlare from \"!!raw-loader!/examples/developer-hub-rust/src/bin/deploy_contract_flare.rs\";\nimport Config from \"!!raw-loader!/examples/developer-hub-rust/config.json\";\n\nThis guide is for developers who want to interact with Flare using Rust. In this guide, using Rust, you will learn how to:\n\n- Query a contract on Flare using [alloy-rs](https://github.com/alloy-rs), an async library for interacting with Ethereum-like chains.\n- Compile a Solidity contract using the CLI interface of [solc](https://github.com/ethereum/solidity), the Solidity compiler.\n- Deploy your compiled contract on Flare.\n\n:::tip\n\nAll examples in this guide are available at [developer-hub/examples](https://github.com/flare-foundation/developer-hub/tree/main/examples).\n\n:::",
    "file_name": "files/hub-docs/network/guides/flare-for-rust-developers.mdx",
    "meta_data": {
      "slug": "flare-for-rust-developers",
      "title": "Flare for Rust Devs",
      "authors": [
        "dineshpinto"
      ],
      "description": "Learn how to interact with Flare using alloy-rs.",
      "tags": [
        "rust",
        "quickstart",
        "solidity"
      ],
      "keywords": [
        "rust",
        "alloy-rs",
        "quickstart",
        "solidity",
        "smart-contract",
        "flare-network"
      ],
      "sidebar_position": 4
    },
    "type": "answer"
  },
  {
    "content": "import Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport FtsoV2FeedConsumerNoImports from \"!!raw-loader!/examples/developer-hub-solidity/FtsoV2FeedConsumer_no_imports.sol\";\nimport ChainIdCoston2 from \"!!raw-loader!/examples/developer-hub-rust/src/bin/chain_id_coston2.rs\";\nimport ChainIdFlare from \"!!raw-loader!/examples/developer-hub-rust/src/bin/chain_id_flare.rs\";\nimport CreateAccount from \"!!raw-loader!/examples/developer-hub-rust/src/bin/create_account.rs\";\nimport MakeQueryCoston2 from \"!!raw-loader!/examples/developer-hub-rust/src/bin/make_query_coston2.rs\";\nimport MakeQueryFlare from \"!!raw-loader!/examples/developer-hub-rust/src/bin/make_query_flare.rs\";\nimport DeployContractCoston2 from \"!!raw-loader!/examples/developer-hub-rust/src/bin/deploy_contract_coston2.rs\";\nimport DeployContractFlare from \"!!raw-loader!/examples/developer-hub-rust/src/bin/deploy_contract_flare.rs\";\nimport Config from \"!!raw-loader!/examples/developer-hub-rust/config.json\";\n\nThis guide is for developers who want to interact with Flare using Rust. In this guide, using Rust, you will learn how to:\n\n- Query a contract on Flare using [alloy-rs](https://github.com/alloy-rs), an async library for interacting with Ethereum-like chains.\n- Compile a Solidity contract using the CLI interface of [solc](https://github.com/ethereum/solidity), the Solidity compiler.\n- Deploy your compiled contract on Flare.\n\n:::tip\n\nAll examples in this guide are available at [developer-hub/examples](https://github.com/flare-foundation/developer-hub/tree/main/examples).\n\n:::\n\nimport Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport FtsoV2FeedConsumerNoImports from \"!!raw-loader!/examples/developer-hub-solidity/FtsoV2FeedConsumer_no_imports.sol\";\nimport ChainIdCoston2 from \"!!raw-loader!/examples/developer-hub-rust/src/bin/chain_id_coston2.rs\";\nimport ChainIdFlare from \"!!raw-loader!/examples/developer-hub-rust/src/bin/chain_id_flare.rs\";\nimport CreateAccount from \"!!raw-loader!/examples/developer-hub-rust/src/bin/create_account.rs\";\nimport MakeQueryCoston2 from \"!!raw-loader!/examples/developer-hub-rust/src/bin/make_query_coston2.rs\";\nimport MakeQueryFlare from \"!!raw-loader!/examples/developer-hub-rust/src/bin/make_query_flare.rs\";\nimport DeployContractCoston2 from \"!!raw-loader!/examples/developer-hub-rust/src/bin/deploy_contract_coston2.rs\";\nimport DeployContractFlare from \"!!raw-loader!/examples/developer-hub-rust/src/bin/deploy_contract_flare.rs\";\nimport Config from \"!!raw-loader!/examples/developer-hub-rust/config.json\";\n\nThis guide is for developers who want to interact with Flare using Rust. In this guide, using Rust, you will learn how to:\n\n- Query a contract on Flare using [alloy-rs](https://github.com/alloy-rs), an async library for interacting with Ethereum-like chains.\n- Compile a Solidity contract using the CLI interface of [solc](https://github.com/ethereum/solidity), the Solidity compiler.\n- Deploy your compiled contract on Flare.\n\n:::tip\n\nAll examples in this guide are available at [developer-hub/examples](https://github.com/flare-foundation/developer-hub/tree/main/examples).\n\n:::\n\nimport Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport FtsoV2FeedConsumerNoImports from \"!!raw-loader!/examples/developer-hub-solidity/FtsoV2FeedConsumer_no_imports.sol\";\nimport ChainIdCoston2 from \"!!raw-loader!/examples/developer-hub-rust/src/bin/chain_id_coston2.rs\";\nimport ChainIdFlare from \"!!raw-loader!/examples/developer-hub-rust/src/bin/chain_id_flare.rs\";\nimport CreateAccount from \"!!raw-loader!/examples/developer-hub-rust/src/bin/create_account.rs\";\nimport MakeQueryCoston2 from \"!!raw-loader!/examples/developer-hub-rust/src/bin/make_query_coston2.rs\";\nimport MakeQueryFlare from \"!!raw-loader!/examples/developer-hub-rust/src/bin/make_query_flare.rs\";\nimport DeployContractCoston2 from \"!!raw-loader!/examples/developer-hub-rust/src/bin/deploy_contract_coston2.rs\";\nimport DeployContractFlare from \"!!raw-loader!/examples/developer-hub-rust/src/bin/deploy_contract_flare.rs\";\nimport Config from \"!!raw-loader!/examples/developer-hub-rust/config.json\";\n\nThis guide is for developers who want to interact with Flare using Rust. In this guide, using Rust, you will learn how to:\n\n- Query a contract on Flare using [alloy-rs](https://github.com/alloy-rs), an async library for interacting with Ethereum-like chains.\n- Compile a Solidity contract using the CLI interface of [solc](https://github.com/ethereum/solidity), the Solidity compiler.\n- Deploy your compiled contract on Flare.\n\n:::tip\n\nAll examples in this guide are available at [developer-hub/examples](https://github.com/flare-foundation/developer-hub/tree/main/examples).\n\n:::",
    "file_name": "files/hub-docs/network/guides/flare-for-rust-developers.mdx",
    "meta_data": {
      "slug": "flare-for-rust-developers",
      "title": "Flare for Rust Devs",
      "authors": [
        "dineshpinto"
      ],
      "description": "Learn how to interact with Flare using alloy-rs.",
      "tags": [
        "rust",
        "quickstart",
        "solidity"
      ],
      "keywords": [
        "rust",
        "alloy-rs",
        "quickstart",
        "solidity",
        "smart-contract",
        "flare-network"
      ],
      "sidebar_position": 4
    },
    "type": "answer"
  },
  {
    "content": "import Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport FtsoV2FeedConsumerNoImports from \"!!raw-loader!/examples/developer-hub-solidity/FtsoV2FeedConsumer_no_imports.sol\";\nimport ChainIdCoston2 from \"!!raw-loader!/examples/developer-hub-python/chain_id_coston2.py\";\nimport ChainIdFlare from \"!!raw-loader!/examples/developer-hub-python/chain_id_flare.py\";\nimport FetchAbiCoston2 from \"!!raw-loader!/examples/developer-hub-python/fetch_abi_coston2.py\";\nimport FetchAbiFlare from \"!!raw-loader!/examples/developer-hub-python/fetch_abi_flare.py\";\nimport MakeQueryCoston2 from \"!!raw-loader!/examples/developer-hub-python/make_query_coston2.py\";\nimport MakeQueryFlare from \"!!raw-loader!/examples/developer-hub-python/make_query_flare.py\";\nimport CreateAccount from \"!!raw-loader!/examples/developer-hub-python/create_account.py\";\nimport DeployContractCoston2 from \"!!raw-loader!/examples/developer-hub-python/deploy_contract_coston2.py\";\nimport DeployContractFlare from \"!!raw-loader!/examples/developer-hub-python/deploy_contract_flare.py\";\nimport Utils from \"!!raw-loader!/examples/developer-hub-python/utils.py\";\nimport CompileContract from \"!!raw-loader!/examples/developer-hub-python/compile_contract.py\";\n\nThis guide is for developers who want to interact with Flare using Python. In this guide, using Python, you will learn how to:\n\n- Query a contract on Flare using [web3.py](https://github.com/ethereum/web3.py), an async/sync library for interacting with Ethereum-like chains.\n- Compile a Solidity contract using [py-solc-x](https://github.com/ApeWorX/py-solc-x), a wrapper around the Solidity compiler.\n- Deploy your compiled contract on Flare.\n\n:::tip\n\nAll examples in this guide are available at [developer-hub/examples](https://github.com/flare-foundation/developer-hub/tree/main/examples).\n\n:::\n\nimport Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport FtsoV2FeedConsumerNoImports from \"!!raw-loader!/examples/developer-hub-solidity/FtsoV2FeedConsumer_no_imports.sol\";\nimport ChainIdCoston2 from \"!!raw-loader!/examples/developer-hub-python/chain_id_coston2.py\";\nimport ChainIdFlare from \"!!raw-loader!/examples/developer-hub-python/chain_id_flare.py\";\nimport FetchAbiCoston2 from \"!!raw-loader!/examples/developer-hub-python/fetch_abi_coston2.py\";\nimport FetchAbiFlare from \"!!raw-loader!/examples/developer-hub-python/fetch_abi_flare.py\";\nimport MakeQueryCoston2 from \"!!raw-loader!/examples/developer-hub-python/make_query_coston2.py\";\nimport MakeQueryFlare from \"!!raw-loader!/examples/developer-hub-python/make_query_flare.py\";\nimport CreateAccount from \"!!raw-loader!/examples/developer-hub-python/create_account.py\";\nimport DeployContractCoston2 from \"!!raw-loader!/examples/developer-hub-python/deploy_contract_coston2.py\";\nimport DeployContractFlare from \"!!raw-loader!/examples/developer-hub-python/deploy_contract_flare.py\";\nimport Utils from \"!!raw-loader!/examples/developer-hub-python/utils.py\";\nimport CompileContract from \"!!raw-loader!/examples/developer-hub-python/compile_contract.py\";\n\nThis guide is for developers who want to interact with Flare using Python. In this guide, using Python, you will learn how to:\n\n- Query a contract on Flare using [web3.py](https://github.com/ethereum/web3.py), an async/sync library for interacting with Ethereum-like chains.\n- Compile a Solidity contract using [py-solc-x](https://github.com/ApeWorX/py-solc-x), a wrapper around the Solidity compiler.\n- Deploy your compiled contract on Flare.\n\n:::tip\n\nAll examples in this guide are available at [developer-hub/examples](https://github.com/flare-foundation/developer-hub/tree/main/examples).\n\n:::",
    "file_name": "files/hub-docs/network/guides/flare-for-python-developers.mdx",
    "meta_data": {
      "slug": "flare-for-python-developers",
      "title": "Flare for Python Devs",
      "authors": [
        "dineshpinto"
      ],
      "description": "Learn how to interact with Flare using web3.py.",
      "tags": [
        "python",
        "quickstart",
        "solidity"
      ],
      "keywords": [
        "python",
        "web3.py",
        "quickstart",
        "solidity",
        "smart-contract",
        "flare-network"
      ],
      "sidebar_position": 3
    },
    "type": "answer"
  },
  {
    "content": "import Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport FtsoV2FeedConsumerNoImports from \"!!raw-loader!/examples/developer-hub-solidity/FtsoV2FeedConsumer_no_imports.sol\";\nimport ChainIdCoston2 from \"!!raw-loader!/examples/developer-hub-python/chain_id_coston2.py\";\nimport ChainIdFlare from \"!!raw-loader!/examples/developer-hub-python/chain_id_flare.py\";\nimport FetchAbiCoston2 from \"!!raw-loader!/examples/developer-hub-python/fetch_abi_coston2.py\";\nimport FetchAbiFlare from \"!!raw-loader!/examples/developer-hub-python/fetch_abi_flare.py\";\nimport MakeQueryCoston2 from \"!!raw-loader!/examples/developer-hub-python/make_query_coston2.py\";\nimport MakeQueryFlare from \"!!raw-loader!/examples/developer-hub-python/make_query_flare.py\";\nimport CreateAccount from \"!!raw-loader!/examples/developer-hub-python/create_account.py\";\nimport DeployContractCoston2 from \"!!raw-loader!/examples/developer-hub-python/deploy_contract_coston2.py\";\nimport DeployContractFlare from \"!!raw-loader!/examples/developer-hub-python/deploy_contract_flare.py\";\nimport Utils from \"!!raw-loader!/examples/developer-hub-python/utils.py\";\nimport CompileContract from \"!!raw-loader!/examples/developer-hub-python/compile_contract.py\";\n\nThis guide is for developers who want to interact with Flare using Python. In this guide, using Python, you will learn how to:\n\n- Query a contract on Flare using [web3.py](https://github.com/ethereum/web3.py), an async/sync library for interacting with Ethereum-like chains.\n- Compile a Solidity contract using [py-solc-x](https://github.com/ApeWorX/py-solc-x), a wrapper around the Solidity compiler.\n- Deploy your compiled contract on Flare.\n\n:::tip\n\nAll examples in this guide are available at [developer-hub/examples](https://github.com/flare-foundation/developer-hub/tree/main/examples).\n\n:::\n\nimport Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport FtsoV2FeedConsumerNoImports from \"!!raw-loader!/examples/developer-hub-solidity/FtsoV2FeedConsumer_no_imports.sol\";\nimport ChainIdCoston2 from \"!!raw-loader!/examples/developer-hub-python/chain_id_coston2.py\";\nimport ChainIdFlare from \"!!raw-loader!/examples/developer-hub-python/chain_id_flare.py\";\nimport FetchAbiCoston2 from \"!!raw-loader!/examples/developer-hub-python/fetch_abi_coston2.py\";\nimport FetchAbiFlare from \"!!raw-loader!/examples/developer-hub-python/fetch_abi_flare.py\";\nimport MakeQueryCoston2 from \"!!raw-loader!/examples/developer-hub-python/make_query_coston2.py\";\nimport MakeQueryFlare from \"!!raw-loader!/examples/developer-hub-python/make_query_flare.py\";\nimport CreateAccount from \"!!raw-loader!/examples/developer-hub-python/create_account.py\";\nimport DeployContractCoston2 from \"!!raw-loader!/examples/developer-hub-python/deploy_contract_coston2.py\";\nimport DeployContractFlare from \"!!raw-loader!/examples/developer-hub-python/deploy_contract_flare.py\";\nimport Utils from \"!!raw-loader!/examples/developer-hub-python/utils.py\";\nimport CompileContract from \"!!raw-loader!/examples/developer-hub-python/compile_contract.py\";\n\nThis guide is for developers who want to interact with Flare using Python. In this guide, using Python, you will learn how to:\n\n- Query a contract on Flare using [web3.py](https://github.com/ethereum/web3.py), an async/sync library for interacting with Ethereum-like chains.\n- Compile a Solidity contract using [py-solc-x](https://github.com/ApeWorX/py-solc-x), a wrapper around the Solidity compiler.\n- Deploy your compiled contract on Flare.\n\n:::tip\n\nAll examples in this guide are available at [developer-hub/examples](https://github.com/flare-foundation/developer-hub/tree/main/examples).\n\n:::",
    "file_name": "files/hub-docs/network/guides/flare-for-python-developers.mdx",
    "meta_data": {
      "slug": "flare-for-python-developers",
      "title": "Flare for Python Devs",
      "authors": [
        "dineshpinto"
      ],
      "description": "Learn how to interact with Flare using web3.py.",
      "tags": [
        "python",
        "quickstart",
        "solidity"
      ],
      "keywords": [
        "python",
        "web3.py",
        "quickstart",
        "solidity",
        "smart-contract",
        "flare-network"
      ],
      "sidebar_position": 3
    },
    "type": "answer"
  },
  {
    "content": "import Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport FtsoV2FeedConsumerNoImports from \"!!raw-loader!/examples/developer-hub-solidity/FtsoV2FeedConsumer_no_imports.sol\";\nimport ChainIdCoston2 from \"!!raw-loader!/examples/developer-hub-python/chain_id_coston2.py\";\nimport ChainIdFlare from \"!!raw-loader!/examples/developer-hub-python/chain_id_flare.py\";\nimport FetchAbiCoston2 from \"!!raw-loader!/examples/developer-hub-python/fetch_abi_coston2.py\";\nimport FetchAbiFlare from \"!!raw-loader!/examples/developer-hub-python/fetch_abi_flare.py\";\nimport MakeQueryCoston2 from \"!!raw-loader!/examples/developer-hub-python/make_query_coston2.py\";\nimport MakeQueryFlare from \"!!raw-loader!/examples/developer-hub-python/make_query_flare.py\";\nimport CreateAccount from \"!!raw-loader!/examples/developer-hub-python/create_account.py\";\nimport DeployContractCoston2 from \"!!raw-loader!/examples/developer-hub-python/deploy_contract_coston2.py\";\nimport DeployContractFlare from \"!!raw-loader!/examples/developer-hub-python/deploy_contract_flare.py\";\nimport Utils from \"!!raw-loader!/examples/developer-hub-python/utils.py\";\nimport CompileContract from \"!!raw-loader!/examples/developer-hub-python/compile_contract.py\";\n\nThis guide is for developers who want to interact with Flare using Python. In this guide, using Python, you will learn how to:\n\n- Query a contract on Flare using [web3.py](https://github.com/ethereum/web3.py), an async/sync library for interacting with Ethereum-like chains.\n- Compile a Solidity contract using [py-solc-x](https://github.com/ApeWorX/py-solc-x), a wrapper around the Solidity compiler.\n- Deploy your compiled contract on Flare.\n\n:::tip\n\nAll examples in this guide are available at [developer-hub/examples](https://github.com/flare-foundation/developer-hub/tree/main/examples).\n\n:::\n\nimport Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport FtsoV2FeedConsumerNoImports from \"!!raw-loader!/examples/developer-hub-solidity/FtsoV2FeedConsumer_no_imports.sol\";\nimport ChainIdCoston2 from \"!!raw-loader!/examples/developer-hub-python/chain_id_coston2.py\";\nimport ChainIdFlare from \"!!raw-loader!/examples/developer-hub-python/chain_id_flare.py\";\nimport FetchAbiCoston2 from \"!!raw-loader!/examples/developer-hub-python/fetch_abi_coston2.py\";\nimport FetchAbiFlare from \"!!raw-loader!/examples/developer-hub-python/fetch_abi_flare.py\";\nimport MakeQueryCoston2 from \"!!raw-loader!/examples/developer-hub-python/make_query_coston2.py\";\nimport MakeQueryFlare from \"!!raw-loader!/examples/developer-hub-python/make_query_flare.py\";\nimport CreateAccount from \"!!raw-loader!/examples/developer-hub-python/create_account.py\";\nimport DeployContractCoston2 from \"!!raw-loader!/examples/developer-hub-python/deploy_contract_coston2.py\";\nimport DeployContractFlare from \"!!raw-loader!/examples/developer-hub-python/deploy_contract_flare.py\";\nimport Utils from \"!!raw-loader!/examples/developer-hub-python/utils.py\";\nimport CompileContract from \"!!raw-loader!/examples/developer-hub-python/compile_contract.py\";\n\nThis guide is for developers who want to interact with Flare using Python. In this guide, using Python, you will learn how to:\n\n- Query a contract on Flare using [web3.py](https://github.com/ethereum/web3.py), an async/sync library for interacting with Ethereum-like chains.\n- Compile a Solidity contract using [py-solc-x](https://github.com/ApeWorX/py-solc-x), a wrapper around the Solidity compiler.\n- Deploy your compiled contract on Flare.\n\n:::tip\n\nAll examples in this guide are available at [developer-hub/examples](https://github.com/flare-foundation/developer-hub/tree/main/examples).\n\n:::",
    "file_name": "files/hub-docs/network/guides/flare-for-python-developers.mdx",
    "meta_data": {
      "slug": "flare-for-python-developers",
      "title": "Flare for Python Devs",
      "authors": [
        "dineshpinto"
      ],
      "description": "Learn how to interact with Flare using web3.py.",
      "tags": [
        "python",
        "quickstart",
        "solidity"
      ],
      "keywords": [
        "python",
        "web3.py",
        "quickstart",
        "solidity",
        "smart-contract",
        "flare-network"
      ],
      "sidebar_position": 3
    },
    "type": "answer"
  },
  {
    "content": "import TabItem from \"@theme/TabItem\";\nimport Tabs from \"@theme/Tabs\";\nimport Remix from \"@site/src/components/remix\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport SecureRandomConsumer from \"!!raw-loader!/examples/developer-hub-solidity/SecureRandomConsumer.sol\";\nimport SetEvmVersionRemix from \"/static/img/set-evm-version-remix.png\";\nimport SecureRandomWeb3Js from \"!!raw-loader!/examples/developer-hub-javascript/secure_random_coston2_web3.js\";\nimport SecureRandomEthersJs from \"!!raw-loader!/examples/developer-hub-javascript/secure_random_coston2_ethers.js\";\nimport SecureRandomWeb3Py from \"!!raw-loader!/examples/developer-hub-python/secure_random_coston2.py\";\nimport SecureRandomRust from \"!!raw-loader!/examples/developer-hub-rust/src/bin/secure_random_coston2.rs\";\nimport SecureRandomGo from \"!!raw-loader!/examples/developer-hub-go/coston2/secure_random.go\";\nimport RandomNumberV2Lottery from \"!!raw-loader!/examples/developer-hub-solidity/RandomNumberV2Lottery.sol\";\n\nThis guide explains how to obtain secure random numbers on Flare. Secure randomness is generated by the [Scaling](/ftso/scaling/overview) protocol, which leverages a decentralized network of approximately 100 data providers who generate random numbers every 90 seconds.\n\nThe protocol aggregates these individual random numbers to produce a final random number that is both uniform and resistant to manipulation. The uniformity of this random number is ensured as long as at least one of the data providers remains honest, i.e. 1-of-N.\nThe protocol has an in-built security mechanism to detect manipulation attempts, and will warn the end user if such an attempt is detected.\n\n<details>\n<summary>**Understand the mechanism behind secure random numbers on Flare.**</summary>\n\nAs described in the [FTSOv2 whitepaper](https://flare.network/wp-content/uploads/FTSOv2-White-Paper.pdf), the Scaling protocol consists of the following phases:\n\n1. **Commit:** During the Commit phase, data providers prepare their submissions for each of the data feeds and encode them into a 4-byte vector. Then, each data provider publishes on chain a hash commitment obtained as:\n\n   `Hash(address, voting_epoch_id, random_number, price_data)`\n\n   - **Random Number**: This commit includes a locally generated random number.\n   - **Purpose**: The random number blinds the commit hash of the user from a search attack and is used later (once revealed) to contribute to onchain randomness.\n\n2. **Reveal:** During the Reveal phase, each data provider reveals all inputs to their hash commitment. As such, all locally produced random numbers become available onchain.\n\n3. **Signing:** After the Reveal phase, data providers perform a number of local computations relevant to the Scaling protocol, which include:\n\n   - Computing the weighted median prices\n   - Calculating the rewards\n\n   All these are packaged into a Merkle root, which is published onchain together with a signature of the root.\n\n4. **Finalization:** Once enough signatures for the same Merkle root are gathered, the process is finalized.\n\n**Secure Random Numbers**\n\nFor each voting epoch (90 seconds), an overall random number is generated from the local random numbers:\n\n$$\nR = \\sum_{i} r_i \\pmod{N}\n$$\n\nwhere $r_i$ is the local random number generated by the $i^{th}$ data provider, and $ N = 2^n $ denotes the maximum possible size of the individual $n$-bit random numbers.\nThis mechanism ensures that the resultant $R$ is a uniformly generated random number as long as at least any one of the inputs was an honestly generated uniformly random number.\n\nImportantly, the Merkle root published by the data providers contains a Boolean value that tracks whether the generated random number for the current voting epoch is secure.\n\n**Security Mechanism**\n\nThe security mechanism behind the random number generator protects the protocol against withholding attacks. An adversary could wait until all submissions are known and then choose whether or not to reveal their own commit data to influence the final result. This security mechanism measures the quality of the random number as follows:\n\n- **True**: If there are no omissions of reveals for the commits provided by the data providers.\n- **False**: If any omission exists, or if a reveal does not match the committed value.\n\nIf a data provider causes an omission (or false reveal), they will be penalized, and their random number will not be included in the random number calculation for a number of voting rounds.\n\n</details>",
    "file_name": "files/hub-docs/network/guides/secure-random-numbers.mdx",
    "meta_data": {
      "slug": "secure-random-numbers",
      "title": "Secure Random Numbers",
      "tags": [
        "quickstart",
        "solidity",
        "javascript",
        "python",
        "rust",
        "go"
      ],
      "authors": [
        "dineshpinto",
        "horiamagureanu",
        "charlesgrover"
      ],
      "description": "Use Flare's secure randomness in your application.",
      "keywords": [
        "solidity",
        "javascript",
        "python",
        "rust",
        "go",
        "randomness",
        "randomn-number",
        "flare-time-series-oracle",
        "flare-network"
      ],
      "sidebar_position": 6
    },
    "type": "answer"
  },
  {
    "content": "import TabItem from \"@theme/TabItem\";\nimport Tabs from \"@theme/Tabs\";\nimport Remix from \"@site/src/components/remix\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport SecureRandomConsumer from \"!!raw-loader!/examples/developer-hub-solidity/SecureRandomConsumer.sol\";\nimport SetEvmVersionRemix from \"/static/img/set-evm-version-remix.png\";\nimport SecureRandomWeb3Js from \"!!raw-loader!/examples/developer-hub-javascript/secure_random_coston2_web3.js\";\nimport SecureRandomEthersJs from \"!!raw-loader!/examples/developer-hub-javascript/secure_random_coston2_ethers.js\";\nimport SecureRandomWeb3Py from \"!!raw-loader!/examples/developer-hub-python/secure_random_coston2.py\";\nimport SecureRandomRust from \"!!raw-loader!/examples/developer-hub-rust/src/bin/secure_random_coston2.rs\";\nimport SecureRandomGo from \"!!raw-loader!/examples/developer-hub-go/coston2/secure_random.go\";\nimport RandomNumberV2Lottery from \"!!raw-loader!/examples/developer-hub-solidity/RandomNumberV2Lottery.sol\";\n\nThis guide explains how to obtain secure random numbers on Flare. Secure randomness is generated by the [Scaling](/ftso/scaling/overview) protocol, which leverages a decentralized network of approximately 100 data providers who generate random numbers every 90 seconds.\n\nThe protocol aggregates these individual random numbers to produce a final random number that is both uniform and resistant to manipulation. The uniformity of this random number is ensured as long as at least one of the data providers remains honest, i.e. 1-of-N.\nThe protocol has an in-built security mechanism to detect manipulation attempts, and will warn the end user if such an attempt is detected.\n\n<details>\n<summary>**Understand the mechanism behind secure random numbers on Flare.**</summary>\n\nAs described in the [FTSOv2 whitepaper](https://flare.network/wp-content/uploads/FTSOv2-White-Paper.pdf), the Scaling protocol consists of the following phases:\n\n1. **Commit:** During the Commit phase, data providers prepare their submissions for each of the data feeds and encode them into a 4-byte vector. Then, each data provider publishes on chain a hash commitment obtained as:\n\n   `Hash(address, voting_epoch_id, random_number, price_data)`\n\n   - **Random Number**: This commit includes a locally generated random number.\n   - **Purpose**: The random number blinds the commit hash of the user from a search attack and is used later (once revealed) to contribute to onchain randomness.\n\n2. **Reveal:** During the Reveal phase, each data provider reveals all inputs to their hash commitment. As such, all locally produced random numbers become available onchain.\n\n3. **Signing:** After the Reveal phase, data providers perform a number of local computations relevant to the Scaling protocol, which include:\n\n   - Computing the weighted median prices\n   - Calculating the rewards\n\n   All these are packaged into a Merkle root, which is published onchain together with a signature of the root.\n\n4. **Finalization:** Once enough signatures for the same Merkle root are gathered, the process is finalized.\n\n**Secure Random Numbers**\n\nFor each voting epoch (90 seconds), an overall random number is generated from the local random numbers:\n\n$$\nR = \\sum_{i} r_i \\pmod{N}\n$$\n\nwhere $r_i$ is the local random number generated by the $i^{th}$ data provider, and $ N = 2^n $ denotes the maximum possible size of the individual $n$-bit random numbers.\nThis mechanism ensures that the resultant $R$ is a uniformly generated random number as long as at least any one of the inputs was an honestly generated uniformly random number.\n\nImportantly, the Merkle root published by the data providers contains a Boolean value that tracks whether the generated random number for the current voting epoch is secure.\n\n**Security Mechanism**\n\nThe security mechanism behind the random number generator protects the protocol against withholding attacks. An adversary could wait until all submissions are known and then choose whether or not to reveal their own commit data to influence the final result. This security mechanism measures the quality of the random number as follows:\n\n- **True**: If there are no omissions of reveals for the commits provided by the data providers.\n- **False**: If any omission exists, or if a reveal does not match the committed value.\n\nIf a data provider causes an omission (or false reveal), they will be penalized, and their random number will not be included in the random number calculation for a number of voting rounds.\n\n</details>",
    "file_name": "files/hub-docs/network/guides/secure-random-numbers.mdx",
    "meta_data": {
      "slug": "secure-random-numbers",
      "title": "Secure Random Numbers",
      "tags": [
        "quickstart",
        "solidity",
        "javascript",
        "python",
        "rust",
        "go"
      ],
      "authors": [
        "dineshpinto",
        "horiamagureanu",
        "charlesgrover"
      ],
      "description": "Use Flare's secure randomness in your application.",
      "keywords": [
        "solidity",
        "javascript",
        "python",
        "rust",
        "go",
        "randomness",
        "randomn-number",
        "flare-time-series-oracle",
        "flare-network"
      ],
      "sidebar_position": 6
    },
    "type": "answer"
  },
  {
    "content": "import TabItem from \"@theme/TabItem\";\nimport Tabs from \"@theme/Tabs\";\nimport Remix from \"@site/src/components/remix\";\nimport CodeBlock from \"@theme/CodeBlock\";\nimport SecureRandomConsumer from \"!!raw-loader!/examples/developer-hub-solidity/SecureRandomConsumer.sol\";\nimport SetEvmVersionRemix from \"/static/img/set-evm-version-remix.png\";\nimport SecureRandomWeb3Js from \"!!raw-loader!/examples/developer-hub-javascript/secure_random_coston2_web3.js\";\nimport SecureRandomEthersJs from \"!!raw-loader!/examples/developer-hub-javascript/secure_random_coston2_ethers.js\";\nimport SecureRandomWeb3Py from \"!!raw-loader!/examples/developer-hub-python/secure_random_coston2.py\";\nimport SecureRandomRust from \"!!raw-loader!/examples/developer-hub-rust/src/bin/secure_random_coston2.rs\";\nimport SecureRandomGo from \"!!raw-loader!/examples/developer-hub-go/coston2/secure_random.go\";\nimport RandomNumberV2Lottery from \"!!raw-loader!/examples/developer-hub-solidity/RandomNumberV2Lottery.sol\";\n\nThis guide explains how to obtain secure random numbers on Flare. Secure randomness is generated by the [Scaling](/ftso/scaling/overview) protocol, which leverages a decentralized network of approximately 100 data providers who generate random numbers every 90 seconds.\n\nThe protocol aggregates these individual random numbers to produce a final random number that is both uniform and resistant to manipulation. The uniformity of this random number is ensured as long as at least one of the data providers remains honest, i.e. 1-of-N.\nThe protocol has an in-built security mechanism to detect manipulation attempts, and will warn the end user if such an attempt is detected.\n\n<details>\n<summary>**Understand the mechanism behind secure random numbers on Flare.**</summary>\n\nAs described in the [FTSOv2 whitepaper](https://flare.network/wp-content/uploads/FTSOv2-White-Paper.pdf), the Scaling protocol consists of the following phases:\n\n1. **Commit:** During the Commit phase, data providers prepare their submissions for each of the data feeds and encode them into a 4-byte vector. Then, each data provider publishes on chain a hash commitment obtained as:\n\n   `Hash(address, voting_epoch_id, random_number, price_data)`\n\n   - **Random Number**: This commit includes a locally generated random number.\n   - **Purpose**: The random number blinds the commit hash of the user from a search attack and is used later (once revealed) to contribute to onchain randomness.\n\n2. **Reveal:** During the Reveal phase, each data provider reveals all inputs to their hash commitment. As such, all locally produced random numbers become available onchain.\n\n3. **Signing:** After the Reveal phase, data providers perform a number of local computations relevant to the Scaling protocol, which include:\n\n   - Computing the weighted median prices\n   - Calculating the rewards\n\n   All these are packaged into a Merkle root, which is published onchain together with a signature of the root.\n\n4. **Finalization:** Once enough signatures for the same Merkle root are gathered, the process is finalized.\n\n**Secure Random Numbers**\n\nFor each voting epoch (90 seconds), an overall random number is generated from the local random numbers:\n\n$$\nR = \\sum_{i} r_i \\pmod{N}\n$$\n\nwhere $r_i$ is the local random number generated by the $i^{th}$ data provider, and $ N = 2^n $ denotes the maximum possible size of the individual $n$-bit random numbers.\nThis mechanism ensures that the resultant $R$ is a uniformly generated random number as long as at least any one of the inputs was an honestly generated uniformly random number.\n\nImportantly, the Merkle root published by the data providers contains a Boolean value that tracks whether the generated random number for the current voting epoch is secure.\n\n**Security Mechanism**\n\nThe security mechanism behind the random number generator protects the protocol against withholding attacks. An adversary could wait until all submissions are known and then choose whether or not to reveal their own commit data to influence the final result. This security mechanism measures the quality of the random number as follows:\n\n- **True**: If there are no omissions of reveals for the commits provided by the data providers.\n- **False**: If any omission exists, or if a reveal does not match the committed value.\n\nIf a data provider causes an omission (or false reveal), they will be penalized, and their random number will not be included in the random number calculation for a number of voting rounds.\n\n</details>",
    "file_name": "files/hub-docs/network/guides/secure-random-numbers.mdx",
    "meta_data": {
      "slug": "secure-random-numbers",
      "title": "Secure Random Numbers",
      "tags": [
        "quickstart",
        "solidity",
        "javascript",
        "python",
        "rust",
        "go"
      ],
      "authors": [
        "dineshpinto",
        "horiamagureanu",
        "charlesgrover"
      ],
      "description": "Use Flare's secure randomness in your application.",
      "keywords": [
        "solidity",
        "javascript",
        "python",
        "rust",
        "go",
        "randomness",
        "randomn-number",
        "flare-time-series-oracle",
        "flare-network"
      ],
      "sidebar_position": 6
    },
    "type": "answer"
  },
  {
    "content": "The **Flare Systems Protocol** encompasses the following core system protocols:\n\n1. **P-chain Stake Voting Protocol**\n2. **Signing Policy Definition Protocol**\n3. **Validator Uptime Voting Protocol**\n4. **Reward Voting Protocol**\n5. **Random Number Generation Protocol** (dependent on the FTSOv2 Scaling)\n\nProtocols with voting frequencies tied to reward epochs are implemented directly on the [`FlareSystemsManager`](/network/fsp/solidity-reference/IFlareSystemsManager) smart contract, while others operate as sub-protocols. Each sub-protocol has a unique protocol ID, except for the system protocols mentioned above.\n\nThe **Flare Systems Protocol** encompasses the following core system protocols:\n\n1. **P-chain Stake Voting Protocol**\n2. **Signing Policy Definition Protocol**\n3. **Validator Uptime Voting Protocol**\n4. **Reward Voting Protocol**\n5. **Random Number Generation Protocol** (dependent on the FTSOv2 Scaling)\n\nProtocols with voting frequencies tied to reward epochs are implemented directly on the [`FlareSystemsManager`](/network/fsp/solidity-reference/IFlareSystemsManager) smart contract, while others operate as sub-protocols. Each sub-protocol has a unique protocol ID, except for the system protocols mentioned above.\n\nThe **Flare Systems Protocol** encompasses the following core system protocols:\n\n1. **P-chain Stake Voting Protocol**\n2. **Signing Policy Definition Protocol**\n3. **Validator Uptime Voting Protocol**\n4. **Reward Voting Protocol**\n5. **Random Number Generation Protocol** (dependent on the FTSOv2 Scaling)\n\nProtocols with voting frequencies tied to reward epochs are implemented directly on the [`FlareSystemsManager`](/network/fsp/solidity-reference/IFlareSystemsManager) smart contract, while others operate as sub-protocols. Each sub-protocol has a unique protocol ID, except for the system protocols mentioned above.\n\nThe **Flare Systems Protocol** encompasses the following core system protocols:\n\n1. **P-chain Stake Voting Protocol**\n2. **Signing Policy Definition Protocol**\n3. **Validator Uptime Voting Protocol**\n4. **Reward Voting Protocol**\n5. **Random Number Generation Protocol** (dependent on the FTSOv2 Scaling)\n\nProtocols with voting frequencies tied to reward epochs are implemented directly on the [`FlareSystemsManager`](/network/fsp/solidity-reference/IFlareSystemsManager) smart contract, while others operate as sub-protocols. Each sub-protocol has a unique protocol ID, except for the system protocols mentioned above.\n\nThe **Flare Systems Protocol** encompasses the following core system protocols:\n\n1. **P-chain Stake Voting Protocol**\n2. **Signing Policy Definition Protocol**\n3. **Validator Uptime Voting Protocol**\n4. **Reward Voting Protocol**\n5. **Random Number Generation Protocol** (dependent on the FTSOv2 Scaling)\n\nProtocols with voting frequencies tied to reward epochs are implemented directly on the [`FlareSystemsManager`](/network/fsp/solidity-reference/IFlareSystemsManager) smart contract, while others operate as sub-protocols. Each sub-protocol has a unique protocol ID, except for the system protocols mentioned above.\n\nThe **Flare Systems Protocol** encompasses the following core system protocols:\n\n1. **P-chain Stake Voting Protocol**\n2. **Signing Policy Definition Protocol**\n3. **Validator Uptime Voting Protocol**\n4. **Reward Voting Protocol**\n5. **Random Number Generation Protocol** (dependent on the FTSOv2 Scaling)\n\nProtocols with voting frequencies tied to reward epochs are implemented directly on the [`FlareSystemsManager`](/network/fsp/solidity-reference/IFlareSystemsManager) smart contract, while others operate as sub-protocols. Each sub-protocol has a unique protocol ID, except for the system protocols mentioned above.\n\nThe **Flare Systems Protocol** encompasses the following core system protocols:\n\n1. **P-chain Stake Voting Protocol**\n2. **Signing Policy Definition Protocol**\n3. **Validator Uptime Voting Protocol**\n4. **Reward Voting Protocol**\n5. **Random Number Generation Protocol** (dependent on the FTSOv2 Scaling)\n\nProtocols with voting frequencies tied to reward epochs are implemented directly on the [`FlareSystemsManager`](/network/fsp/solidity-reference/IFlareSystemsManager) smart contract, while others operate as sub-protocols. Each sub-protocol has a unique protocol ID, except for the system protocols mentioned above.",
    "file_name": "files/hub-docs/network/fsp/1-system-protocols.mdx",
    "meta_data": {
      "title": "System Protocols",
      "description": "Describes the core protocols comprising FSP.",
      "keywords": [
        "flare-network",
        "configuration",
        "blockchain",
        "data",
        "smart-contracts",
        "wallets"
      ]
    },
    "type": "answer"
  },
  {
    "content": "## Voters\n\nVoters are off-chain participants in Flare's protocols, responsible for threshold-weighted voting across all sub-protocols. The system anticipates **100 voters**, selected among validators with the highest vote power.\n\n**Vote Power Sources**:\n\n- **P-chain Stake**: Adding FLR stake to a validator node.\n- **WNat Delegations**: Community members delegate vote power via the WNat smart contract.\n\nEach voter is identified by an **identity address** (managed securely via cold wallets), used for:\n\n- Establishing voter identity.\n- Conducting admin operations (e.g., setting fees, signing addresses, delegation addresses).\n- Enabling delegations to a voter's address for WNat and staking weight.\n\n**Signing and Prioritized Addresses**:\n\n- Voters can set a **signing address** (hot wallet) for protocol participation.\n- **Prioritized submission addresses** are used for on-chain communication, defaulting to the identity address.\n- Rewards are distributed either directly to the identity address or based on participation weights (delegation and node IDs).\n\n## Voters\n\nVoters are off-chain participants in Flare's protocols, responsible for threshold-weighted voting across all sub-protocols. The system anticipates **100 voters**, selected among validators with the highest vote power.\n\n**Vote Power Sources**:\n\n- **P-chain Stake**: Adding FLR stake to a validator node.\n- **WNat Delegations**: Community members delegate vote power via the WNat smart contract.\n\nEach voter is identified by an **identity address** (managed securely via cold wallets), used for:\n\n- Establishing voter identity.\n- Conducting admin operations (e.g., setting fees, signing addresses, delegation addresses).\n- Enabling delegations to a voter's address for WNat and staking weight.\n\n**Signing and Prioritized Addresses**:\n\n- Voters can set a **signing address** (hot wallet) for protocol participation.\n- **Prioritized submission addresses** are used for on-chain communication, defaulting to the identity address.\n- Rewards are distributed either directly to the identity address or based on participation weights (delegation and node IDs).\n\n## Voters\n\nVoters are off-chain participants in Flare's protocols, responsible for threshold-weighted voting across all sub-protocols. The system anticipates **100 voters**, selected among validators with the highest vote power.\n\n**Vote Power Sources**:\n\n- **P-chain Stake**: Adding FLR stake to a validator node.\n- **WNat Delegations**: Community members delegate vote power via the WNat smart contract.\n\nEach voter is identified by an **identity address** (managed securely via cold wallets), used for:\n\n- Establishing voter identity.\n- Conducting admin operations (e.g., setting fees, signing addresses, delegation addresses).\n- Enabling delegations to a voter's address for WNat and staking weight.\n\n**Signing and Prioritized Addresses**:\n\n- Voters can set a **signing address** (hot wallet) for protocol participation.\n- **Prioritized submission addresses** are used for on-chain communication, defaulting to the identity address.\n- Rewards are distributed either directly to the identity address or based on participation weights (delegation and node IDs).\n\n## Voters\n\nVoters are off-chain participants in Flare's protocols, responsible for threshold-weighted voting across all sub-protocols. The system anticipates **100 voters**, selected among validators with the highest vote power.\n\n**Vote Power Sources**:\n\n- **P-chain Stake**: Adding FLR stake to a validator node.\n- **WNat Delegations**: Community members delegate vote power via the WNat smart contract.\n\nEach voter is identified by an **identity address** (managed securely via cold wallets), used for:\n\n- Establishing voter identity.\n- Conducting admin operations (e.g., setting fees, signing addresses, delegation addresses).\n- Enabling delegations to a voter's address for WNat and staking weight.\n\n**Signing and Prioritized Addresses**:\n\n- Voters can set a **signing address** (hot wallet) for protocol participation.\n- **Prioritized submission addresses** are used for on-chain communication, defaulting to the identity address.\n- Rewards are distributed either directly to the identity address or based on participation weights (delegation and node IDs).",
    "file_name": "files/hub-docs/network/fsp/0-protocol-components.mdx",
    "meta_data": {
      "title": "Protocol Components",
      "description": "Defines the structure, voting, and weight calculations for FSP.",
      "keywords": [
        "flare-network",
        "configuration",
        "blockchain",
        "data",
        "smart-contracts",
        "wallets"
      ]
    },
    "type": "answer"
  },
  {
    "content": "## Voters\n\nVoters are off-chain participants in Flare's protocols, responsible for threshold-weighted voting across all sub-protocols. The system anticipates **100 voters**, selected among validators with the highest vote power.\n\n**Vote Power Sources**:\n\n- **P-chain Stake**: Adding FLR stake to a validator node.\n- **WNat Delegations**: Community members delegate vote power via the WNat smart contract.\n\nEach voter is identified by an **identity address** (managed securely via cold wallets), used for:\n\n- Establishing voter identity.\n- Conducting admin operations (e.g., setting fees, signing addresses, delegation addresses).\n- Enabling delegations to a voter's address for WNat and staking weight.\n\n**Signing and Prioritized Addresses**:\n\n- Voters can set a **signing address** (hot wallet) for protocol participation.\n- **Prioritized submission addresses** are used for on-chain communication, defaulting to the identity address.\n- Rewards are distributed either directly to the identity address or based on participation weights (delegation and node IDs).\n\n## Voters\n\nVoters are off-chain participants in Flare's protocols, responsible for threshold-weighted voting across all sub-protocols. The system anticipates **100 voters**, selected among validators with the highest vote power.\n\n**Vote Power Sources**:\n\n- **P-chain Stake**: Adding FLR stake to a validator node.\n- **WNat Delegations**: Community members delegate vote power via the WNat smart contract.\n\nEach voter is identified by an **identity address** (managed securely via cold wallets), used for:\n\n- Establishing voter identity.\n- Conducting admin operations (e.g., setting fees, signing addresses, delegation addresses).\n- Enabling delegations to a voter's address for WNat and staking weight.\n\n**Signing and Prioritized Addresses**:\n\n- Voters can set a **signing address** (hot wallet) for protocol participation.\n- **Prioritized submission addresses** are used for on-chain communication, defaulting to the identity address.\n- Rewards are distributed either directly to the identity address or based on participation weights (delegation and node IDs).\n\n## Voters\n\nVoters are off-chain participants in Flare's protocols, responsible for threshold-weighted voting across all sub-protocols. The system anticipates **100 voters**, selected among validators with the highest vote power.\n\n**Vote Power Sources**:\n\n- **P-chain Stake**: Adding FLR stake to a validator node.\n- **WNat Delegations**: Community members delegate vote power via the WNat smart contract.\n\nEach voter is identified by an **identity address** (managed securely via cold wallets), used for:\n\n- Establishing voter identity.\n- Conducting admin operations (e.g., setting fees, signing addresses, delegation addresses).\n- Enabling delegations to a voter's address for WNat and staking weight.\n\n**Signing and Prioritized Addresses**:\n\n- Voters can set a **signing address** (hot wallet) for protocol participation.\n- **Prioritized submission addresses** are used for on-chain communication, defaulting to the identity address.\n- Rewards are distributed either directly to the identity address or based on participation weights (delegation and node IDs).\n\n## Voters\n\nVoters are off-chain participants in Flare's protocols, responsible for threshold-weighted voting across all sub-protocols. The system anticipates **100 voters**, selected among validators with the highest vote power.\n\n**Vote Power Sources**:\n\n- **P-chain Stake**: Adding FLR stake to a validator node.\n- **WNat Delegations**: Community members delegate vote power via the WNat smart contract.\n\nEach voter is identified by an **identity address** (managed securely via cold wallets), used for:\n\n- Establishing voter identity.\n- Conducting admin operations (e.g., setting fees, signing addresses, delegation addresses).\n- Enabling delegations to a voter's address for WNat and staking weight.\n\n**Signing and Prioritized Addresses**:\n\n- Voters can set a **signing address** (hot wallet) for protocol participation.\n- **Prioritized submission addresses** are used for on-chain communication, defaulting to the identity address.\n- Rewards are distributed either directly to the identity address or based on participation weights (delegation and node IDs).",
    "file_name": "files/hub-docs/network/fsp/0-protocol-components.mdx",
    "meta_data": {
      "title": "Protocol Components",
      "description": "Defines the structure, voting, and weight calculations for FSP.",
      "keywords": [
        "flare-network",
        "configuration",
        "blockchain",
        "data",
        "smart-contracts",
        "wallets"
      ]
    },
    "type": "answer"
  },
  {
    "content": "## Voters\n\nVoters are off-chain participants in Flare's protocols, responsible for threshold-weighted voting across all sub-protocols. The system anticipates **100 voters**, selected among validators with the highest vote power.\n\n**Vote Power Sources**:\n\n- **P-chain Stake**: Adding FLR stake to a validator node.\n- **WNat Delegations**: Community members delegate vote power via the WNat smart contract.\n\nEach voter is identified by an **identity address** (managed securely via cold wallets), used for:\n\n- Establishing voter identity.\n- Conducting admin operations (e.g., setting fees, signing addresses, delegation addresses).\n- Enabling delegations to a voter's address for WNat and staking weight.\n\n**Signing and Prioritized Addresses**:\n\n- Voters can set a **signing address** (hot wallet) for protocol participation.\n- **Prioritized submission addresses** are used for on-chain communication, defaulting to the identity address.\n- Rewards are distributed either directly to the identity address or based on participation weights (delegation and node IDs).",
    "file_name": "files/hub-docs/network/fsp/0-protocol-components.mdx",
    "meta_data": {
      "title": "Protocol Components",
      "description": "Defines the structure, voting, and weight calculations for FSP.",
      "keywords": [
        "flare-network",
        "configuration",
        "blockchain",
        "data",
        "smart-contracts",
        "wallets"
      ]
    },
    "type": "answer"
  },
  {
    "content": "import Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport DocCardList from \"@theme/DocCardList\";\nimport SolidityReference from \"@site/src/components/DataTables/SolidityReference\";\n\nimport Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport DocCardList from \"@theme/DocCardList\";\nimport SolidityReference from \"@site/src/components/DataTables/SolidityReference\";\n\nimport Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\nimport DocCardList from \"@theme/DocCardList\";\nimport SolidityReference from \"@site/src/components/DataTables/SolidityReference\";",
    "file_name": "files/hub-docs/network/fsp/4-solidity-reference.mdx",
    "meta_data": {
      "title": "FSP Reference",
      "description": "Solidity reference for Flare contracts.",
      "keywords": [
        "solidity",
        "reference",
        "ftso",
        "flare-network",
        "smart-contracts"
      ]
    },
    "type": "answer"
  },
  {
    "content": "Flare's sub-protocols utilize a uniform signing weight for decision-making; however, reward distribution is based on the delegators' participation weights. Each sub-protocol calculates rewards for various participation weight types, allowing delegators to claim rewards according to their specific contribution shares.\n\nAll rewards are managed through the [`RewardManager`](/network/fsp/solidity-reference/IRewardManager) contract and are claimable after the reward epoch concludes. Sub-protocols implement their own contracts to gather rewarding inputs, which are passed to the Reward Manager for distribution. Funding is provided by sub-protocol-specific contracts, which may also handle inflation-based rewards through automated offers.\n\nFlare's sub-protocols utilize a uniform signing weight for decision-making; however, reward distribution is based on the delegators' participation weights. Each sub-protocol calculates rewards for various participation weight types, allowing delegators to claim rewards according to their specific contribution shares.\n\nAll rewards are managed through the [`RewardManager`](/network/fsp/solidity-reference/IRewardManager) contract and are claimable after the reward epoch concludes. Sub-protocols implement their own contracts to gather rewarding inputs, which are passed to the Reward Manager for distribution. Funding is provided by sub-protocol-specific contracts, which may also handle inflation-based rewards through automated offers.\n\nFlare's sub-protocols utilize a uniform signing weight for decision-making; however, reward distribution is based on the delegators' participation weights. Each sub-protocol calculates rewards for various participation weight types, allowing delegators to claim rewards according to their specific contribution shares.\n\nAll rewards are managed through the [`RewardManager`](/network/fsp/solidity-reference/IRewardManager) contract and are claimable after the reward epoch concludes. Sub-protocols implement their own contracts to gather rewarding inputs, which are passed to the Reward Manager for distribution. Funding is provided by sub-protocol-specific contracts, which may also handle inflation-based rewards through automated offers.\n\nFlare's sub-protocols utilize a uniform signing weight for decision-making; however, reward distribution is based on the delegators' participation weights. Each sub-protocol calculates rewards for various participation weight types, allowing delegators to claim rewards according to their specific contribution shares.\n\nAll rewards are managed through the [`RewardManager`](/network/fsp/solidity-reference/IRewardManager) contract and are claimable after the reward epoch concludes. Sub-protocols implement their own contracts to gather rewarding inputs, which are passed to the Reward Manager for distribution. Funding is provided by sub-protocol-specific contracts, which may also handle inflation-based rewards through automated offers.\n\nFlare's sub-protocols utilize a uniform signing weight for decision-making; however, reward distribution is based on the delegators' participation weights. Each sub-protocol calculates rewards for various participation weight types, allowing delegators to claim rewards according to their specific contribution shares.\n\nAll rewards are managed through the [`RewardManager`](/network/fsp/solidity-reference/IRewardManager) contract and are claimable after the reward epoch concludes. Sub-protocols implement their own contracts to gather rewarding inputs, which are passed to the Reward Manager for distribution. Funding is provided by sub-protocol-specific contracts, which may also handle inflation-based rewards through automated offers.",
    "file_name": "files/hub-docs/network/fsp/3-rewarding.mdx",
    "meta_data": {
      "title": "Rewarding",
      "description": "Explains the structure for distributing rewards in FSP.",
      "keywords": [
        "flare-network",
        "configuration",
        "blockchain",
        "data",
        "smart-contracts",
        "wallets"
      ]
    },
    "type": "answer"
  },
  {
    "content": "The **Flare Systems Protocol** utilizes a set of off-chain services encapsulated within the **Flare Systems Client**. These services interact with blockchain smart contracts to support various protocols. Key components include:\n\n1. **Protocol Manager Service**: Handles periodic transactions (`submit1`, `submit2`, `submitSignatures`, and future `submit3`) for each voting round by querying protocol data providers.\n2. **Reward Aggregator Service**: Submits the Merkle root of combined reward claims once per reward epoch.\n3. **Signing Policy Voter Service**: Signs new signing policies after they are defined, once per reward epoch.\n4. **Voter Registration Service**: Registers voters on the [`VoterRegistry`](/network/fsp/solidity-reference/IVoterRegistry) contract.\n5. **Finalizer Service**: Submits finalization transactions when a voter is eligible to finalize a specific sub-protocol.\n6. **Scheduler**: Coordinates transaction scheduling across services.\n7. **Uptime Voting Client**: Submits validator uptime votes once per reward epoch.\n\nEach voter runs an independent instance of the **Flare Systems Client**, which manages private keys and transaction submissions, enabling participation across multiple sub-protocols.\n\nThe **Flare Systems Protocol** utilizes a set of off-chain services encapsulated within the **Flare Systems Client**. These services interact with blockchain smart contracts to support various protocols. Key components include:\n\n1. **Protocol Manager Service**: Handles periodic transactions (`submit1`, `submit2`, `submitSignatures`, and future `submit3`) for each voting round by querying protocol data providers.\n2. **Reward Aggregator Service**: Submits the Merkle root of combined reward claims once per reward epoch.\n3. **Signing Policy Voter Service**: Signs new signing policies after they are defined, once per reward epoch.\n4. **Voter Registration Service**: Registers voters on the [`VoterRegistry`](/network/fsp/solidity-reference/IVoterRegistry) contract.\n5. **Finalizer Service**: Submits finalization transactions when a voter is eligible to finalize a specific sub-protocol.\n6. **Scheduler**: Coordinates transaction scheduling across services.\n7. **Uptime Voting Client**: Submits validator uptime votes once per reward epoch.\n\nEach voter runs an independent instance of the **Flare Systems Client**, which manages private keys and transaction submissions, enabling participation across multiple sub-protocols.\n\nThe **Flare Systems Protocol** utilizes a set of off-chain services encapsulated within the **Flare Systems Client**. These services interact with blockchain smart contracts to support various protocols. Key components include:\n\n1. **Protocol Manager Service**: Handles periodic transactions (`submit1`, `submit2`, `submitSignatures`, and future `submit3`) for each voting round by querying protocol data providers.\n2. **Reward Aggregator Service**: Submits the Merkle root of combined reward claims once per reward epoch.\n3. **Signing Policy Voter Service**: Signs new signing policies after they are defined, once per reward epoch.\n4. **Voter Registration Service**: Registers voters on the [`VoterRegistry`](/network/fsp/solidity-reference/IVoterRegistry) contract.\n5. **Finalizer Service**: Submits finalization transactions when a voter is eligible to finalize a specific sub-protocol.\n6. **Scheduler**: Coordinates transaction scheduling across services.\n7. **Uptime Voting Client**: Submits validator uptime votes once per reward epoch.\n\nEach voter runs an independent instance of the **Flare Systems Client**, which manages private keys and transaction submissions, enabling participation across multiple sub-protocols.\n\nThe **Flare Systems Protocol** utilizes a set of off-chain services encapsulated within the **Flare Systems Client**. These services interact with blockchain smart contracts to support various protocols. Key components include:\n\n1. **Protocol Manager Service**: Handles periodic transactions (`submit1`, `submit2`, `submitSignatures`, and future `submit3`) for each voting round by querying protocol data providers.\n2. **Reward Aggregator Service**: Submits the Merkle root of combined reward claims once per reward epoch.\n3. **Signing Policy Voter Service**: Signs new signing policies after they are defined, once per reward epoch.\n4. **Voter Registration Service**: Registers voters on the [`VoterRegistry`](/network/fsp/solidity-reference/IVoterRegistry) contract.\n5. **Finalizer Service**: Submits finalization transactions when a voter is eligible to finalize a specific sub-protocol.\n6. **Scheduler**: Coordinates transaction scheduling across services.\n7. **Uptime Voting Client**: Submits validator uptime votes once per reward epoch.\n\nEach voter runs an independent instance of the **Flare Systems Client**, which manages private keys and transaction submissions, enabling participation across multiple sub-protocols.",
    "file_name": "files/hub-docs/network/fsp/2-offchain-services.mdx",
    "meta_data": {
      "title": "Offchain Services",
      "description": "Outlines the architecture of off-chain services supporting FSP.",
      "keywords": [
        "flare-network",
        "configuration",
        "blockchain",
        "data",
        "smart-contracts",
        "wallets"
      ]
    },
    "type": "answer"
  },
  {
    "content": "The **Flare Systems Protocol** utilizes a set of off-chain services encapsulated within the **Flare Systems Client**. These services interact with blockchain smart contracts to support various protocols. Key components include:\n\n1. **Protocol Manager Service**: Handles periodic transactions (`submit1`, `submit2`, `submitSignatures`, and future `submit3`) for each voting round by querying protocol data providers.\n2. **Reward Aggregator Service**: Submits the Merkle root of combined reward claims once per reward epoch.\n3. **Signing Policy Voter Service**: Signs new signing policies after they are defined, once per reward epoch.\n4. **Voter Registration Service**: Registers voters on the [`VoterRegistry`](/network/fsp/solidity-reference/IVoterRegistry) contract.\n5. **Finalizer Service**: Submits finalization transactions when a voter is eligible to finalize a specific sub-protocol.\n6. **Scheduler**: Coordinates transaction scheduling across services.\n7. **Uptime Voting Client**: Submits validator uptime votes once per reward epoch.\n\nEach voter runs an independent instance of the **Flare Systems Client**, which manages private keys and transaction submissions, enabling participation across multiple sub-protocols.\n\nThe **Flare Systems Protocol** utilizes a set of off-chain services encapsulated within the **Flare Systems Client**. These services interact with blockchain smart contracts to support various protocols. Key components include:\n\n1. **Protocol Manager Service**: Handles periodic transactions (`submit1`, `submit2`, `submitSignatures`, and future `submit3`) for each voting round by querying protocol data providers.\n2. **Reward Aggregator Service**: Submits the Merkle root of combined reward claims once per reward epoch.\n3. **Signing Policy Voter Service**: Signs new signing policies after they are defined, once per reward epoch.\n4. **Voter Registration Service**: Registers voters on the [`VoterRegistry`](/network/fsp/solidity-reference/IVoterRegistry) contract.\n5. **Finalizer Service**: Submits finalization transactions when a voter is eligible to finalize a specific sub-protocol.\n6. **Scheduler**: Coordinates transaction scheduling across services.\n7. **Uptime Voting Client**: Submits validator uptime votes once per reward epoch.\n\nEach voter runs an independent instance of the **Flare Systems Client**, which manages private keys and transaction submissions, enabling participation across multiple sub-protocols.\n\nThe **Flare Systems Protocol** utilizes a set of off-chain services encapsulated within the **Flare Systems Client**. These services interact with blockchain smart contracts to support various protocols. Key components include:\n\n1. **Protocol Manager Service**: Handles periodic transactions (`submit1`, `submit2`, `submitSignatures`, and future `submit3`) for each voting round by querying protocol data providers.\n2. **Reward Aggregator Service**: Submits the Merkle root of combined reward claims once per reward epoch.\n3. **Signing Policy Voter Service**: Signs new signing policies after they are defined, once per reward epoch.\n4. **Voter Registration Service**: Registers voters on the [`VoterRegistry`](/network/fsp/solidity-reference/IVoterRegistry) contract.\n5. **Finalizer Service**: Submits finalization transactions when a voter is eligible to finalize a specific sub-protocol.\n6. **Scheduler**: Coordinates transaction scheduling across services.\n7. **Uptime Voting Client**: Submits validator uptime votes once per reward epoch.\n\nEach voter runs an independent instance of the **Flare Systems Client**, which manages private keys and transaction submissions, enabling participation across multiple sub-protocols.\n\nThe **Flare Systems Protocol** utilizes a set of off-chain services encapsulated within the **Flare Systems Client**. These services interact with blockchain smart contracts to support various protocols. Key components include:\n\n1. **Protocol Manager Service**: Handles periodic transactions (`submit1`, `submit2`, `submitSignatures`, and future `submit3`) for each voting round by querying protocol data providers.\n2. **Reward Aggregator Service**: Submits the Merkle root of combined reward claims once per reward epoch.\n3. **Signing Policy Voter Service**: Signs new signing policies after they are defined, once per reward epoch.\n4. **Voter Registration Service**: Registers voters on the [`VoterRegistry`](/network/fsp/solidity-reference/IVoterRegistry) contract.\n5. **Finalizer Service**: Submits finalization transactions when a voter is eligible to finalize a specific sub-protocol.\n6. **Scheduler**: Coordinates transaction scheduling across services.\n7. **Uptime Voting Client**: Submits validator uptime votes once per reward epoch.\n\nEach voter runs an independent instance of the **Flare Systems Client**, which manages private keys and transaction submissions, enabling participation across multiple sub-protocols.",
    "file_name": "files/hub-docs/network/fsp/2-offchain-services.mdx",
    "meta_data": {
      "title": "Offchain Services",
      "description": "Outlines the architecture of off-chain services supporting FSP.",
      "keywords": [
        "flare-network",
        "configuration",
        "blockchain",
        "data",
        "smart-contracts",
        "wallets"
      ]
    },
    "type": "answer"
  },
  {
    "content": "The **Flare Systems Protocol** utilizes a set of off-chain services encapsulated within the **Flare Systems Client**. These services interact with blockchain smart contracts to support various protocols. Key components include:\n\n1. **Protocol Manager Service**: Handles periodic transactions (`submit1`, `submit2`, `submitSignatures`, and future `submit3`) for each voting round by querying protocol data providers.\n2. **Reward Aggregator Service**: Submits the Merkle root of combined reward claims once per reward epoch.\n3. **Signing Policy Voter Service**: Signs new signing policies after they are defined, once per reward epoch.\n4. **Voter Registration Service**: Registers voters on the [`VoterRegistry`](/network/fsp/solidity-reference/IVoterRegistry) contract.\n5. **Finalizer Service**: Submits finalization transactions when a voter is eligible to finalize a specific sub-protocol.\n6. **Scheduler**: Coordinates transaction scheduling across services.\n7. **Uptime Voting Client**: Submits validator uptime votes once per reward epoch.\n\nEach voter runs an independent instance of the **Flare Systems Client**, which manages private keys and transaction submissions, enabling participation across multiple sub-protocols.\n\nThe **Flare Systems Protocol** utilizes a set of off-chain services encapsulated within the **Flare Systems Client**. These services interact with blockchain smart contracts to support various protocols. Key components include:\n\n1. **Protocol Manager Service**: Handles periodic transactions (`submit1`, `submit2`, `submitSignatures`, and future `submit3`) for each voting round by querying protocol data providers.\n2. **Reward Aggregator Service**: Submits the Merkle root of combined reward claims once per reward epoch.\n3. **Signing Policy Voter Service**: Signs new signing policies after they are defined, once per reward epoch.\n4. **Voter Registration Service**: Registers voters on the [`VoterRegistry`](/network/fsp/solidity-reference/IVoterRegistry) contract.\n5. **Finalizer Service**: Submits finalization transactions when a voter is eligible to finalize a specific sub-protocol.\n6. **Scheduler**: Coordinates transaction scheduling across services.\n7. **Uptime Voting Client**: Submits validator uptime votes once per reward epoch.\n\nEach voter runs an independent instance of the **Flare Systems Client**, which manages private keys and transaction submissions, enabling participation across multiple sub-protocols.\n\nThe **Flare Systems Protocol** utilizes a set of off-chain services encapsulated within the **Flare Systems Client**. These services interact with blockchain smart contracts to support various protocols. Key components include:\n\n1. **Protocol Manager Service**: Handles periodic transactions (`submit1`, `submit2`, `submitSignatures`, and future `submit3`) for each voting round by querying protocol data providers.\n2. **Reward Aggregator Service**: Submits the Merkle root of combined reward claims once per reward epoch.\n3. **Signing Policy Voter Service**: Signs new signing policies after they are defined, once per reward epoch.\n4. **Voter Registration Service**: Registers voters on the [`VoterRegistry`](/network/fsp/solidity-reference/IVoterRegistry) contract.\n5. **Finalizer Service**: Submits finalization transactions when a voter is eligible to finalize a specific sub-protocol.\n6. **Scheduler**: Coordinates transaction scheduling across services.\n7. **Uptime Voting Client**: Submits validator uptime votes once per reward epoch.\n\nEach voter runs an independent instance of the **Flare Systems Client**, which manages private keys and transaction submissions, enabling participation across multiple sub-protocols.",
    "file_name": "files/hub-docs/network/fsp/2-offchain-services.mdx",
    "meta_data": {
      "title": "Offchain Services",
      "description": "Outlines the architecture of off-chain services supporting FSP.",
      "keywords": [
        "flare-network",
        "configuration",
        "blockchain",
        "data",
        "smart-contracts",
        "wallets"
      ]
    },
    "type": "answer"
  },
  {
    "content": "Registry interface with all Flare contract addresses.\n\nSourced from `IFlareContractRegistry.sol` on [GitLab](https://gitlab.com/flarenetwork/flare-smart-contracts/-/blob/master/contracts/userInterfaces/IFlareContractRegistry.sol).\n\nRegistry interface with all Flare contract addresses.\n\nSourced from `IFlareContractRegistry.sol` on [GitLab](https://gitlab.com/flarenetwork/flare-smart-contracts/-/blob/master/contracts/userInterfaces/IFlareContractRegistry.sol).",
    "file_name": "files/hub-docs/network/solidity-reference/IFlareContractRegistry.md",
    "meta_data": {
      "title": "IFlareContractRegistry",
      "sidebar_position": 1,
      "description": "Registry interface with all Flare contract addresses."
    },
    "type": "answer"
  },
  {
    "content": "Primary interface for managing all protocol rewards. This is a long-term support (LTS) interface, designed to ensure continuity even as underlying contracts evolve or protocols migrate to new versions.\n\nSourced from `RewardsV2Interface.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/LTS/RewardsV2Interface.sol).\n\nPrimary interface for managing all protocol rewards. This is a long-term support (LTS) interface, designed to ensure continuity even as underlying contracts evolve or protocols migrate to new versions.\n\nSourced from `RewardsV2Interface.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/LTS/RewardsV2Interface.sol).\n\nPrimary interface for managing all protocol rewards. This is a long-term support (LTS) interface, designed to ensure continuity even as underlying contracts evolve or protocols migrate to new versions.\n\nSourced from `RewardsV2Interface.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/LTS/RewardsV2Interface.sol).\n\nPrimary interface for managing all protocol rewards. This is a long-term support (LTS) interface, designed to ensure continuity even as underlying contracts evolve or protocols migrate to new versions.\n\nSourced from `RewardsV2Interface.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/LTS/RewardsV2Interface.sol).",
    "file_name": "files/hub-docs/network/solidity-reference/RewardsV2Interface.md",
    "meta_data": {
      "title": "RewardsV2Interface",
      "description": "Primary interface for managing all protocol rewards.",
      "sidebar_position": 4
    },
    "type": "answer"
  },
  {
    "content": "Primary interface for managing protocol related metadata. This is a long-term support (LTS) interface, designed to ensure continuity even as underlying contracts evolve or protocols migrate to new versions.\n\nSourced from `ProtocolsV2Interface.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/LTS/ProtocolsV2Interface.sol).\n\nPrimary interface for managing protocol related metadata. This is a long-term support (LTS) interface, designed to ensure continuity even as underlying contracts evolve or protocols migrate to new versions.\n\nSourced from `ProtocolsV2Interface.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/LTS/ProtocolsV2Interface.sol).",
    "file_name": "files/hub-docs/network/solidity-reference/ProtocolsV2Interface.md",
    "meta_data": {
      "title": "ProtocolsV2Interface",
      "description": "Primary interface for managing protocol related metadata.",
      "sidebar_position": 2
    },
    "type": "answer"
  },
  {
    "content": "Interface for managing reward claim setup.\n\nSourced from `IClaimSetupManager.sol` on [GitLab](https://gitlab.com/flarenetwork/flare-smart-contracts/-/blob/master/contracts/userInterfaces/IClaimSetupManager.sol).\n\nInterface for managing reward claim setup.\n\nSourced from `IClaimSetupManager.sol` on [GitLab](https://gitlab.com/flarenetwork/flare-smart-contracts/-/blob/master/contracts/userInterfaces/IClaimSetupManager.sol).\n\nInterface for managing reward claim setup.\n\nSourced from `IClaimSetupManager.sol` on [GitLab](https://gitlab.com/flarenetwork/flare-smart-contracts/-/blob/master/contracts/userInterfaces/IClaimSetupManager.sol).",
    "file_name": "files/hub-docs/network/solidity-reference/IClaimSetupManager.md",
    "meta_data": {
      "title": "IClaimSetupManager",
      "sidebar_position": 5,
      "description": "Interface for managing reward claim setup."
    },
    "type": "answer"
  },
  {
    "content": "Primary interface for random number generation. This is a long-term support (LTS) interface, designed to ensure continuity even as underlying contracts evolve or protocols migrate to new versions.\n\nSourced from `RandomNumberV2Interface.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/LTS/RandomNumberV2Interface.sol).\n\nPrimary interface for random number generation. This is a long-term support (LTS) interface, designed to ensure continuity even as underlying contracts evolve or protocols migrate to new versions.\n\nSourced from `RandomNumberV2Interface.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/LTS/RandomNumberV2Interface.sol).",
    "file_name": "files/hub-docs/network/solidity-reference/RandomNumberV2Interface.md",
    "meta_data": {
      "title": "RandomNumberV2Interface",
      "description": "Primary interface for random number generation.",
      "sidebar_position": 3
    },
    "type": "answer"
  },
  {
    "content": "Interface for wrapping and unwrapping native tokens.\n\nSourced from `IWNat.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IWNat.sol).\n\nInterface for wrapping and unwrapping native tokens.\n\nSourced from `IWNat.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IWNat.sol).",
    "file_name": "files/hub-docs/network/solidity-reference/IWNat.md",
    "meta_data": {
      "title": "IWNat",
      "description": "Interface for wrapping and unwrapping native tokens.",
      "sidebar_position": 7
    },
    "type": "answer"
  },
  {
    "content": "Interface for managing rFLR.\n\nSourced from `IRNat.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IRNat.sol).\n\nInterface for managing rFLR.\n\nSourced from `IRNat.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IRNat.sol).\n\nInterface for managing rFLR.\n\nSourced from `IRNat.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IRNat.sol).",
    "file_name": "files/hub-docs/network/solidity-reference/IRNat.md",
    "meta_data": {
      "title": "IRNat",
      "description": "Interface for managing rFLR.",
      "sidebar_position": 10
    },
    "type": "answer"
  },
  {
    "content": "Interface for managing FlareDrop claims.\n\nSourced from `IDistributionToDelegators.sol` on [GitLab](https://gitlab.com/flarenetwork/flare-smart-contracts/-/blob/master/contracts/userInterfaces/IDistributionToDelegators.sol).\n\nManages the ongoing distribution of tokens from the Delegation Incentive Pool (the \"FlareDrop\"). The approval of [FIP.01](https://proposals.flare.network/FIP/FIP_1) created this pool, that releases its tokens every 30 days, over a period of 36 months, to all accounts holding Wrapped FLR.\n\nInterface for managing FlareDrop claims.\n\nSourced from `IDistributionToDelegators.sol` on [GitLab](https://gitlab.com/flarenetwork/flare-smart-contracts/-/blob/master/contracts/userInterfaces/IDistributionToDelegators.sol).\n\nManages the ongoing distribution of tokens from the Delegation Incentive Pool (the \"FlareDrop\"). The approval of [FIP.01](https://proposals.flare.network/FIP/FIP_1) created this pool, that releases its tokens every 30 days, over a period of 36 months, to all accounts holding Wrapped FLR.\n\nInterface for managing FlareDrop claims.\n\nSourced from `IDistributionToDelegators.sol` on [GitLab](https://gitlab.com/flarenetwork/flare-smart-contracts/-/blob/master/contracts/userInterfaces/IDistributionToDelegators.sol).\n\nManages the ongoing distribution of tokens from the Delegation Incentive Pool (the \"FlareDrop\"). The approval of [FIP.01](https://proposals.flare.network/FIP/FIP_1) created this pool, that releases its tokens every 30 days, over a period of 36 months, to all accounts holding Wrapped FLR.",
    "file_name": "files/hub-docs/network/solidity-reference/IDistributionToDelegators.md",
    "meta_data": {
      "title": "IDistributionToDelegators",
      "sidebar_position": 6,
      "description": "Interface for managing FlareDrop claims."
    },
    "type": "answer"
  },
  {
    "content": "Stores confirmed Merkle roots and signing policies.\n\nSourced from `IRelay.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IRelay.sol).\n\nStores confirmed Merkle roots and signing policies.\n\nSourced from `IRelay.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IRelay.sol).\n\nStores confirmed Merkle roots and signing policies.\n\nSourced from `IRelay.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IRelay.sol).\n\nStores confirmed Merkle roots and signing policies.\n\nSourced from `IRelay.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IRelay.sol).",
    "file_name": "files/hub-docs/network/fsp/solidity-reference/IRelay.md",
    "meta_data": {
      "title": "IRelay",
      "sidebar_position": 4,
      "description": "Stores confirmed Merkle roots and signing policies."
    },
    "type": "answer"
  },
  {
    "content": "Manages system protocols like the Signing Policy Definition, Uptime Voting, and Reward Voting.\n\nSourced from `IFlareSystemsManager.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IFlareSystemsManager.sol).\n\nManages system protocols like the Signing Policy Definition, Uptime Voting, and Reward Voting.\n\nSourced from `IFlareSystemsManager.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IFlareSystemsManager.sol).\n\nManages system protocols like the Signing Policy Definition, Uptime Voting, and Reward Voting.\n\nSourced from `IFlareSystemsManager.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IFlareSystemsManager.sol).\n\nManages system protocols like the Signing Policy Definition, Uptime Voting, and Reward Voting.\n\nSourced from `IFlareSystemsManager.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IFlareSystemsManager.sol).",
    "file_name": "files/hub-docs/network/fsp/solidity-reference/IFlareSystemsManager.md",
    "meta_data": {
      "title": "IFlareSystemsManager",
      "sidebar_position": 3,
      "description": "Manages system protocols like Signing Policy Definition, Uptime Voting, and Reward Voting."
    },
    "type": "answer"
  },
  {
    "content": "Facilitates the claiming and distribution of rewards to voters, delegators, and stakers.\n\nSourced from `IRewardManager.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IRewardManager.sol).\n\nFacilitates the claiming and distribution of rewards to voters, delegators, and stakers.\n\nSourced from `IRewardManager.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IRewardManager.sol).\n\nFacilitates the claiming and distribution of rewards to voters, delegators, and stakers.\n\nSourced from `IRewardManager.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IRewardManager.sol).\n\nFacilitates the claiming and distribution of rewards to voters, delegators, and stakers.\n\nSourced from `IRewardManager.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IRewardManager.sol).",
    "file_name": "files/hub-docs/network/fsp/solidity-reference/IRewardManager.md",
    "meta_data": {
      "title": "IRewardManager",
      "sidebar_position": 5,
      "description": "Facilitates the claiming and distribution of rewards to voters, delegators, and stakers."
    },
    "type": "answer"
  },
  {
    "content": "Manages prioritized and subsidized submissions for protocols.\n\nSourced from `ISubmission.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/ISubmission.sol).\n\nManages prioritized and subsidized submissions for protocols.\n\nSourced from `ISubmission.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/ISubmission.sol).\n\nManages prioritized and subsidized submissions for protocols.\n\nSourced from `ISubmission.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/ISubmission.sol).",
    "file_name": "files/hub-docs/network/fsp/solidity-reference/ISubmission.md",
    "meta_data": {
      "title": "ISubmission",
      "sidebar_position": 2,
      "description": "Manages prioritized and subsidized submissions for protocols."
    },
    "type": "answer"
  },
  {
    "content": "Manages the delegation fees set by voters for WFLR delegations.\n\nSourced from `IWNatDelegationFee.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IWNatDelegationFee.sol).\n\nManages the delegation fees set by voters for WFLR delegations.\n\nSourced from `IWNatDelegationFee.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IWNatDelegationFee.sol).\n\nManages the delegation fees set by voters for WFLR delegations.\n\nSourced from `IWNatDelegationFee.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IWNatDelegationFee.sol).",
    "file_name": "files/hub-docs/network/fsp/solidity-reference/IWNatDelegationFee.md",
    "meta_data": {
      "title": "IWNatDelegationFee",
      "description": "Manages the delegation fees set by voters for WFLR delegations.",
      "sidebar_position": 8
    },
    "type": "answer"
  },
  {
    "content": "Manages the registration of voters for upcoming reward epochs.\n\nSourced from `IVoterRegistry.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IVoterRegistry.sol).\n\nManages the registration of voters for upcoming reward epochs.\n\nSourced from `IVoterRegistry.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IVoterRegistry.sol).\n\nManages the registration of voters for upcoming reward epochs.\n\nSourced from `IVoterRegistry.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IVoterRegistry.sol).\n\nManages the registration of voters for upcoming reward epochs.\n\nSourced from `IVoterRegistry.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IVoterRegistry.sol).",
    "file_name": "files/hub-docs/network/fsp/solidity-reference/IVoterRegistry.md",
    "meta_data": {
      "title": "IVoterRegistry",
      "sidebar_position": 6,
      "description": "Manages the registration of voters for upcoming reward epochs."
    },
    "type": "answer"
  },
  {
    "content": "Performs calculations for weights and burn factors used by other contracts.\n\nSourced from `IFlareSystemsCalculator.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IFlareSystemsCalculator.sol).\n\nPerforms calculations for weights and burn factors used by other contracts.\n\nSourced from `IFlareSystemsCalculator.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IFlareSystemsCalculator.sol).\n\nPerforms calculations for weights and burn factors used by other contracts.\n\nSourced from `IFlareSystemsCalculator.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IFlareSystemsCalculator.sol).",
    "file_name": "files/hub-docs/network/fsp/solidity-reference/IFlareSystemsCalculator.md",
    "meta_data": {
      "title": "IFlareSystemsCalculator",
      "sidebar_position": 7,
      "description": "Performs calculations for weights and burn factors used by other contracts."
    },
    "type": "answer"
  },
  {
    "content": "Manages voter entities, including addresses and node IDs.\n\nSourced from `IEntityManager.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IEntityManager.sol).\n\nManages voter entities, including addresses and node IDs.\n\nSourced from `IEntityManager.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IEntityManager.sol).\n\nManages voter entities, including addresses and node IDs.\n\nSourced from `IEntityManager.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IEntityManager.sol).\n\nManages voter entities, including addresses and node IDs.\n\nSourced from `IEntityManager.sol` on [GitHub](https://github.com/flare-foundation/flare-smart-contracts-v2/blob/main/contracts/userInterfaces/IEntityManager.sol).",
    "file_name": "files/hub-docs/network/fsp/solidity-reference/IEntityManager.md",
    "meta_data": {
      "title": "IEntityManager",
      "sidebar_position": 1,
      "description": "Manages voter entities, including addresses and node IDs."
    },
    "type": "answer"
  },
  {
    "content": "Along with the endpoints listed to interact with its own networks, Flare offers public [RPC](../tech/glossary.md#rpc) nodes for a series of other blockchain networks, to bootstrap development of connected services like [attestation providers](../tech/glossary.md#attestation).\n\nAll public [RPC](../tech/glossary.md#rpc) endpoints are experimental and rate-limited to avoid spamming attacks.\nFor a production-grade option check out Flare's [API Portal](../tech/api-portal.md) and the [Google Cloud Marketplace](https://console.cloud.google.com/marketplace/product/flare-public/api-portal-flare-network).\n\n??? info \"Algorand\"\n\n    * **RPC endpoint**: `https://algorand-api.flare.network`\n    * **Sample query**:\n\n        ```bash\n        curl -s -m 10 \\\n        -H \"X-Algo-API-Token: zl748k3wddvld8cvn64utnslbf7otorkijp84se0f58pmuu0shgm27gttpcjpmuq\" \\\n        https://algorand-api.flare.network/v2/status | jq\n        ```\n\n??? info \"Avalanche\"\n\n    * **RPC endpoint**: `https://avalanche-api.flare.network`\n    * **Sample query**:\n\n        ```bash\n        curl -X POST \\\n        -H 'content-type:application/json' \\\n        --data '{\n            \"jsonrpc\": \"2.0\",\n            \"id\": 1,\n            \"method\": \"info.getNodeVersion\"\n        }' https://avalanche-api.flare.network/ext/info | jq\n        ```\n\n??? info \"Bitcoin\"\n\n    * **RPC endpoint**: `https://bitcoin-api.flare.network`\n    * **Sample query**:\n\n    ```bash\n    curl -s -X POST -m 10 -H \"Content-type: application/json\" \\\n    -d '{\"jsonrpc\": \"1.0\", \"id\":\"hc\", \"method\": \"getblockchaininfo\", \"params\":[]}' \\\n    -u public:d681co1pe2l3wcj9adrm2orlk0j5r5gr3wghgxt58tvge594co0k1ciljxq9glei \\\n    https://bitcoin-api.flare.network | jq\n    ```\n\n??? info \"BNB-BSC\"\n\n    * **RPC endpoint**: `https://bnb-bsc-api.flare.network`\n    * **Sample query**:\n\n        ```bash\n        curl -s -X POST -m 10 -H \"Content-Type: application/json\" \\\n        -d '{\"jsonrpc\": \"2.0\", \"id\":67, \"method\":\"eth_blockNumber\", \"params\":[]}' \\\n        https://bnb-bsc-api.flare.network | jq\n        ```\n\n??? info \"Dogecoin\"\n\n    * **RPC endpoint**: `https://dogecoin-api.flare.network`\n    * **Sample query**:\n\n        ```bash\n        curl -s -X POST -m 10 -H \"Content-type: application/json\" \\\n        -d '{\"jsonrpc\": \"1.0\", \"id\":\"hc\", \"method\": \"getblockchaininfo\", \"params\":[]}' \\\n        -u public:6r1e5z3w9g6qruvkzkqvz8w67yqrq5js2cmyl2f1cncbp7gpp7tqixqskuub5v70 \\\n        https://dogecoin-api.flare.network | jq\n        ```\n\n??? info \"Ethereum\"\n\n    Ethereum has two layers: the execution layer and consensus layer, which work in tandem.\n\n    * The execution layer creates blocks with transactions and executes smart contracts.\n    * The consensus layer, sometimes referred to as the beacon chain, governs consensus and was the extra layer required for the Ethereum 2.0 proof-of-stake (PoS) merge.\n\n    These two layers have their own API, which can be called from the provided nodes. When querying the Ethereum network nodes, specifying only the root path `/` will target the execution layer API. Prefixing your path with `/eth` will target the consensus layer API.\n\n    Official API specifications for each layer:\n\n    * [Consensus Layer - API Spec](https://ethereum.github.io/beacon-APIs/#/)\n    * [Execution Layer - API Spec](https://ethereum.github.io/execution-apis/api-documentation/)\n\n    === \"Mainnet\"\n\n        * **RPC endpoint**: `https://ethereum-api.flare.network`\n        * **Sample query - consensus layer**:\n\n            ```bash\n            curl -s -X GET -m 10 -H \"Content-type: application/json\" \\\n            https://ethereum-api.flare.network/eth/v1/beacon/pool/attestations | jq\n            ```\n        * **Sample query - execution layer**:\n\n            ```bash\n            curl -s -X POST -m 10 -H \"Content-Type: application/json\" \\\n            -d '{\"jsonrpc\": \"2.0\", \"id\":67, \"method\":\"eth_blockNumber\", \"params\":[]}' \\\n            https://ethereum-api.flare.network | jq\n            ```\n\n    === \"Goerli\"\n\n        * **RPC endpoint**: `https://goerli-api.flare.network`\n        * **Sample query - consensus layer**:\n\n            ```bash\n            curl -s -X GET -m 10 -H \"Content-type: application/json\" \\\n            https://goerli-api.flare.network/eth/v1/beacon/pool/attestations | jq\n            ```\n        * **Sample query - execution layer**:\n\n            ```bash\n            curl -s -X POST -m 10 -H \"Content-Type: application/json\" \\\n            -d '{\"jsonrpc\": \"2.0\", \"id\":67, \"method\":\"eth_blockNumber\", \"params\":[]}' \\\n            https://goerli-api.flare.network | jq\n            ```\n\n    === \"Sepolia\"\n\n        * **RPC endpoint**: `https://sepolia-api.flare.network`\n        * **Sample query - consensus layer**:\n\n            ```bash\n            curl -s -X GET -m 10 -H \"Content-type: application/json\" \\\n            https://sepolia-api.flare.network/eth/v1/beacon/pool/attestations | jq\n            ```\n        * **Sample query - execution layer**:\n\n            ```bash\n            curl -s -X POST -m 10 -H \"Content-Type: application/json\" \\\n            -d '{\"jsonrpc\": \"2.0\", \"id\":67, \"method\":\"eth_blockNumber\", \"params\":[]}' \\\n            https://sepolia-api.flare.network | jq\n            ```\n\n??? info \"Filecoin\"\n\n    * **RPC endpoint**: `https://filecoin-api.flare.network/rpc/v1`\n    * **Sample query**:\n\n        ```bash\n        curl -X POST -H \"Content-type: application/json\" \\\n        -d '{\"jsonrpc\": \"2.0\", \"id\": \"1\", \"method\": \"Filecoin.NodeStatus\", \"params\": [true]}' \\\n        \"https://filecoin-api.flare.network/rpc/v1\" | jq\n        ```\n\n??? info \"Litecoin\"\n\n    * **RPC endpoint**: `https://litecoin-api.flare.network`\n    * **Sample query**:\n\n        ```bash\n        curl -s -X POST -m 10 -H \"Content-type: application/json\" \\\n        -d '{\"jsonrpc\": \"1.0\", \"id\":\"hc\", \"method\": \"getblockchaininfo\", \"params\":[]}' \\\n        -u public:ntvzi4i1yne499t7vcdjqhhp92m3jvm0bb6dkpr406gkndvuns9sg6th3jd393uc \\\n        https://litecoin-api.flare.network | jq\n        ```\n\n??? info \"Polygon\"\n\n    * **RPC endpoint**: `https://polygon-api.flare.network`\n    * **Sample query**:\n\n        ```bash\n        curl -X GET -H \"Content-type: application/json\" \\\n        https://polygon-api.flare.network/block?height=1000 | jq\n        ```\n\n??? info \"Solana\"\n\n    * **RPC endpoint**: `https://solana-api.flare.network`\n    * **Sample query**:\n\n        ```bash\n        curl -s -X POST -m 10 -H \"Content-type: application/json\" \\\n        -d '{\"jsonrpc\": \"2.0\", \"id\": 1, \"method\": \"getVersion\"}' \\\n        https://solana-api.flare.network | jq\n        ```\n\n??? info \"XRPL\"\n\n    * **RPC endpoint**: `https://xrpl-api.flare.network`\n    * **Sample query**:\n\n        ```bash\n        curl -s -X POST -m 10 -H \"Content-type: application/json\" \\\n        -d '{\"method\": \"server_info\", \"params\":[{\"api_version\": 1}]}' \\\n        https://xrpl-api.flare.network | jq\n        ```\n\n[flrId]: <https://github.com/ethereum-lists/chains/blob/master/_data/chains/eip155-14.json>\n[sgbId]: <https://github.com/ethereum-lists/chains/blob/master/_data/chains/eip155-19.json>\n[cflrId]: <https://github.com/ethereum-lists/chains/blob/master/_data/chains/eip155-16.json>\n[c2flrId]: <https://github.com/ethereum-lists/chains/pull/1559/files>\n[rosetta-api]: <https://www.rosetta-api.org/>",
    "meta_data": {
      "search": {
        "boost": 2
      },
      "title": "Connected Networks"
    },
    "file_name": "files/flare-docs/infra/connected-networks.md",
    "type": "answer"
  },
  {
    "content": "This section contains step-by-step guides on how to deploy the different components that make up the Flare ecosystem, and be rewarded for it.",
    "meta_data": {
      "title": "Infrastructure Guides"
    },
    "file_name": "files/flare-docs/infra/index.md",
    "type": "answer"
  },
  {
    "content": "In this section you can read more about Flare's core protocols and products. \n\n* [FTSO](../tech/ftso/index.md)\n* [Flare Data connector](../tech/data-connector.md)\n* [FAssets](https://dev.flare.network/fassets/overview)\n* [Validator nodes](../tech/validators.md)\n* [API Portal](../tech/api-portal.md)",
    "meta_data": {
      "title": "Products"
    },
    "file_name": "files/flare-docs/products/index.md",
    "type": "answer"
  },
  {
    "content": "Automatic claiming enables users to appoint an executor to claim rewards on their behalf.\n\nAutomatic claiming enables users to appoint an executor to claim rewards on their behalf.\n\nAutomatic claiming enables users to appoint an executor to claim rewards on their behalf.\n\nAutomatic claiming enables users to appoint an executor to claim rewards on their behalf.\n\nAutomatic claiming enables users to appoint an executor to claim rewards on their behalf.",
    "file_name": "files/flare-docs/tech/automatic-claiming.md",
    "meta_data": {
      "search": {
        "boost": 2
      },
      "title": "Automatic Claiming"
    },
    "type": "answer"
  },
  {
    "content": "## Introduction\n\nFlare governance gives everyone in the ecosystem the opportunity to collaborate on decision-making on the [Flare and Songbird](./flare.md#flare-networks) networks, making governance an important element of decentralization.\n\nThis process enables the Flare Foundation and Flare and Songbird community members to:\n\n* Propose policy changes.\n* Vote on them.\n* Execute them if accepted.\n\nThe following sections detail the different kinds of proposals Flare allows and the process for each of them.\n\nIf you are already familiar with Flare's governance and just need to know how to cast your vote through the Flare Portal, check the [Voting User Guide](../user/governance/voting.md).\n\n## Introduction\n\nFlare governance gives everyone in the ecosystem the opportunity to collaborate on decision-making on the [Flare and Songbird](./flare.md#flare-networks) networks, making governance an important element of decentralization.\n\nThis process enables the Flare Foundation and Flare and Songbird community members to:\n\n* Propose policy changes.\n* Vote on them.\n* Execute them if accepted.\n\nThe following sections detail the different kinds of proposals Flare allows and the process for each of them.\n\nIf you are already familiar with Flare's governance and just need to know how to cast your vote through the Flare Portal, check the [Voting User Guide](../user/governance/voting.md).\n\n## Introduction\n\nFlare governance gives everyone in the ecosystem the opportunity to collaborate on decision-making on the [Flare and Songbird](./flare.md#flare-networks) networks, making governance an important element of decentralization.\n\nThis process enables the Flare Foundation and Flare and Songbird community members to:\n\n* Propose policy changes.\n* Vote on them.\n* Execute them if accepted.\n\nThe following sections detail the different kinds of proposals Flare allows and the process for each of them.\n\nIf you are already familiar with Flare's governance and just need to know how to cast your vote through the Flare Portal, check the [Voting User Guide](../user/governance/voting.md).\n\n## Introduction\n\nFlare governance gives everyone in the ecosystem the opportunity to collaborate on decision-making on the [Flare and Songbird](./flare.md#flare-networks) networks, making governance an important element of decentralization.\n\nThis process enables the Flare Foundation and Flare and Songbird community members to:\n\n* Propose policy changes.\n* Vote on them.\n* Execute them if accepted.\n\nThe following sections detail the different kinds of proposals Flare allows and the process for each of them.\n\nIf you are already familiar with Flare's governance and just need to know how to cast your vote through the Flare Portal, check the [Voting User Guide](../user/governance/voting.md).",
    "file_name": "files/flare-docs/tech/governance.md",
    "meta_data": {
      "search": {
        "boost": 2
      },
      "title": "Governance"
    },
    "type": "answer"
  },
  {
    "content": "The FlareDrop, previously called the _Delegation Incentive Pool_ in the [FIP.01](https://flare.network/fip01/), is a distribution method for the 24.25B remaining `$FLR` tokens after the [original airdrop](./archive/flare-launch-process.md#definitions).\nIt will last for 36 months and is destined for any holder of wrapped `$FLR` (`$WFLR`) that participates in the network as per the FIP.01.\n\nIf you enabled your [PDA](./personal-delegation-account.md) and it contains `$WFLR`, it is also eligible to receive the FlareDrop distribution.\nMake sure to check both your **Main Account** and your **Delegation Account** for FlareDrop to claim.\n\nThe FlareDrop, previously called the _Delegation Incentive Pool_ in the [FIP.01](https://flare.network/fip01/), is a distribution method for the 24.25B remaining `$FLR` tokens after the [original airdrop](./archive/flare-launch-process.md#definitions).\nIt will last for 36 months and is destined for any holder of wrapped `$FLR` (`$WFLR`) that participates in the network as per the FIP.01.\n\nIf you enabled your [PDA](./personal-delegation-account.md) and it contains `$WFLR`, it is also eligible to receive the FlareDrop distribution.\nMake sure to check both your **Main Account** and your **Delegation Account** for FlareDrop to claim.\n\nThe FlareDrop, previously called the _Delegation Incentive Pool_ in the [FIP.01](https://flare.network/fip01/), is a distribution method for the 24.25B remaining `$FLR` tokens after the [original airdrop](./archive/flare-launch-process.md#definitions).\nIt will last for 36 months and is destined for any holder of wrapped `$FLR` (`$WFLR`) that participates in the network as per the FIP.01.\n\nIf you enabled your [PDA](./personal-delegation-account.md) and it contains `$WFLR`, it is also eligible to receive the FlareDrop distribution.\nMake sure to check both your **Main Account** and your **Delegation Account** for FlareDrop to claim.",
    "file_name": "files/flare-docs/tech/the-flaredrop.md",
    "meta_data": {
      "search": {
        "boost": 1
      },
      "title": "The FlareDrop"
    },
    "type": "answer"
  },
  {
    "content": "Decentralization will be achieved by moving the transaction validation duty **from the Flare Foundation to community-run FTSO** [data providers](glossary.md#data_provider), but this will not happen instantly.\n\nInstead, to ensure a safe transition, a number of **professional validators** were initially enabled and continue to be employed.\n\nThe professional validators were chosen among companies with proven experience running blockchain infrastructure and **at first held most of the validation power**.\nThis power, though, will be **progressively shifted** onto the community-run validators until they run the network on their own.\n\nThis initial period is called **Flare Beta**, and it will span several [launch phases](./archive/flare-launch-process.md).\n\nDecentralization will be achieved by moving the transaction validation duty **from the Flare Foundation to community-run FTSO** [data providers](glossary.md#data_provider), but this will not happen instantly.\n\nInstead, to ensure a safe transition, a number of **professional validators** were initially enabled and continue to be employed.\n\nThe professional validators were chosen among companies with proven experience running blockchain infrastructure and **at first held most of the validation power**.\nThis power, though, will be **progressively shifted** onto the community-run validators until they run the network on their own.\n\nThis initial period is called **Flare Beta**, and it will span several [launch phases](./archive/flare-launch-process.md).",
    "file_name": "files/flare-docs/tech/flare-beta.md",
    "meta_data": {
      "search": {
        "boost": 2
      },
      "title": "Flare Beta"
    },
    "type": "answer"
  },
  {
    "content": "The Flare Systems Protocol (FSP) is the core protocol that provides basic functionality to support current and future Flare protocols.\n\nBy taking care of tasks common to the rest of Flare protocols, the FSP greatly simplifies them and the dapps that interact with them.\n\nInteraction with the FSP depends on your role:\n\n* As a Flare user, common activities such as governance voting, delegating, and staking do not require direct access to the FSP.\n* As an infrastructure provider, access is required because you participate in decentralized data acquisition and validation for all Flare protocols. An update to infrastructure provider procedures is in progress.\n* As a developer, writing dapps requires access to the FSP, which simplifies development by using a similar approach for all Flare protocols. A more detailed introduction for developers is in progress.\n\nThe FSP manages the results of infrastructure providers' votes and rewards in a way that brings scalability to Flare protocols.\nWith the FSP, only a representation of the data validation results (called a [Merkle Root](glossary.md#merkle_root) hash) is stored on-chain, so it is more lightweight and scalable than, for example, storing all prices for the FTSO.\nBecause only the hashes are stored on-chain, applications retrieve the actual data directly from infrastructure providers and then verify it using the on-chain hash.\n\nThe Flare Systems Protocol (FSP) is the core protocol that provides basic functionality to support current and future Flare protocols.\n\nBy taking care of tasks common to the rest of Flare protocols, the FSP greatly simplifies them and the dapps that interact with them.\n\nInteraction with the FSP depends on your role:\n\n* As a Flare user, common activities such as governance voting, delegating, and staking do not require direct access to the FSP.\n* As an infrastructure provider, access is required because you participate in decentralized data acquisition and validation for all Flare protocols. An update to infrastructure provider procedures is in progress.\n* As a developer, writing dapps requires access to the FSP, which simplifies development by using a similar approach for all Flare protocols. A more detailed introduction for developers is in progress.\n\nThe FSP manages the results of infrastructure providers' votes and rewards in a way that brings scalability to Flare protocols.\nWith the FSP, only a representation of the data validation results (called a [Merkle Root](glossary.md#merkle_root) hash) is stored on-chain, so it is more lightweight and scalable than, for example, storing all prices for the FTSO.\nBecause only the hashes are stored on-chain, applications retrieve the actual data directly from infrastructure providers and then verify it using the on-chain hash.\n\nThe Flare Systems Protocol (FSP) is the core protocol that provides basic functionality to support current and future Flare protocols.\n\nBy taking care of tasks common to the rest of Flare protocols, the FSP greatly simplifies them and the dapps that interact with them.\n\nInteraction with the FSP depends on your role:\n\n* As a Flare user, common activities such as governance voting, delegating, and staking do not require direct access to the FSP.\n* As an infrastructure provider, access is required because you participate in decentralized data acquisition and validation for all Flare protocols. An update to infrastructure provider procedures is in progress.\n* As a developer, writing dapps requires access to the FSP, which simplifies development by using a similar approach for all Flare protocols. A more detailed introduction for developers is in progress.\n\nThe FSP manages the results of infrastructure providers' votes and rewards in a way that brings scalability to Flare protocols.\nWith the FSP, only a representation of the data validation results (called a [Merkle Root](glossary.md#merkle_root) hash) is stored on-chain, so it is more lightweight and scalable than, for example, storing all prices for the FTSO.\nBecause only the hashes are stored on-chain, applications retrieve the actual data directly from infrastructure providers and then verify it using the on-chain hash.",
    "file_name": "files/flare-docs/tech/flare-systems-protocol.md",
    "meta_data": {
      "title": "Flare Systems Protocol"
    },
    "type": "answer"
  },
  {
    "content": "The Flare Systems Protocol (FSP) is the core protocol that provides basic functionality to support current and future Flare protocols.\n\nBy taking care of tasks common to the rest of Flare protocols, the FSP greatly simplifies them and the dapps that interact with them.\n\nInteraction with the FSP depends on your role:\n\n* As a Flare user, common activities such as governance voting, delegating, and staking do not require direct access to the FSP.\n* As an infrastructure provider, access is required because you participate in decentralized data acquisition and validation for all Flare protocols. An update to infrastructure provider procedures is in progress.\n* As a developer, writing dapps requires access to the FSP, which simplifies development by using a similar approach for all Flare protocols. A more detailed introduction for developers is in progress.\n\nThe FSP manages the results of infrastructure providers' votes and rewards in a way that brings scalability to Flare protocols.\nWith the FSP, only a representation of the data validation results (called a [Merkle Root](glossary.md#merkle_root) hash) is stored on-chain, so it is more lightweight and scalable than, for example, storing all prices for the FTSO.\nBecause only the hashes are stored on-chain, applications retrieve the actual data directly from infrastructure providers and then verify it using the on-chain hash.",
    "file_name": "files/flare-docs/tech/flare-systems-protocol.md",
    "meta_data": {
      "title": "Flare Systems Protocol"
    },
    "type": "answer"
  },
  {
    "content": "Flare's API Portal is a paid product that gives developers access to a number of **private nodes** running on different blockchains, including Flare, [Songbird](glossary.md#songbird) and [Coston](glossary.md#coston), but also other networks like Bitcoin or XRPL.\n\nThese nodes are **not rate-limited**, so it is typically **more convenient** to connect your apps to them than to deploy your own nodes, or connect to public nodes.\n\nThis is one more step towards Flare's goal to **connect all blockchains**.\n\n!!! info \"Visit [Flare's API Portal website](https://api-portal.flare.network/)\"\n\n!!! question \"Visit the [API Portal's FAQ](https://api-portal.flare.network/support) if you are having authentication issues!\"",
    "meta_data": {
      "search": {
        "boost": 2
      },
      "title": "Flare API Portal"
    },
    "file_name": "files/flare-docs/tech/api-portal.md",
    "type": "answer"
  },
  {
    "content": "!!! image inline end \"\"\n    ![Flare logo](logo-FLR.png){ .allow-zoom }\n\nFlare is the blockchain for data.\nIt is a [layer 1](glossary.md#layer1), [EVM](glossary.md#evm) [smart contract](glossary.md#smart_contract) platform designed to expand the utility of blockchain.\n\nFlare's aim is to provide data as a public good, meaning that data is not controlled by a centralized entity and is available to all.\nThe infrastructure providers, which perform doubly as [validators](../tech/validators.md) and data providers, enable two native [oracles](glossary.md#oracle), the [FTSO](./ftso/index.md) and the [Flare Data Connector](./data-connector.md).\nThis [native](glossary.md#native) processing provides developers on Flare with efficient access to large amounts of data and [data proofs](glossary.md#data_proof) at minimal cost, with which to build software on the platform.\n\nBy giving developers [trustless](glossary.md#trustless) access to the broadest range of data needed by the software they build, Flare can advance the development of more blockchain use cases where data is important, such as in [DeFi](glossary.md#defi), gaming, [NFT](glossary.md#nft), music, social networks, Real World Assets [(RWAs)](glossary.md#rwa), Machine Learning (ML), and Artificial Intelligence (AI).\n\n!!! image inline end \"\"\n    ![Flare logo](logo-FLR.png){ .allow-zoom }\n\nFlare is the blockchain for data.\nIt is a [layer 1](glossary.md#layer1), [EVM](glossary.md#evm) [smart contract](glossary.md#smart_contract) platform designed to expand the utility of blockchain.\n\nFlare's aim is to provide data as a public good, meaning that data is not controlled by a centralized entity and is available to all.\nThe infrastructure providers, which perform doubly as [validators](../tech/validators.md) and data providers, enable two native [oracles](glossary.md#oracle), the [FTSO](./ftso/index.md) and the [Flare Data Connector](./data-connector.md).\nThis [native](glossary.md#native) processing provides developers on Flare with efficient access to large amounts of data and [data proofs](glossary.md#data_proof) at minimal cost, with which to build software on the platform.\n\nBy giving developers [trustless](glossary.md#trustless) access to the broadest range of data needed by the software they build, Flare can advance the development of more blockchain use cases where data is important, such as in [DeFi](glossary.md#defi), gaming, [NFT](glossary.md#nft), music, social networks, Real World Assets [(RWAs)](glossary.md#rwa), Machine Learning (ML), and Artificial Intelligence (AI).\n\n!!! image inline end \"\"\n    ![Flare logo](logo-FLR.png){ .allow-zoom }\n\nFlare is the blockchain for data.\nIt is a [layer 1](glossary.md#layer1), [EVM](glossary.md#evm) [smart contract](glossary.md#smart_contract) platform designed to expand the utility of blockchain.\n\nFlare's aim is to provide data as a public good, meaning that data is not controlled by a centralized entity and is available to all.\nThe infrastructure providers, which perform doubly as [validators](../tech/validators.md) and data providers, enable two native [oracles](glossary.md#oracle), the [FTSO](./ftso/index.md) and the [Flare Data Connector](./data-connector.md).\nThis [native](glossary.md#native) processing provides developers on Flare with efficient access to large amounts of data and [data proofs](glossary.md#data_proof) at minimal cost, with which to build software on the platform.\n\nBy giving developers [trustless](glossary.md#trustless) access to the broadest range of data needed by the software they build, Flare can advance the development of more blockchain use cases where data is important, such as in [DeFi](glossary.md#defi), gaming, [NFT](glossary.md#nft), music, social networks, Real World Assets [(RWAs)](glossary.md#rwa), Machine Learning (ML), and Artificial Intelligence (AI).",
    "file_name": "files/flare-docs/tech/flare.md",
    "meta_data": {
      "search": {
        "boost": 2
      },
      "title": "What Is Flare?"
    },
    "type": "answer"
  },
  {
    "content": "!!! image inline end \"\"\n    ![Flare logo](logo-FLR.png){ .allow-zoom }\n\nFlare is the blockchain for data.\nIt is a [layer 1](glossary.md#layer1), [EVM](glossary.md#evm) [smart contract](glossary.md#smart_contract) platform designed to expand the utility of blockchain.\n\nFlare's aim is to provide data as a public good, meaning that data is not controlled by a centralized entity and is available to all.\nThe infrastructure providers, which perform doubly as [validators](../tech/validators.md) and data providers, enable two native [oracles](glossary.md#oracle), the [FTSO](./ftso/index.md) and the [Flare Data Connector](./data-connector.md).\nThis [native](glossary.md#native) processing provides developers on Flare with efficient access to large amounts of data and [data proofs](glossary.md#data_proof) at minimal cost, with which to build software on the platform.\n\nBy giving developers [trustless](glossary.md#trustless) access to the broadest range of data needed by the software they build, Flare can advance the development of more blockchain use cases where data is important, such as in [DeFi](glossary.md#defi), gaming, [NFT](glossary.md#nft), music, social networks, Real World Assets [(RWAs)](glossary.md#rwa), Machine Learning (ML), and Artificial Intelligence (AI).\n\n!!! image inline end \"\"\n    ![Flare logo](logo-FLR.png){ .allow-zoom }\n\nFlare is the blockchain for data.\nIt is a [layer 1](glossary.md#layer1), [EVM](glossary.md#evm) [smart contract](glossary.md#smart_contract) platform designed to expand the utility of blockchain.\n\nFlare's aim is to provide data as a public good, meaning that data is not controlled by a centralized entity and is available to all.\nThe infrastructure providers, which perform doubly as [validators](../tech/validators.md) and data providers, enable two native [oracles](glossary.md#oracle), the [FTSO](./ftso/index.md) and the [Flare Data Connector](./data-connector.md).\nThis [native](glossary.md#native) processing provides developers on Flare with efficient access to large amounts of data and [data proofs](glossary.md#data_proof) at minimal cost, with which to build software on the platform.\n\nBy giving developers [trustless](glossary.md#trustless) access to the broadest range of data needed by the software they build, Flare can advance the development of more blockchain use cases where data is important, such as in [DeFi](glossary.md#defi), gaming, [NFT](glossary.md#nft), music, social networks, Real World Assets [(RWAs)](glossary.md#rwa), Machine Learning (ML), and Artificial Intelligence (AI).",
    "file_name": "files/flare-docs/tech/flare.md",
    "meta_data": {
      "search": {
        "boost": 2
      },
      "title": "What Is Flare?"
    },
    "type": "answer"
  },
  {
    "content": "## Blockchain Validation\n\nValidator nodes are **online servers** running a blockchain's client software.\nThey all keep their own copy of the [ledger](glossary.md#ledger) and are constantly talking to other nodes to make sure the copies are **consistent with each other** as new data is added.\n\n<figure markdown>\n  ![Validator node network](validator-network.png){ loading=lazy .allow-zoom width=500px }\n  <figcaption>A network of validator nodes, each one with an identical copy of the ledger.</figcaption>\n</figure>\n\nThe fact that the ledger is not under control of a single entity but **distributed among a network of independent validators** is what makes blockchains:\n\n* Require less trust than traditional options (said to be [_trustless_](glossary.md#trustless)).\n* Censorship resistant.\n* [Byzantine fault-tolerant](glossary.md#byzantine_fault_tolerance).\n\nValidators agree on the state of the ledger using a [consensus algorithm](glossary.md#consensus) that varies for each blockchain.\nFor example, Flare uses the **Snowman++** consensus protocol from [Avalanche](glossary.md#avalanche).\n\n!!! info \"Snowman++\"\n    During each round, a validator is **randomly selected** to act as the **leader** and propose new blocks to be added to the ledger, which are then validated by the rest of nodes.\n    To provide [Sybil resistance](glossary.md#sybil_resistance), the probability that a node is elected the leader is **proportional to the node's stake**, effectively enacting a [proof-of-stake](glossary.md#proof_of_stake) consensus.\n\nWith its vision to be the blockchain for data, Flare adds the [FTSO Data provider](./ftso/index.md) and [Attestation Provider](./data-connector.md) roles to validators, creating a single _infrastructure entity_.\n\nWhen fully operational, these decentralized infrastructure entities are responsible for:\n\n* Securing the network through proof-of-stake consensus.\n* Providing continuous data to the FTSO system.\n* Answering the Data Connector's queries for attestations.\n\nIn this way, the stake required to operate these entities secures all three functions.\n\nInfrastructure entities are rewarded for each one of these roles, a process that involves staking on the [P-chain](https://docs.avax.network/learn/avalanche/avalanche-platform#p-chain) and rewards that are calculated on smart contracts running on the [C-chain](https://docs.avax.network/learn/avalanche/avalanche-platform#c-chain).\n\n## Blockchain Validation\n\nValidator nodes are **online servers** running a blockchain's client software.\nThey all keep their own copy of the [ledger](glossary.md#ledger) and are constantly talking to other nodes to make sure the copies are **consistent with each other** as new data is added.\n\n<figure markdown>\n  ![Validator node network](validator-network.png){ loading=lazy .allow-zoom width=500px }\n  <figcaption>A network of validator nodes, each one with an identical copy of the ledger.</figcaption>\n</figure>\n\nThe fact that the ledger is not under control of a single entity but **distributed among a network of independent validators** is what makes blockchains:\n\n* Require less trust than traditional options (said to be [_trustless_](glossary.md#trustless)).\n* Censorship resistant.\n* [Byzantine fault-tolerant](glossary.md#byzantine_fault_tolerance).\n\nValidators agree on the state of the ledger using a [consensus algorithm](glossary.md#consensus) that varies for each blockchain.\nFor example, Flare uses the **Snowman++** consensus protocol from [Avalanche](glossary.md#avalanche).\n\n!!! info \"Snowman++\"\n    During each round, a validator is **randomly selected** to act as the **leader** and propose new blocks to be added to the ledger, which are then validated by the rest of nodes.\n    To provide [Sybil resistance](glossary.md#sybil_resistance), the probability that a node is elected the leader is **proportional to the node's stake**, effectively enacting a [proof-of-stake](glossary.md#proof_of_stake) consensus.\n\nWith its vision to be the blockchain for data, Flare adds the [FTSO Data provider](./ftso/index.md) and [Attestation Provider](./data-connector.md) roles to validators, creating a single _infrastructure entity_.\n\nWhen fully operational, these decentralized infrastructure entities are responsible for:\n\n* Securing the network through proof-of-stake consensus.\n* Providing continuous data to the FTSO system.\n* Answering the Data Connector's queries for attestations.\n\nIn this way, the stake required to operate these entities secures all three functions.\n\nInfrastructure entities are rewarded for each one of these roles, a process that involves staking on the [P-chain](https://docs.avax.network/learn/avalanche/avalanche-platform#p-chain) and rewards that are calculated on smart contracts running on the [C-chain](https://docs.avax.network/learn/avalanche/avalanche-platform#c-chain).",
    "file_name": "files/flare-docs/tech/validators.md",
    "meta_data": {
      "search": {
        "boost": 2
      },
      "title": "Validator Nodes"
    },
    "type": "answer"
  },
  {
    "content": "## Blockchain Validation\n\nValidator nodes are **online servers** running a blockchain's client software.\nThey all keep their own copy of the [ledger](glossary.md#ledger) and are constantly talking to other nodes to make sure the copies are **consistent with each other** as new data is added.\n\n<figure markdown>\n  ![Validator node network](validator-network.png){ loading=lazy .allow-zoom width=500px }\n  <figcaption>A network of validator nodes, each one with an identical copy of the ledger.</figcaption>\n</figure>\n\nThe fact that the ledger is not under control of a single entity but **distributed among a network of independent validators** is what makes blockchains:\n\n* Require less trust than traditional options (said to be [_trustless_](glossary.md#trustless)).\n* Censorship resistant.\n* [Byzantine fault-tolerant](glossary.md#byzantine_fault_tolerance).\n\nValidators agree on the state of the ledger using a [consensus algorithm](glossary.md#consensus) that varies for each blockchain.\nFor example, Flare uses the **Snowman++** consensus protocol from [Avalanche](glossary.md#avalanche).\n\n!!! info \"Snowman++\"\n    During each round, a validator is **randomly selected** to act as the **leader** and propose new blocks to be added to the ledger, which are then validated by the rest of nodes.\n    To provide [Sybil resistance](glossary.md#sybil_resistance), the probability that a node is elected the leader is **proportional to the node's stake**, effectively enacting a [proof-of-stake](glossary.md#proof_of_stake) consensus.\n\nWith its vision to be the blockchain for data, Flare adds the [FTSO Data provider](./ftso/index.md) and [Attestation Provider](./data-connector.md) roles to validators, creating a single _infrastructure entity_.\n\nWhen fully operational, these decentralized infrastructure entities are responsible for:\n\n* Securing the network through proof-of-stake consensus.\n* Providing continuous data to the FTSO system.\n* Answering the Data Connector's queries for attestations.\n\nIn this way, the stake required to operate these entities secures all three functions.\n\nInfrastructure entities are rewarded for each one of these roles, a process that involves staking on the [P-chain](https://docs.avax.network/learn/avalanche/avalanche-platform#p-chain) and rewards that are calculated on smart contracts running on the [C-chain](https://docs.avax.network/learn/avalanche/avalanche-platform#c-chain).",
    "file_name": "files/flare-docs/tech/validators.md",
    "meta_data": {
      "search": {
        "boost": 2
      },
      "title": "Validator Nodes"
    },
    "type": "answer"
  },
  {
    "content": "## Introduction\n\nThe **Flare Data Connector (FDC)** is a smart contract running on the Flare network that allows anyone to query **non-changing, verifiable information** (such as blockchain or geographic data) from **outside the Flare network**.\nData that changes, such as the latest BTC to USD conversion rate, and non-verifiable data, such as data behind a paywall, are not available through the Data Connector.\n\nThe Data Connector accesses data in a **decentralized manner** (no single party is in control of the process) and **securely** (it takes a lot of effort to disrupt the process).\nThis is accomplished by using a set of **independent attestation providers** which fetch the required information from the world and deliver it to the Flare network.\nThe Data Connector smart contract then checks if there is **enough consensus** among the received answers and **publishes the results** if so.\n\nAs an added security measure, individual validators can also define **local attestation providers** which, when in disagreement with the rest, cause the validator to **branch** into an idle, safe state while the situation is resolved.\n\n<figure markdown>\n  ![The Data Connector](SC-intro.png){ loading=lazy .allow-zoom width=500px }\n  <figcaption>The Data Connector.</figcaption>\n</figure>\n\nThe Data Connector can, for instance, **check whether a deposit has been made on another blockchain**, opening the door to more advanced mechanisms like FAssets or bridges.\n\nThis page gives technical details about the whole procedure, the different security and scalability measures that have been taken into account in its design and the kind of queries that can be performed.\n\n## Introduction\n\nThe **Flare Data Connector (FDC)** is a smart contract running on the Flare network that allows anyone to query **non-changing, verifiable information** (such as blockchain or geographic data) from **outside the Flare network**.\nData that changes, such as the latest BTC to USD conversion rate, and non-verifiable data, such as data behind a paywall, are not available through the Data Connector.\n\nThe Data Connector accesses data in a **decentralized manner** (no single party is in control of the process) and **securely** (it takes a lot of effort to disrupt the process).\nThis is accomplished by using a set of **independent attestation providers** which fetch the required information from the world and deliver it to the Flare network.\nThe Data Connector smart contract then checks if there is **enough consensus** among the received answers and **publishes the results** if so.\n\nAs an added security measure, individual validators can also define **local attestation providers** which, when in disagreement with the rest, cause the validator to **branch** into an idle, safe state while the situation is resolved.\n\n<figure markdown>\n  ![The Data Connector](SC-intro.png){ loading=lazy .allow-zoom width=500px }\n  <figcaption>The Data Connector.</figcaption>\n</figure>\n\nThe Data Connector can, for instance, **check whether a deposit has been made on another blockchain**, opening the door to more advanced mechanisms like FAssets or bridges.\n\nThis page gives technical details about the whole procedure, the different security and scalability measures that have been taken into account in its design and the kind of queries that can be performed.",
    "file_name": "files/flare-docs/tech/data-connector.md",
    "meta_data": {
      "search": {
        "boost": 2
      },
      "title": "Flare Data Connector"
    },
    "type": "answer"
  },
  {
    "content": "## Introduction\n\nThe **Flare Data Connector (FDC)** is a smart contract running on the Flare network that allows anyone to query **non-changing, verifiable information** (such as blockchain or geographic data) from **outside the Flare network**.\nData that changes, such as the latest BTC to USD conversion rate, and non-verifiable data, such as data behind a paywall, are not available through the Data Connector.\n\nThe Data Connector accesses data in a **decentralized manner** (no single party is in control of the process) and **securely** (it takes a lot of effort to disrupt the process).\nThis is accomplished by using a set of **independent attestation providers** which fetch the required information from the world and deliver it to the Flare network.\nThe Data Connector smart contract then checks if there is **enough consensus** among the received answers and **publishes the results** if so.\n\nAs an added security measure, individual validators can also define **local attestation providers** which, when in disagreement with the rest, cause the validator to **branch** into an idle, safe state while the situation is resolved.\n\n<figure markdown>\n  ![The Data Connector](SC-intro.png){ loading=lazy .allow-zoom width=500px }\n  <figcaption>The Data Connector.</figcaption>\n</figure>\n\nThe Data Connector can, for instance, **check whether a deposit has been made on another blockchain**, opening the door to more advanced mechanisms like FAssets or bridges.\n\nThis page gives technical details about the whole procedure, the different security and scalability measures that have been taken into account in its design and the kind of queries that can be performed.\n\n## Introduction\n\nThe **Flare Data Connector (FDC)** is a smart contract running on the Flare network that allows anyone to query **non-changing, verifiable information** (such as blockchain or geographic data) from **outside the Flare network**.\nData that changes, such as the latest BTC to USD conversion rate, and non-verifiable data, such as data behind a paywall, are not available through the Data Connector.\n\nThe Data Connector accesses data in a **decentralized manner** (no single party is in control of the process) and **securely** (it takes a lot of effort to disrupt the process).\nThis is accomplished by using a set of **independent attestation providers** which fetch the required information from the world and deliver it to the Flare network.\nThe Data Connector smart contract then checks if there is **enough consensus** among the received answers and **publishes the results** if so.\n\nAs an added security measure, individual validators can also define **local attestation providers** which, when in disagreement with the rest, cause the validator to **branch** into an idle, safe state while the situation is resolved.\n\n<figure markdown>\n  ![The Data Connector](SC-intro.png){ loading=lazy .allow-zoom width=500px }\n  <figcaption>The Data Connector.</figcaption>\n</figure>\n\nThe Data Connector can, for instance, **check whether a deposit has been made on another blockchain**, opening the door to more advanced mechanisms like FAssets or bridges.\n\nThis page gives technical details about the whole procedure, the different security and scalability measures that have been taken into account in its design and the kind of queries that can be performed.",
    "file_name": "files/flare-docs/tech/data-connector.md",
    "meta_data": {
      "search": {
        "boost": 2
      },
      "title": "Flare Data Connector"
    },
    "type": "answer"
  },
  {
    "content": "## Introduction\n\nThe **Flare Data Connector (FDC)** is a smart contract running on the Flare network that allows anyone to query **non-changing, verifiable information** (such as blockchain or geographic data) from **outside the Flare network**.\nData that changes, such as the latest BTC to USD conversion rate, and non-verifiable data, such as data behind a paywall, are not available through the Data Connector.\n\nThe Data Connector accesses data in a **decentralized manner** (no single party is in control of the process) and **securely** (it takes a lot of effort to disrupt the process).\nThis is accomplished by using a set of **independent attestation providers** which fetch the required information from the world and deliver it to the Flare network.\nThe Data Connector smart contract then checks if there is **enough consensus** among the received answers and **publishes the results** if so.\n\nAs an added security measure, individual validators can also define **local attestation providers** which, when in disagreement with the rest, cause the validator to **branch** into an idle, safe state while the situation is resolved.\n\n<figure markdown>\n  ![The Data Connector](SC-intro.png){ loading=lazy .allow-zoom width=500px }\n  <figcaption>The Data Connector.</figcaption>\n</figure>\n\nThe Data Connector can, for instance, **check whether a deposit has been made on another blockchain**, opening the door to more advanced mechanisms like FAssets or bridges.\n\nThis page gives technical details about the whole procedure, the different security and scalability measures that have been taken into account in its design and the kind of queries that can be performed.\n\n## Introduction\n\nThe **Flare Data Connector (FDC)** is a smart contract running on the Flare network that allows anyone to query **non-changing, verifiable information** (such as blockchain or geographic data) from **outside the Flare network**.\nData that changes, such as the latest BTC to USD conversion rate, and non-verifiable data, such as data behind a paywall, are not available through the Data Connector.\n\nThe Data Connector accesses data in a **decentralized manner** (no single party is in control of the process) and **securely** (it takes a lot of effort to disrupt the process).\nThis is accomplished by using a set of **independent attestation providers** which fetch the required information from the world and deliver it to the Flare network.\nThe Data Connector smart contract then checks if there is **enough consensus** among the received answers and **publishes the results** if so.\n\nAs an added security measure, individual validators can also define **local attestation providers** which, when in disagreement with the rest, cause the validator to **branch** into an idle, safe state while the situation is resolved.\n\n<figure markdown>\n  ![The Data Connector](SC-intro.png){ loading=lazy .allow-zoom width=500px }\n  <figcaption>The Data Connector.</figcaption>\n</figure>\n\nThe Data Connector can, for instance, **check whether a deposit has been made on another blockchain**, opening the door to more advanced mechanisms like FAssets or bridges.\n\nThis page gives technical details about the whole procedure, the different security and scalability measures that have been taken into account in its design and the kind of queries that can be performed.",
    "file_name": "files/flare-docs/tech/data-connector.md",
    "meta_data": {
      "search": {
        "boost": 2
      },
      "title": "Flare Data Connector"
    },
    "type": "answer"
  },
  {
    "content": "Flare token holders are eligible to receive a number of rewards, for example through [FTSO Delegation](./ftso/index.md#delegation).\nThe Flare network offers the option to set up Personal Delegation Accounts (PDAs) to temporarily receive and store rewards to track which funds are from rewards, for example, for personal or tax purposes.\nIn certain jurisdictions, delaying the realization of earnings for a specified time can lead to a reduced tax rate.\n\nEach Flare address can be associated with one PDA, which behaves like a regular account in many respects.\nFor example, it can receive funds from any address.\nLike regular accounts, it is under control of the owner and can perform functions such as delegation and claiming.\n\nHere are some of the differences from a regular account:\n\n* A PDA cannot have another PDA of its own.\n* PDA addresses cannot participate in [governance](./governance.md) directly, but their owners can transfer all their votes to another address (their main account or someone else's).\n* A PDA automatically converts any `$FLR` tokens transferred to it to wrapped Flare tokens (`$WFLR`), which are more useful for functions such as delegation.\n* Only the owner of the main account can transfer funds from the PDA and only to the main account.\n* When an [executor](./automatic-claiming.md) is configured, it will claim rewards both from the main account and the PDA, and send them to the PDA.\n\n!!! warning\n\n    The Flare Foundation is not liable for any damages, especially pertaining to tax related issues when using this service.\n    Check your local tax laws.\n\nFlare token holders are eligible to receive a number of rewards, for example through [FTSO Delegation](./ftso/index.md#delegation).\nThe Flare network offers the option to set up Personal Delegation Accounts (PDAs) to temporarily receive and store rewards to track which funds are from rewards, for example, for personal or tax purposes.\nIn certain jurisdictions, delaying the realization of earnings for a specified time can lead to a reduced tax rate.\n\nEach Flare address can be associated with one PDA, which behaves like a regular account in many respects.\nFor example, it can receive funds from any address.\nLike regular accounts, it is under control of the owner and can perform functions such as delegation and claiming.\n\nHere are some of the differences from a regular account:\n\n* A PDA cannot have another PDA of its own.\n* PDA addresses cannot participate in [governance](./governance.md) directly, but their owners can transfer all their votes to another address (their main account or someone else's).\n* A PDA automatically converts any `$FLR` tokens transferred to it to wrapped Flare tokens (`$WFLR`), which are more useful for functions such as delegation.\n* Only the owner of the main account can transfer funds from the PDA and only to the main account.\n* When an [executor](./automatic-claiming.md) is configured, it will claim rewards both from the main account and the PDA, and send them to the PDA.\n\n!!! warning\n\n    The Flare Foundation is not liable for any damages, especially pertaining to tax related issues when using this service.\n    Check your local tax laws.",
    "file_name": "files/flare-docs/tech/personal-delegation-account.md",
    "meta_data": {
      "search": {
        "boost": 1
      },
      "title": "Personal Delegation Accounts"
    },
    "type": "answer"
  },
  {
    "content": "This section contains in-depth descriptions of Flare's key concepts, technology and tools.\n\nSelect one of the topics below:\n\n* [What Is Flare?](./flare.md)\n* [Automatic Claiming](./automatic-claiming.md)\n* [FAssets](https://dev.flare.network/fassets/overview)\n* [Flare API Portal](./api-portal.md)\n* [Flare Beta](./flare-beta.md)\n* [Flare Systems Protocol](./flare-systems-protocol.md)\n* [The FlareDrop](./the-flaredrop.md)\n* [FTSO](./ftso/index.md)\n* [Governance](./governance.md)\n* [Personal Delegation Accounts](./personal-delegation-account.md)\n* [Flare Data Connector](./data-connector.md)\n* [Tokenomics](./tokenomics.md)\n* [Validator Nodes](./validators.md)\n* [Glossary](./glossary.md)\n* [Archive](./archive/index.md)",
    "meta_data": {
      "search": {
        "boost": 2
      },
      "title": "Concepts"
    },
    "file_name": "files/flare-docs/tech/index.md",
    "type": "answer"
  },
  {
    "content": "Flare\u2019s token economics support Flare\u2019s ambition to connect the decentralized economy and drive broader adoption of web3.\nThese tokenomics help to create a more balanced playing field where multiple connected ecosystems have an incentive to grow and participate with Flare.\nThe adoption of [FIP.01][fip-01] on [January 27, 2023](https://portal.flare.network/proposal/view/31313223399225215467886651717691514407244212421129328237186875197531473335173) enabled this approach by changing the mechanism of the public token distribution.\n\nFlare\u2019s token economics support Flare\u2019s ambition to connect the decentralized economy and drive broader adoption of web3.\nThese tokenomics help to create a more balanced playing field where multiple connected ecosystems have an incentive to grow and participate with Flare.\nThe adoption of [FIP.01][fip-01] on [January 27, 2023](https://portal.flare.network/proposal/view/31313223399225215467886651717691514407244212421129328237186875197531473335173) enabled this approach by changing the mechanism of the public token distribution.\n\nFlare\u2019s token economics support Flare\u2019s ambition to connect the decentralized economy and drive broader adoption of web3.\nThese tokenomics help to create a more balanced playing field where multiple connected ecosystems have an incentive to grow and participate with Flare.\nThe adoption of [FIP.01][fip-01] on [January 27, 2023](https://portal.flare.network/proposal/view/31313223399225215467886651717691514407244212421129328237186875197531473335173) enabled this approach by changing the mechanism of the public token distribution.\n\nFlare\u2019s token economics support Flare\u2019s ambition to connect the decentralized economy and drive broader adoption of web3.\nThese tokenomics help to create a more balanced playing field where multiple connected ecosystems have an incentive to grow and participate with Flare.\nThe adoption of [FIP.01][fip-01] on [January 27, 2023](https://portal.flare.network/proposal/view/31313223399225215467886651717691514407244212421129328237186875197531473335173) enabled this approach by changing the mechanism of the public token distribution.\n\nFlare\u2019s token economics support Flare\u2019s ambition to connect the decentralized economy and drive broader adoption of web3.\nThese tokenomics help to create a more balanced playing field where multiple connected ecosystems have an incentive to grow and participate with Flare.\nThe adoption of [FIP.01][fip-01] on [January 27, 2023](https://portal.flare.network/proposal/view/31313223399225215467886651717691514407244212421129328237186875197531473335173) enabled this approach by changing the mechanism of the public token distribution.\n\nFlare\u2019s token economics support Flare\u2019s ambition to connect the decentralized economy and drive broader adoption of web3.\nThese tokenomics help to create a more balanced playing field where multiple connected ecosystems have an incentive to grow and participate with Flare.\nThe adoption of [FIP.01][fip-01] on [January 27, 2023](https://portal.flare.network/proposal/view/31313223399225215467886651717691514407244212421129328237186875197531473335173) enabled this approach by changing the mechanism of the public token distribution.\n\nFlare\u2019s token economics support Flare\u2019s ambition to connect the decentralized economy and drive broader adoption of web3.\nThese tokenomics help to create a more balanced playing field where multiple connected ecosystems have an incentive to grow and participate with Flare.\nThe adoption of [FIP.01][fip-01] on [January 27, 2023](https://portal.flare.network/proposal/view/31313223399225215467886651717691514407244212421129328237186875197531473335173) enabled this approach by changing the mechanism of the public token distribution.\n\nFlare\u2019s token economics support Flare\u2019s ambition to connect the decentralized economy and drive broader adoption of web3.\nThese tokenomics help to create a more balanced playing field where multiple connected ecosystems have an incentive to grow and participate with Flare.\nThe adoption of [FIP.01][fip-01] on [January 27, 2023](https://portal.flare.network/proposal/view/31313223399225215467886651717691514407244212421129328237186875197531473335173) enabled this approach by changing the mechanism of the public token distribution.\n\nFlare\u2019s token economics support Flare\u2019s ambition to connect the decentralized economy and drive broader adoption of web3.\nThese tokenomics help to create a more balanced playing field where multiple connected ecosystems have an incentive to grow and participate with Flare.\nThe adoption of [FIP.01][fip-01] on [January 27, 2023](https://portal.flare.network/proposal/view/31313223399225215467886651717691514407244212421129328237186875197531473335173) enabled this approach by changing the mechanism of the public token distribution.",
    "file_name": "files/flare-docs/tech/tokenomics.md",
    "meta_data": {
      "title": "Tokenomics"
    },
    "type": "answer"
  },
  {
    "content": "To save time, maximize compound interest, and avoid unnecessary exposure of a cold wallet, you can set an [executor](../tech/automatic-claiming.md) to claim rewards for you.\nExecutors then use automatic claiming to send rewards directly to your account.\n\nTo save time, maximize compound interest, and avoid unnecessary exposure of a cold wallet, you can set an [executor](../tech/automatic-claiming.md) to claim rewards for you.\nExecutors then use automatic claiming to send rewards directly to your account.\n\nTo save time, maximize compound interest, and avoid unnecessary exposure of a cold wallet, you can set an [executor](../tech/automatic-claiming.md) to claim rewards for you.\nExecutors then use automatic claiming to send rewards directly to your account.\n\nTo save time, maximize compound interest, and avoid unnecessary exposure of a cold wallet, you can set an [executor](../tech/automatic-claiming.md) to claim rewards for you.\nExecutors then use automatic claiming to send rewards directly to your account.\n\nTo save time, maximize compound interest, and avoid unnecessary exposure of a cold wallet, you can set an [executor](../tech/automatic-claiming.md) to claim rewards for you.\nExecutors then use automatic claiming to send rewards directly to your account.\n\nTo save time, maximize compound interest, and avoid unnecessary exposure of a cold wallet, you can set an [executor](../tech/automatic-claiming.md) to claim rewards for you.\nExecutors then use automatic claiming to send rewards directly to your account.",
    "file_name": "files/flare-docs/user/automatic-claiming.md",
    "meta_data": {
      "title": "Automatic Claiming"
    },
    "type": "answer"
  },
  {
    "content": "This information explains how to wrap and unwrap native tokens on various Flare networks using the [Flare Portal](https://portal.flare.network) or the block explorer.\nWrapped tokens are required to [delegate your vote power](../tech/ftso/index.md#delegation) to FTSO data providers and to [vote on decisions](../tech/governance.md) that affect how Flare networks operate.\n\nWhen you complete the following steps for wrapping, your native tokens, such as `$FLR` and `$SGB`, are wrapped into `$WFLR` and `$WSGB`, respectively, so that you can participate in FTSO delegation and governance.\nWhen you need to convert your wrapped tokens into native tokens again, unwrap the wrapped tokens using similar steps, as described below.\n\nThis information explains how to wrap and unwrap native tokens on various Flare networks using the [Flare Portal](https://portal.flare.network) or the block explorer.\nWrapped tokens are required to [delegate your vote power](../tech/ftso/index.md#delegation) to FTSO data providers and to [vote on decisions](../tech/governance.md) that affect how Flare networks operate.\n\nWhen you complete the following steps for wrapping, your native tokens, such as `$FLR` and `$SGB`, are wrapped into `$WFLR` and `$WSGB`, respectively, so that you can participate in FTSO delegation and governance.\nWhen you need to convert your wrapped tokens into native tokens again, unwrap the wrapped tokens using similar steps, as described below.\n\nThis information explains how to wrap and unwrap native tokens on various Flare networks using the [Flare Portal](https://portal.flare.network) or the block explorer.\nWrapped tokens are required to [delegate your vote power](../tech/ftso/index.md#delegation) to FTSO data providers and to [vote on decisions](../tech/governance.md) that affect how Flare networks operate.\n\nWhen you complete the following steps for wrapping, your native tokens, such as `$FLR` and `$SGB`, are wrapped into `$WFLR` and `$WSGB`, respectively, so that you can participate in FTSO delegation and governance.\nWhen you need to convert your wrapped tokens into native tokens again, unwrap the wrapped tokens using similar steps, as described below.\n\nThis information explains how to wrap and unwrap native tokens on various Flare networks using the [Flare Portal](https://portal.flare.network) or the block explorer.\nWrapped tokens are required to [delegate your vote power](../tech/ftso/index.md#delegation) to FTSO data providers and to [vote on decisions](../tech/governance.md) that affect how Flare networks operate.\n\nWhen you complete the following steps for wrapping, your native tokens, such as `$FLR` and `$SGB`, are wrapped into `$WFLR` and `$WSGB`, respectively, so that you can participate in FTSO delegation and governance.\nWhen you need to convert your wrapped tokens into native tokens again, unwrap the wrapped tokens using similar steps, as described below.",
    "file_name": "files/flare-docs/user/wrapping-tokens.md",
    "meta_data": {
      "search": {
        "boost": 2
      },
      "title": "Wrapping Flare Tokens"
    },
    "type": "answer"
  },
  {
    "content": "You can receive `$WFLR` rewards for making contributions to the Flare community, for example, by [delegating](../tech/ftso/index.md#delegation) your tokens to FTSO data providers.\n\nA Personal Delegation Account (PDA) allows you to keep these rewards temporarily separate from your main account, so that you can track them, for example, as a personal record or for tax purposes.\nIn certain jurisdictions, delaying the realization of earnings for a specified time can lead to a reduced tax rate.\nSee [the Concept page](../tech/personal-delegation-account.md) for more detail.\n\nParticularly, the balance of a PDA can still be redelegated to earn compounded interest and the governance votes it grants can be transferred to another address.\n\nIf a PDA is enabled and you configured an [executor](../tech/automatic-claiming.md), it automatically claims rewards for the main account and the PDA, and sends them to the PDA.\n\nYou can receive `$WFLR` rewards for making contributions to the Flare community, for example, by [delegating](../tech/ftso/index.md#delegation) your tokens to FTSO data providers.\n\nA Personal Delegation Account (PDA) allows you to keep these rewards temporarily separate from your main account, so that you can track them, for example, as a personal record or for tax purposes.\nIn certain jurisdictions, delaying the realization of earnings for a specified time can lead to a reduced tax rate.\nSee [the Concept page](../tech/personal-delegation-account.md) for more detail.\n\nParticularly, the balance of a PDA can still be redelegated to earn compounded interest and the governance votes it grants can be transferred to another address.\n\nIf a PDA is enabled and you configured an [executor](../tech/automatic-claiming.md), it automatically claims rewards for the main account and the PDA, and sends them to the PDA.\n\nYou can receive `$WFLR` rewards for making contributions to the Flare community, for example, by [delegating](../tech/ftso/index.md#delegation) your tokens to FTSO data providers.\n\nA Personal Delegation Account (PDA) allows you to keep these rewards temporarily separate from your main account, so that you can track them, for example, as a personal record or for tax purposes.\nIn certain jurisdictions, delaying the realization of earnings for a specified time can lead to a reduced tax rate.\nSee [the Concept page](../tech/personal-delegation-account.md) for more detail.\n\nParticularly, the balance of a PDA can still be redelegated to earn compounded interest and the governance votes it grants can be transferred to another address.\n\nIf a PDA is enabled and you configured an [executor](../tech/automatic-claiming.md), it automatically claims rewards for the main account and the PDA, and sends them to the PDA.",
    "file_name": "files/flare-docs/user/personal-delegation-account.md",
    "meta_data": {
      "title": "Personal Delegation Accounts"
    },
    "type": "answer"
  },
  {
    "content": "This section contains step-by-step guides on how to use tools like the Block Explorer or the different wallets.\n\nSelect one of the topics below:\n\n* [Automatic Claiming](./automatic-claiming.md)\n* [Claiming the FlareDrop](./claiming-the-flaredrop.md)\n* [FTSO Delegation](./delegation/index.md)\n* [Governance](./governance/index.md)\n* [Personal Delegation Accounts](./personal-delegation-account.md)\n* [Staking on Validators](./staking/index.md)\n* [Wallets](./wallets/index.md)\n* [Wrapping Tokens](./wrapping-tokens.md)",
    "meta_data": {
      "title": "User Guides"
    },
    "file_name": "files/flare-docs/user/index.md",
    "type": "answer"
  },
  {
    "content": "Claiming the FlareDrop is available every 30 days and is based on the average balance from the last 23 days of each 30-day month.\nTherefore, it is advised that each address claim its funds during the first 7 days of each 30-day round.\n\nSee [The FlareDrop concept page](../tech/the-flaredrop.md) for further explanation.\n\n<figure markdown>\n![FlareDrop Distribution Dates](flaredrop-distribution-dates.png){ loading=lazy .allow-zoom  width=500px }\n<figcaption>FlareDrop distribution dates.</figcaption>\n</figure>\n\nThere are several ways to claim.\nYou can claim:\n\n* Using the [Flare Portal](https://portal.flare.network/).\n* Through an [executor](../tech/automatic-claiming.md), which you can configure using the Portal, or\n\n!!! warning \"Two steps to ensure receiving all your `$FLR` !\"\n\n    You must:\n\n    1. **Wrap `$FLR` to receive it.**\n    Rewards are proportional to the `$WFLR` balance, not `$FLR`, so always wrap as much `$FLR` as you can!\n    Wrapping has no downside: Wrapped tokens continue to be available for [delegation](../tech/ftso/index.md#delegation) and [governance voting](../tech/governance.md), for example, and they can be unwrapped at any time.\n    See [Wrapping Flare Tokens](../user/wrapping-tokens.md).\n    2. **Claim before the distribution expires.**\n    After the distribution becomes claimable, it expires in two bank months and a week (67 days).\n\nClaiming the FlareDrop is available every 30 days and is based on the average balance from the last 23 days of each 30-day month.\nTherefore, it is advised that each address claim its funds during the first 7 days of each 30-day round.\n\nSee [The FlareDrop concept page](../tech/the-flaredrop.md) for further explanation.\n\n<figure markdown>\n![FlareDrop Distribution Dates](flaredrop-distribution-dates.png){ loading=lazy .allow-zoom  width=500px }\n<figcaption>FlareDrop distribution dates.</figcaption>\n</figure>\n\nThere are several ways to claim.\nYou can claim:\n\n* Using the [Flare Portal](https://portal.flare.network/).\n* Through an [executor](../tech/automatic-claiming.md), which you can configure using the Portal, or\n\n!!! warning \"Two steps to ensure receiving all your `$FLR` !\"\n\n    You must:\n\n    1. **Wrap `$FLR` to receive it.**\n    Rewards are proportional to the `$WFLR` balance, not `$FLR`, so always wrap as much `$FLR` as you can!\n    Wrapping has no downside: Wrapped tokens continue to be available for [delegation](../tech/ftso/index.md#delegation) and [governance voting](../tech/governance.md), for example, and they can be unwrapped at any time.\n    See [Wrapping Flare Tokens](../user/wrapping-tokens.md).\n    2. **Claim before the distribution expires.**\n    After the distribution becomes claimable, it expires in two bank months and a week (67 days).\n\nClaiming the FlareDrop is available every 30 days and is based on the average balance from the last 23 days of each 30-day month.\nTherefore, it is advised that each address claim its funds during the first 7 days of each 30-day round.\n\nSee [The FlareDrop concept page](../tech/the-flaredrop.md) for further explanation.\n\n<figure markdown>\n![FlareDrop Distribution Dates](flaredrop-distribution-dates.png){ loading=lazy .allow-zoom  width=500px }\n<figcaption>FlareDrop distribution dates.</figcaption>\n</figure>\n\nThere are several ways to claim.\nYou can claim:\n\n* Using the [Flare Portal](https://portal.flare.network/).\n* Through an [executor](../tech/automatic-claiming.md), which you can configure using the Portal, or\n\n!!! warning \"Two steps to ensure receiving all your `$FLR` !\"\n\n    You must:\n\n    1. **Wrap `$FLR` to receive it.**\n    Rewards are proportional to the `$WFLR` balance, not `$FLR`, so always wrap as much `$FLR` as you can!\n    Wrapping has no downside: Wrapped tokens continue to be available for [delegation](../tech/ftso/index.md#delegation) and [governance voting](../tech/governance.md), for example, and they can be unwrapped at any time.\n    See [Wrapping Flare Tokens](../user/wrapping-tokens.md).\n    2. **Claim before the distribution expires.**\n    After the distribution becomes claimable, it expires in two bank months and a week (67 days).",
    "file_name": "files/flare-docs/user/claiming-the-flaredrop.md",
    "meta_data": {
      "title": "Claiming the FlareDrop"
    },
    "type": "answer"
  },
  {
    "content": "When you make delegations to data providers, you increase their vote power, reinforce the stability of the FTSO ecosystem, and earn monetary rewards.\n\nThis information explains how to manage your delegations using the [Flare Portal](https://portal.flare.network). Alternatively, if you have used block explorers for other networks and are competent interacting with smart contracts without a user interface, you can use the block explorer, which provides more options but can be more complex. Using it is intended for advanced users.\n\nWhen you make delegations to data providers, you increase their vote power, reinforce the stability of the FTSO ecosystem, and earn monetary rewards.\n\nThis information explains how to manage your delegations using the [Flare Portal](https://portal.flare.network). Alternatively, if you have used block explorers for other networks and are competent interacting with smart contracts without a user interface, you can use the block explorer, which provides more options but can be more complex. Using it is intended for advanced users.",
    "file_name": "files/flare-docs/user/delegation/managing-delegations.md",
    "meta_data": {
      "title": "Managing Delegations Using the Flare Portal"
    },
    "type": "answer"
  },
  {
    "content": "[Rewards](../../tech/ftso/index.md#rewards) are accrued from your delegations to FTSO data providers whose submitted data is close to the calculated median value in a price epoch.\n\nUse this information to claim FTSO delegation rewards by using the Flare Portal. Alternatively, if you have used block explorers for other networks and are competent interacting with smart contracts without a user interface, you can use the block explorer, which provides more options but can be more complex. Using it is intended for advanced users.\n\n1. Open the [Flare Portal](https://portal.flare.network). The home page is displayed.\n\n    <figure markdown>\n    ![Flare Portal Home](delegation-portal-connect.png){ loading=lazy .allow-zoom width=500px }\n    <figcaption>Flare Portal home.</figcaption>\n    </figure>\n\n2. Click **Connect to Wallet** and log into your wallet. The interface to your **Main Account** opens.\n\n--8<--\n    ./include/wallet-warning.md\n--8<--\n\n3. Ensure you are connected to the network you want. In the following image, the wallet is connected to the Flare network.\n\n    <figure markdown>\n    ![Flare Portal Main Account](delegation-portal-main.png){ loading=lazy .allow-zoom width=500px }\n    <figcaption>**Main Account** on the Flare network.</figcaption>\n    </figure>\n\n4. On the **Main Account** tab, locate the **Claim your delegation rewards** section to determine whether you have claimable rewards and whether those rewards can currently be claimed:\n\n    * If you have rewards to claim and the reward manager contains enough tokens, the **Claim** button is enabled and shows the amount of rewards you can claim. Go to Step 5.\n    * If you have rewards to claim, but the reward manager currently does not contain enough tokens, the **Claim** button shows the amount of rewards you can claim but is disabled.\n\n        For security reasons, a **limited amount of tokens** is stored at a given time in the reward manager contract.\n        Sometimes, all delegators claim their rewards in a short period of time immediately after the reward epoch ends, and the token storage is depleted.\n        The storage is replenished periodically.\n        If you are currently unable to claim your rewards because the storage is empty, **try again the next day**.\n\n    * If you don't have claimable rewards, the **Claim** button shows **0** and is disabled.\n\n    The following image shows an account with claimable rewards:\n\n    <figure markdown>\n    ![Account with claimable rewards](delegation-portal-main.png){ loading=lazy .allow-zoom width=500px }\n    <figcaption>An account with claimable rewards.</figcaption>\n    </figure>\n\n5. Click the **Claim** button. The **Claim your delegation rewards** window is displayed.\n\n    <figure markdown>\n    ![Claim your delegation rewards](rewards-portal-claim.png){ loading=lazy .allow-zoom width=500px }\n    <figcaption>Claim your delegation rewards.</figcaption>\n    </figure>\n\n6. **Optional**: If you have enabled your [personal delegation account](../../tech/personal-delegation-account.md), the option to send your rewards to the PDA is preselected by default.\n    To send your rewards to the address that you connected to the Portal instead, deselect the option.\n7. Click **Claim All Rewards** to claim all available rewards for the listed epochs.\n\n8. Follow the steps to confirm the transaction in your wallet.\n\nYour rewards are claimed, and your updated balance of native tokens is displayed.",
    "meta_data": {
      "title": "Managing Rewards Using the Flare Portal"
    },
    "file_name": "files/flare-docs/user/delegation/managing-rewards.md",
    "type": "answer"
  },
  {
    "content": "Select one of the topics below:\n\n* [Managing Delegations](./managing-delegations.md)\n* [Managing Rewards](./managing-rewards.md)",
    "meta_data": {
      "title": "FTSO Delegation"
    },
    "file_name": "files/flare-docs/user/delegation/index.md",
    "type": "answer"
  },
  {
    "content": "An integral part of the [governance process](../../tech/governance.md), voting is the way you influence decisions about how Flare and Songbird operate.\n\nThis process can be performed directly through Flare's smart contracts, but the Flare Foundation has developed the [Flare Portal](https://portal.flare.network) to enable you to conveniently cast your vote.\n\nThe following information is about voting on the Flare and Songbird networks.\nEnsure you have selected one of these networks in your wallet.\n\nAn integral part of the [governance process](../../tech/governance.md), voting is the way you influence decisions about how Flare and Songbird operate.\n\nThis process can be performed directly through Flare's smart contracts, but the Flare Foundation has developed the [Flare Portal](https://portal.flare.network) to enable you to conveniently cast your vote.\n\nThe following information is about voting on the Flare and Songbird networks.\nEnsure you have selected one of these networks in your wallet.\n\nAn integral part of the [governance process](../../tech/governance.md), voting is the way you influence decisions about how Flare and Songbird operate.\n\nThis process can be performed directly through Flare's smart contracts, but the Flare Foundation has developed the [Flare Portal](https://portal.flare.network) to enable you to conveniently cast your vote.\n\nThe following information is about voting on the Flare and Songbird networks.\nEnsure you have selected one of these networks in your wallet.\n\nAn integral part of the [governance process](../../tech/governance.md), voting is the way you influence decisions about how Flare and Songbird operate.\n\nThis process can be performed directly through Flare's smart contracts, but the Flare Foundation has developed the [Flare Portal](https://portal.flare.network) to enable you to conveniently cast your vote.\n\nThe following information is about voting on the Flare and Songbird networks.\nEnsure you have selected one of these networks in your wallet.\n\nAn integral part of the [governance process](../../tech/governance.md), voting is the way you influence decisions about how Flare and Songbird operate.\n\nThis process can be performed directly through Flare's smart contracts, but the Flare Foundation has developed the [Flare Portal](https://portal.flare.network) to enable you to conveniently cast your vote.\n\nThe following information is about voting on the Flare and Songbird networks.\nEnsure you have selected one of these networks in your wallet.",
    "file_name": "files/flare-docs/user/governance/voting.md",
    "meta_data": {
      "title": "Voting"
    },
    "type": "answer"
  },
  {
    "content": "This section contains information about participating in governance on the Flare and Songbird networks.\n\n* [Voting](./voting.md)",
    "meta_data": {
      "title": "Governance"
    },
    "file_name": "files/flare-docs/user/governance/index.md",
    "type": "answer"
  },
  {
    "content": "[FlareStake](https://staking.flare.network) is a graphical user interface (GUI) that enables you to easily stake your funds to validators and earn rewards.\n\nStaking works by locking funds for a period of time to support a specific [network validator](../../tech/validators.md).\nWhen validator owners stake to their own nodes they _self-bond_, whereas all other participants are said to _delegate_ their stake to that validator.\nNote that delegating your stake to a validator is different from [FTSO delegation](../../tech/ftso/index.md/#delegation).\n\n!!! note\n\n    Proof of stake is being implemented on Flare in phases.\n    Ensure that you have read the [Validators page](../../tech/validators.md#deployment-phases) to learn about them.\n\nParticipants choose how much to stake and for how long their stake will be locked.\nThe minimum values are:\n{ #minimum-values }\n\n|                  | Self-bond | Delegation |\n| ---------------- | --------: | ---------: |\n| Minimum amount   | 1M `$FLR` | 50K `$FLR` |\n| Minimum duration |   60 days |    14 days |\n\nAt the end of every [reward epoch](../../tech/ftso/index.md#reward-epoch), participants are rewarded according to how well their chosen validator performed in that period.\n\n!!! info \"Staking limits\"\n\n    When you choose your validator and amount to stake, consider the [delegation factor and the staking cap](./index.md#limits).\n\n    You can stake to any number of validators, but [rewards](./staking-flarestake.md#reward-claiming-guide), [FlareDrops](../../tech/the-flaredrop.md), and [governance vote power](../../tech/governance.md#the-vote-count-block) only apply for up to 3 different validators.\n\nThe [deployment phases summary](../../tech/validators.md#summary) shows other rewards that staked funds can still earn while they are locked.\n\nGiven that the Flare network uses two [independent underlying chains](../../tech/flare.md#flare-chains), there is one extra step that must be considered.\nFunds must be transferred from the C-chain, where smart contracts run, to the P-chain, where staking happens.\nAfter the staking period expires and funds are unlocked, they can be transferred back to the C-chain.\n\nThis guide explains how to stake Flare assets by using [FlareStake, the GUI tool for staking](https://staking.flare.network).\nAnother tool exists which uses the command line exclusively.\nSee the [Using the CLI to Stake](./staking-cli.md) guide to learn about it.\n\n[FlareStake](https://staking.flare.network) is a graphical user interface (GUI) that enables you to easily stake your funds to validators and earn rewards.\n\nStaking works by locking funds for a period of time to support a specific [network validator](../../tech/validators.md).\nWhen validator owners stake to their own nodes they _self-bond_, whereas all other participants are said to _delegate_ their stake to that validator.\nNote that delegating your stake to a validator is different from [FTSO delegation](../../tech/ftso/index.md/#delegation).\n\n!!! note\n\n    Proof of stake is being implemented on Flare in phases.\n    Ensure that you have read the [Validators page](../../tech/validators.md#deployment-phases) to learn about them.\n\nParticipants choose how much to stake and for how long their stake will be locked.\nThe minimum values are:\n{ #minimum-values }\n\n|                  | Self-bond | Delegation |\n| ---------------- | --------: | ---------: |\n| Minimum amount   | 1M `$FLR` | 50K `$FLR` |\n| Minimum duration |   60 days |    14 days |\n\nAt the end of every [reward epoch](../../tech/ftso/index.md#reward-epoch), participants are rewarded according to how well their chosen validator performed in that period.\n\n!!! info \"Staking limits\"\n\n    When you choose your validator and amount to stake, consider the [delegation factor and the staking cap](./index.md#limits).\n\n    You can stake to any number of validators, but [rewards](./staking-flarestake.md#reward-claiming-guide), [FlareDrops](../../tech/the-flaredrop.md), and [governance vote power](../../tech/governance.md#the-vote-count-block) only apply for up to 3 different validators.\n\nThe [deployment phases summary](../../tech/validators.md#summary) shows other rewards that staked funds can still earn while they are locked.\n\nGiven that the Flare network uses two [independent underlying chains](../../tech/flare.md#flare-chains), there is one extra step that must be considered.\nFunds must be transferred from the C-chain, where smart contracts run, to the P-chain, where staking happens.\nAfter the staking period expires and funds are unlocked, they can be transferred back to the C-chain.\n\nThis guide explains how to stake Flare assets by using [FlareStake, the GUI tool for staking](https://staking.flare.network).\nAnother tool exists which uses the command line exclusively.\nSee the [Using the CLI to Stake](./staking-cli.md) guide to learn about it.",
    "file_name": "files/flare-docs/user/staking/staking-flarestake.md",
    "meta_data": {
      "title": "Using FlareStake to Stake"
    },
    "type": "answer"
  },
  {
    "content": "[FlareStake](https://staking.flare.network) is a graphical user interface (GUI) that enables you to easily stake your funds to validators and earn rewards.\n\nStaking works by locking funds for a period of time to support a specific [network validator](../../tech/validators.md).\nWhen validator owners stake to their own nodes they _self-bond_, whereas all other participants are said to _delegate_ their stake to that validator.\nNote that delegating your stake to a validator is different from [FTSO delegation](../../tech/ftso/index.md/#delegation).\n\n!!! note\n\n    Proof of stake is being implemented on Flare in phases.\n    Ensure that you have read the [Validators page](../../tech/validators.md#deployment-phases) to learn about them.\n\nParticipants choose how much to stake and for how long their stake will be locked.\nThe minimum values are:\n{ #minimum-values }\n\n|                  | Self-bond | Delegation |\n| ---------------- | --------: | ---------: |\n| Minimum amount   | 1M `$FLR` | 50K `$FLR` |\n| Minimum duration |   60 days |    14 days |\n\nAt the end of every [reward epoch](../../tech/ftso/index.md#reward-epoch), participants are rewarded according to how well their chosen validator performed in that period.\n\n!!! info \"Staking limits\"\n\n    When you choose your validator and amount to stake, consider the [delegation factor and the staking cap](./index.md#limits).\n\n    You can stake to any number of validators, but [rewards](./staking-flarestake.md#reward-claiming-guide), [FlareDrops](../../tech/the-flaredrop.md), and [governance vote power](../../tech/governance.md#the-vote-count-block) only apply for up to 3 different validators.\n\nThe [deployment phases summary](../../tech/validators.md#summary) shows other rewards that staked funds can still earn while they are locked.\n\nGiven that the Flare network uses two [independent underlying chains](../../tech/flare.md#flare-chains), there is one extra step that must be considered.\nFunds must be transferred from the C-chain, where smart contracts run, to the P-chain, where staking happens.\nAfter the staking period expires and funds are unlocked, they can be transferred back to the C-chain.\n\nThis guide explains how to stake Flare assets by using [FlareStake, the GUI tool for staking](https://staking.flare.network).\nAnother tool exists which uses the command line exclusively.\nSee the [Using the CLI to Stake](./staking-cli.md) guide to learn about it.\n\n[FlareStake](https://staking.flare.network) is a graphical user interface (GUI) that enables you to easily stake your funds to validators and earn rewards.\n\nStaking works by locking funds for a period of time to support a specific [network validator](../../tech/validators.md).\nWhen validator owners stake to their own nodes they _self-bond_, whereas all other participants are said to _delegate_ their stake to that validator.\nNote that delegating your stake to a validator is different from [FTSO delegation](../../tech/ftso/index.md/#delegation).\n\n!!! note\n\n    Proof of stake is being implemented on Flare in phases.\n    Ensure that you have read the [Validators page](../../tech/validators.md#deployment-phases) to learn about them.\n\nParticipants choose how much to stake and for how long their stake will be locked.\nThe minimum values are:\n{ #minimum-values }\n\n|                  | Self-bond | Delegation |\n| ---------------- | --------: | ---------: |\n| Minimum amount   | 1M `$FLR` | 50K `$FLR` |\n| Minimum duration |   60 days |    14 days |\n\nAt the end of every [reward epoch](../../tech/ftso/index.md#reward-epoch), participants are rewarded according to how well their chosen validator performed in that period.\n\n!!! info \"Staking limits\"\n\n    When you choose your validator and amount to stake, consider the [delegation factor and the staking cap](./index.md#limits).\n\n    You can stake to any number of validators, but [rewards](./staking-flarestake.md#reward-claiming-guide), [FlareDrops](../../tech/the-flaredrop.md), and [governance vote power](../../tech/governance.md#the-vote-count-block) only apply for up to 3 different validators.\n\nThe [deployment phases summary](../../tech/validators.md#summary) shows other rewards that staked funds can still earn while they are locked.\n\nGiven that the Flare network uses two [independent underlying chains](../../tech/flare.md#flare-chains), there is one extra step that must be considered.\nFunds must be transferred from the C-chain, where smart contracts run, to the P-chain, where staking happens.\nAfter the staking period expires and funds are unlocked, they can be transferred back to the C-chain.\n\nThis guide explains how to stake Flare assets by using [FlareStake, the GUI tool for staking](https://staking.flare.network).\nAnother tool exists which uses the command line exclusively.\nSee the [Using the CLI to Stake](./staking-cli.md) guide to learn about it.",
    "file_name": "files/flare-docs/user/staking/staking-flarestake.md",
    "meta_data": {
      "title": "Using FlareStake to Stake"
    },
    "type": "answer"
  },
  {
    "content": "[FlareStake](https://staking.flare.network) is a graphical user interface (GUI) that enables you to easily stake your funds to validators and earn rewards.\n\nStaking works by locking funds for a period of time to support a specific [network validator](../../tech/validators.md).\nWhen validator owners stake to their own nodes they _self-bond_, whereas all other participants are said to _delegate_ their stake to that validator.\nNote that delegating your stake to a validator is different from [FTSO delegation](../../tech/ftso/index.md/#delegation).\n\n!!! note\n\n    Proof of stake is being implemented on Flare in phases.\n    Ensure that you have read the [Validators page](../../tech/validators.md#deployment-phases) to learn about them.\n\nParticipants choose how much to stake and for how long their stake will be locked.\nThe minimum values are:\n{ #minimum-values }\n\n|                  | Self-bond | Delegation |\n| ---------------- | --------: | ---------: |\n| Minimum amount   | 1M `$FLR` | 50K `$FLR` |\n| Minimum duration |   60 days |    14 days |\n\nAt the end of every [reward epoch](../../tech/ftso/index.md#reward-epoch), participants are rewarded according to how well their chosen validator performed in that period.\n\n!!! info \"Staking limits\"\n\n    When you choose your validator and amount to stake, consider the [delegation factor and the staking cap](./index.md#limits).\n\n    You can stake to any number of validators, but [rewards](./staking-flarestake.md#reward-claiming-guide), [FlareDrops](../../tech/the-flaredrop.md), and [governance vote power](../../tech/governance.md#the-vote-count-block) only apply for up to 3 different validators.\n\nThe [deployment phases summary](../../tech/validators.md#summary) shows other rewards that staked funds can still earn while they are locked.\n\nGiven that the Flare network uses two [independent underlying chains](../../tech/flare.md#flare-chains), there is one extra step that must be considered.\nFunds must be transferred from the C-chain, where smart contracts run, to the P-chain, where staking happens.\nAfter the staking period expires and funds are unlocked, they can be transferred back to the C-chain.\n\nThis guide explains how to stake Flare assets by using [FlareStake, the GUI tool for staking](https://staking.flare.network).\nAnother tool exists which uses the command line exclusively.\nSee the [Using the CLI to Stake](./staking-cli.md) guide to learn about it.",
    "file_name": "files/flare-docs/user/staking/staking-flarestake.md",
    "meta_data": {
      "title": "Using FlareStake to Stake"
    },
    "type": "answer"
  },
  {
    "content": "The [Flare Portal](https://portal.flare.network/) is a dapp developed by Flare Network that enables you to earn rewards by staking your `$FLR` in your MetaMask wallet to validators on the Flare network.\n\nAlternatively, you can use the [FlareStake command-line interface](./staking-cli.md) or the [FlareStake, the GUI tool for staking](./staking-flarestake.md) to stake.\n\nStaking works by locking funds for a period of time to support a specific [network validator](../../tech/validators.md).\nWhen validator owners stake to their own nodes they _self-bond_, whereas all other participants are said to _delegate_ their stake to that validator.\nNote that delegating your stake to a validator is different from [FTSO delegation](../../tech/ftso/index.md/#delegation).\n\n!!! note\n\n    Proof of stake is being implemented on Flare in phases.\n    Ensure that you have read the [Validators page](../../tech/validators.md#deployment-phases) to learn about them.\n\nParticipants choose how much to stake and for how long their stake will be locked.\nThe minimum values are:\n{ #minimum-values }\n\n|                  | Self-bond | Delegation |\n| ---------------- | --------: | ---------: |\n| Minimum amount   | 1M `$FLR` | 50K `$FLR` |\n| Minimum duration |   60 days |    14 days |\n\nAt the end of every [reward epoch](../../tech/ftso/index.md#reward-epoch), participants are rewarded according to how well their chosen validator performed in that period.\n\n!!! info \"Staking limits\"\n\n    When you choose your validator and amount to stake, consider the [delegation factor and the staking cap](./index.md#limits).\n\n    You can stake to any number of validators, but [rewards](./staking-flarestake.md#reward-claiming-guide), [FlareDrops](../../tech/the-flaredrop.md), and [governance vote power](../../tech/governance.md#the-vote-count-block) only apply for up to 3 different validators.\n\nThe [deployment phases summary](../../tech/validators.md#summary) shows other rewards that staked funds can still earn while they are locked.\n\nGiven that the Flare network uses two [independent underlying chains](../../tech/flare.md#flare-chains), there is one extra step that must be considered.\nFunds must be transferred from the C-chain, where smart contracts run, to the P-chain, where staking happens.\nAfter the staking period expires and funds are unlocked, they can be transferred back to the C-chain.\n\nThe [Flare Portal](https://portal.flare.network/) is a dapp developed by Flare Network that enables you to earn rewards by staking your `$FLR` in your MetaMask wallet to validators on the Flare network.\n\nAlternatively, you can use the [FlareStake command-line interface](./staking-cli.md) or the [FlareStake, the GUI tool for staking](./staking-flarestake.md) to stake.\n\nStaking works by locking funds for a period of time to support a specific [network validator](../../tech/validators.md).\nWhen validator owners stake to their own nodes they _self-bond_, whereas all other participants are said to _delegate_ their stake to that validator.\nNote that delegating your stake to a validator is different from [FTSO delegation](../../tech/ftso/index.md/#delegation).\n\n!!! note\n\n    Proof of stake is being implemented on Flare in phases.\n    Ensure that you have read the [Validators page](../../tech/validators.md#deployment-phases) to learn about them.\n\nParticipants choose how much to stake and for how long their stake will be locked.\nThe minimum values are:\n{ #minimum-values }\n\n|                  | Self-bond | Delegation |\n| ---------------- | --------: | ---------: |\n| Minimum amount   | 1M `$FLR` | 50K `$FLR` |\n| Minimum duration |   60 days |    14 days |\n\nAt the end of every [reward epoch](../../tech/ftso/index.md#reward-epoch), participants are rewarded according to how well their chosen validator performed in that period.\n\n!!! info \"Staking limits\"\n\n    When you choose your validator and amount to stake, consider the [delegation factor and the staking cap](./index.md#limits).\n\n    You can stake to any number of validators, but [rewards](./staking-flarestake.md#reward-claiming-guide), [FlareDrops](../../tech/the-flaredrop.md), and [governance vote power](../../tech/governance.md#the-vote-count-block) only apply for up to 3 different validators.\n\nThe [deployment phases summary](../../tech/validators.md#summary) shows other rewards that staked funds can still earn while they are locked.\n\nGiven that the Flare network uses two [independent underlying chains](../../tech/flare.md#flare-chains), there is one extra step that must be considered.\nFunds must be transferred from the C-chain, where smart contracts run, to the P-chain, where staking happens.\nAfter the staking period expires and funds are unlocked, they can be transferred back to the C-chain.",
    "file_name": "files/flare-docs/user/staking/staking-portal.md",
    "meta_data": {
      "title": "Using the Flare Portal to Stake"
    },
    "type": "answer"
  },
  {
    "content": "The [Flare Portal](https://portal.flare.network/) is a dapp developed by Flare Network that enables you to earn rewards by staking your `$FLR` in your MetaMask wallet to validators on the Flare network.\n\nAlternatively, you can use the [FlareStake command-line interface](./staking-cli.md) or the [FlareStake, the GUI tool for staking](./staking-flarestake.md) to stake.\n\nStaking works by locking funds for a period of time to support a specific [network validator](../../tech/validators.md).\nWhen validator owners stake to their own nodes they _self-bond_, whereas all other participants are said to _delegate_ their stake to that validator.\nNote that delegating your stake to a validator is different from [FTSO delegation](../../tech/ftso/index.md/#delegation).\n\n!!! note\n\n    Proof of stake is being implemented on Flare in phases.\n    Ensure that you have read the [Validators page](../../tech/validators.md#deployment-phases) to learn about them.\n\nParticipants choose how much to stake and for how long their stake will be locked.\nThe minimum values are:\n{ #minimum-values }\n\n|                  | Self-bond | Delegation |\n| ---------------- | --------: | ---------: |\n| Minimum amount   | 1M `$FLR` | 50K `$FLR` |\n| Minimum duration |   60 days |    14 days |\n\nAt the end of every [reward epoch](../../tech/ftso/index.md#reward-epoch), participants are rewarded according to how well their chosen validator performed in that period.\n\n!!! info \"Staking limits\"\n\n    When you choose your validator and amount to stake, consider the [delegation factor and the staking cap](./index.md#limits).\n\n    You can stake to any number of validators, but [rewards](./staking-flarestake.md#reward-claiming-guide), [FlareDrops](../../tech/the-flaredrop.md), and [governance vote power](../../tech/governance.md#the-vote-count-block) only apply for up to 3 different validators.\n\nThe [deployment phases summary](../../tech/validators.md#summary) shows other rewards that staked funds can still earn while they are locked.\n\nGiven that the Flare network uses two [independent underlying chains](../../tech/flare.md#flare-chains), there is one extra step that must be considered.\nFunds must be transferred from the C-chain, where smart contracts run, to the P-chain, where staking happens.\nAfter the staking period expires and funds are unlocked, they can be transferred back to the C-chain.",
    "file_name": "files/flare-docs/user/staking/staking-portal.md",
    "meta_data": {
      "title": "Using the Flare Portal to Stake"
    },
    "type": "answer"
  },
  {
    "content": "Flare has a command-line interface (CLI) tool called FlareStake CLI, which allows performing stake operations on validator nodes from a terminal.\n\nA staking app with a graphical user interface (GUI) is also available to simplify the staking process.\nSee the [Using FlareStake to Stake](./staking-flarestake.md) guide to learn about it.\nStill, a CLI tool has other advantages, like allowing it to be part of automated processes.\n\n!!! question \"Table of Contents\"\n\n    * [Staking Overview](#staking-overview): What you need to know about staking.\n    * [Installing the Flare Stake CLI](#installing-the-flare-stake-cli): Install required tools.\n    * [Staking Guide](#staking-guide): How to perform staking.\n    * [Claiming Guide](#reward-claiming-guide): How to claim staking rewards.\n    * [Troubleshooting](#troubleshooting): Addressing common issues.\n\nFlare has a command-line interface (CLI) tool called FlareStake CLI, which allows performing stake operations on validator nodes from a terminal.\n\nA staking app with a graphical user interface (GUI) is also available to simplify the staking process.\nSee the [Using FlareStake to Stake](./staking-flarestake.md) guide to learn about it.\nStill, a CLI tool has other advantages, like allowing it to be part of automated processes.\n\n!!! question \"Table of Contents\"\n\n    * [Staking Overview](#staking-overview): What you need to know about staking.\n    * [Installing the Flare Stake CLI](#installing-the-flare-stake-cli): Install required tools.\n    * [Staking Guide](#staking-guide): How to perform staking.\n    * [Claiming Guide](#reward-claiming-guide): How to claim staking rewards.\n    * [Troubleshooting](#troubleshooting): Addressing common issues.\n\nFlare has a command-line interface (CLI) tool called FlareStake CLI, which allows performing stake operations on validator nodes from a terminal.\n\nA staking app with a graphical user interface (GUI) is also available to simplify the staking process.\nSee the [Using FlareStake to Stake](./staking-flarestake.md) guide to learn about it.\nStill, a CLI tool has other advantages, like allowing it to be part of automated processes.\n\n!!! question \"Table of Contents\"\n\n    * [Staking Overview](#staking-overview): What you need to know about staking.\n    * [Installing the Flare Stake CLI](#installing-the-flare-stake-cli): Install required tools.\n    * [Staking Guide](#staking-guide): How to perform staking.\n    * [Claiming Guide](#reward-claiming-guide): How to claim staking rewards.\n    * [Troubleshooting](#troubleshooting): Addressing common issues.\n\nFlare has a command-line interface (CLI) tool called FlareStake CLI, which allows performing stake operations on validator nodes from a terminal.\n\nA staking app with a graphical user interface (GUI) is also available to simplify the staking process.\nSee the [Using FlareStake to Stake](./staking-flarestake.md) guide to learn about it.\nStill, a CLI tool has other advantages, like allowing it to be part of automated processes.\n\n!!! question \"Table of Contents\"\n\n    * [Staking Overview](#staking-overview): What you need to know about staking.\n    * [Installing the Flare Stake CLI](#installing-the-flare-stake-cli): Install required tools.\n    * [Staking Guide](#staking-guide): How to perform staking.\n    * [Claiming Guide](#reward-claiming-guide): How to claim staking rewards.\n    * [Troubleshooting](#troubleshooting): Addressing common issues.\n\nFlare has a command-line interface (CLI) tool called FlareStake CLI, which allows performing stake operations on validator nodes from a terminal.\n\nA staking app with a graphical user interface (GUI) is also available to simplify the staking process.\nSee the [Using FlareStake to Stake](./staking-flarestake.md) guide to learn about it.\nStill, a CLI tool has other advantages, like allowing it to be part of automated processes.\n\n!!! question \"Table of Contents\"\n\n    * [Staking Overview](#staking-overview): What you need to know about staking.\n    * [Installing the Flare Stake CLI](#installing-the-flare-stake-cli): Install required tools.\n    * [Staking Guide](#staking-guide): How to perform staking.\n    * [Claiming Guide](#reward-claiming-guide): How to claim staking rewards.\n    * [Troubleshooting](#troubleshooting): Addressing common issues.",
    "file_name": "files/flare-docs/user/staking/staking-cli.md",
    "meta_data": {
      "title": "Using the Command Line to Stake"
    },
    "type": "answer"
  },
  {
    "content": "Flare has a command-line interface (CLI) tool called FlareStake CLI, which allows performing stake operations on validator nodes from a terminal.\n\nA staking app with a graphical user interface (GUI) is also available to simplify the staking process.\nSee the [Using FlareStake to Stake](./staking-flarestake.md) guide to learn about it.\nStill, a CLI tool has other advantages, like allowing it to be part of automated processes.\n\n!!! question \"Table of Contents\"\n\n    * [Staking Overview](#staking-overview): What you need to know about staking.\n    * [Installing the Flare Stake CLI](#installing-the-flare-stake-cli): Install required tools.\n    * [Staking Guide](#staking-guide): How to perform staking.\n    * [Claiming Guide](#reward-claiming-guide): How to claim staking rewards.\n    * [Troubleshooting](#troubleshooting): Addressing common issues.",
    "file_name": "files/flare-docs/user/staking/staking-cli.md",
    "meta_data": {
      "title": "Using the Command Line to Stake"
    },
    "type": "answer"
  },
  {
    "content": "This section contains information about staking Flare assets on [validators](../../tech/validators.md) and receiving rewards earned from your stake.\n\n* [Using FlareStake to Stake](./staking-flarestake.md)\n* [Using the Flare Portal to Stake](./staking-portal.md)\n* [Using the Command Line to Stake](./staking-cli.md)\n\nThis section contains information about staking Flare assets on [validators](../../tech/validators.md) and receiving rewards earned from your stake.\n\n* [Using FlareStake to Stake](./staking-flarestake.md)\n* [Using the Flare Portal to Stake](./staking-portal.md)\n* [Using the Command Line to Stake](./staking-cli.md)\n\nThis section contains information about staking Flare assets on [validators](../../tech/validators.md) and receiving rewards earned from your stake.\n\n* [Using FlareStake to Stake](./staking-flarestake.md)\n* [Using the Flare Portal to Stake](./staking-portal.md)\n* [Using the Command Line to Stake](./staking-cli.md)",
    "file_name": "files/flare-docs/user/staking/index.md",
    "meta_data": {
      "title": "Staking on Validators"
    },
    "type": "answer"
  },
  {
    "content": "D'CENT Biometric Wallet is a **noncustodial hardware wallet** and is considered one of the most secure ways to manage your crypto assets.\n\nD'CENT Biometric Wallet is a **noncustodial hardware wallet** and is considered one of the most secure ways to manage your crypto assets.\n\nD'CENT Biometric Wallet is a **noncustodial hardware wallet** and is considered one of the most secure ways to manage your crypto assets.\n\nD'CENT Biometric Wallet is a **noncustodial hardware wallet** and is considered one of the most secure ways to manage your crypto assets.",
    "file_name": "files/flare-docs/user/wallets/dcent-wallet.md",
    "meta_data": {
      "title": "D'CENT Wallet"
    },
    "type": "answer"
  },
  {
    "content": "Hardware wallets are considered among the more secure options to manage crypto assets and store private keys.\nYour crypto assets can remain safe, even if your computer or phone is compromised, as long as you keep your recovery phrase safe and review all transaction details before confirming transactions.\n\nThis guide explains how to configure your Ledger device to use it through the MetaMask wallet.\n\nHardware wallets are considered among the more secure options to manage crypto assets and store private keys.\nYour crypto assets can remain safe, even if your computer or phone is compromised, as long as you keep your recovery phrase safe and review all transaction details before confirming transactions.\n\nThis guide explains how to configure your Ledger device to use it through the MetaMask wallet.\n\nHardware wallets are considered among the more secure options to manage crypto assets and store private keys.\nYour crypto assets can remain safe, even if your computer or phone is compromised, as long as you keep your recovery phrase safe and review all transaction details before confirming transactions.\n\nThis guide explains how to configure your Ledger device to use it through the MetaMask wallet.",
    "file_name": "files/flare-docs/user/wallets/how-to-access-flare-network-with-a-ledger-device.md",
    "meta_data": {
      "title": "Ledger Nano X and Nano S"
    },
    "type": "answer"
  },
  {
    "content": "Brave Browser now offers a noncustodial software wallet on both Windows and macOS for Ethereum Virtual Machine (EVM) integrated chains such as Flare and Songbird.\n\nBrave Browser now offers a noncustodial software wallet on both Windows and macOS for Ethereum Virtual Machine (EVM) integrated chains such as Flare and Songbird.\n\nBrave Browser now offers a noncustodial software wallet on both Windows and macOS for Ethereum Virtual Machine (EVM) integrated chains such as Flare and Songbird.\n\nBrave Browser now offers a noncustodial software wallet on both Windows and macOS for Ethereum Virtual Machine (EVM) integrated chains such as Flare and Songbird.",
    "file_name": "files/flare-docs/user/wallets/brave-wallet.md",
    "meta_data": {
      "description": "How to use your Brave wallet to access the Songbird and Flare networks",
      "title": "Brave Wallet"
    },
    "type": "answer"
  },
  {
    "content": "The MetaMask browser extension is a convenient way to access and interact with blockchains like Songbird or Flare.\nTo do so, you need to first add a custom network to MetaMask, as explained in this guide.\nMake sure that you have securely backed up your recovery phrase before proceeding.\n\nThe MetaMask browser extension is a convenient way to access and interact with blockchains like Songbird or Flare.\nTo do so, you need to first add a custom network to MetaMask, as explained in this guide.\nMake sure that you have securely backed up your recovery phrase before proceeding.\n\nThe MetaMask browser extension is a convenient way to access and interact with blockchains like Songbird or Flare.\nTo do so, you need to first add a custom network to MetaMask, as explained in this guide.\nMake sure that you have securely backed up your recovery phrase before proceeding.\n\nThe MetaMask browser extension is a convenient way to access and interact with blockchains like Songbird or Flare.\nTo do so, you need to first add a custom network to MetaMask, as explained in this guide.\nMake sure that you have securely backed up your recovery phrase before proceeding.",
    "file_name": "files/flare-docs/user/wallets/how-to-access-flare-network-with-metamask.md",
    "meta_data": {
      "description": "How to connect the MetaMask browser extension to the Songbird or Flare networks",
      "title": "MetaMask"
    },
    "type": "answer"
  },
  {
    "content": "SafePal S1 is a **noncustodial hardware wallet** that is considered one of the most secure ways to manage your crypto assets.\n\nSafePal S1 is a **noncustodial hardware wallet** that is considered one of the most secure ways to manage your crypto assets.\n\nSafePal S1 is a **noncustodial hardware wallet** that is considered one of the most secure ways to manage your crypto assets.\n\nSafePal S1 is a **noncustodial hardware wallet** that is considered one of the most secure ways to manage your crypto assets.",
    "file_name": "files/flare-docs/user/wallets/safepal-s1-wallet.md",
    "meta_data": {
      "title": "SafePal S1 Wallet"
    },
    "type": "answer"
  },
  {
    "content": "Bifrost Wallet is a **noncustodial mobile wallet** available for both Android and iOS.\nYou can view your portfolio of crypto assets, access decentralized applications through the in-app browser and perform operations on various blockchain networks, including sending, receiving, wrapping and delegating Flare (`$FLR`) and Songbird (`$SGB`).\n\nBifrost Wallet is a **noncustodial mobile wallet** available for both Android and iOS.\nYou can view your portfolio of crypto assets, access decentralized applications through the in-app browser and perform operations on various blockchain networks, including sending, receiving, wrapping and delegating Flare (`$FLR`) and Songbird (`$SGB`).\n\nBifrost Wallet is a **noncustodial mobile wallet** available for both Android and iOS.\nYou can view your portfolio of crypto assets, access decentralized applications through the in-app browser and perform operations on various blockchain networks, including sending, receiving, wrapping and delegating Flare (`$FLR`) and Songbird (`$SGB`).\n\nBifrost Wallet is a **noncustodial mobile wallet** available for both Android and iOS.\nYou can view your portfolio of crypto assets, access decentralized applications through the in-app browser and perform operations on various blockchain networks, including sending, receiving, wrapping and delegating Flare (`$FLR`) and Songbird (`$SGB`).",
    "file_name": "files/flare-docs/user/wallets/bifrost-wallet.md",
    "meta_data": {
      "title": "Bifrost Wallet"
    },
    "type": "answer"
  },
  {
    "content": "Choose your wallet:\n\n* [Bifrost Wallet](./bifrost-wallet.md)\n* [Brave Wallet](./brave-wallet.md)\n* [D'CENT Wallet](./dcent-wallet.md)\n* [Enkrypt Wallet](./enkrypt-wallet.md)\n* [Ledger Nano X and Nano S](./how-to-access-flare-network-with-a-ledger-device.md)\n* [MetaMask](./how-to-access-flare-network-with-metamask.md)\n* [SafePal S1 Wallet](./safepal-s1-wallet.md)\n* [Trezor T](./how-to-access-flare-network-with-a-trezor-device.md)\n\nIf your wallet is not in the list, you might be able to configure it to connect to the Flare and Songbird networks by specifying the following configuration parameters in your wallet's settings:\n\n=== \"Flare\"\n\n    | Configuration Parameter | Value                                          |\n    | ----------------------- | ---------------------------------------------- |\n    | **Chain ID**            | 14                                             |\n    | **Asset Ticker**        | `FLR`                                          |\n    | **RPC endpoint**        | `https://flare-api.flare.network/ext/bc/C/rpc` |\n    | **Block Explorer**      | <https://flare-explorer.flare.network>         |\n\n=== \"Songbird\"\n\n    | Configuration Parameter | Value                                             |\n    | ----------------------- | ------------------------------------------------- |\n    | **Chain ID**            | 19                                                |\n    | **Asset Ticker**        | `SGB`                                             |\n    | **RPC endpoint**        | `https://songbird-api.flare.network/ext/bc/C/rpc` |\n    | **Block Explorer**      | <https://songbird-explorer.flare.network>         |\n\n!!! warning \"Caution\"\n    When you connect your wallet to a dapp such as the [Flare Portal](https://portal.flare.network/), always double-check that the address shown in the dapp is the one you intend.\n\n    For some wallets, you must explicitly grant dapps access to each account on your wallet.\n    This is typically done through a \"Connect to Wallet\" button.\n\n    If you did not grant this access, the account you select on your wallet might not even be visible to the dapp.\n    Therefore, always double-check that the address shown in the dapp is the one you intend to use.\n    { #unconnected_account }",
    "meta_data": {
      "title": "Wallets"
    },
    "file_name": "files/flare-docs/user/wallets/index.md",
    "type": "answer"
  },
  {
    "content": "[Enkrypt](https://www.enkrypt.com/?mtm_campaign=Flare%20Wiki%20-%20Getting%20started%20with%20Enkrypt) is a **multichain**, **open-source** and **noncustodial** wallet that tracks no data.\nIt interacts with Polkadot, Ethereum, Bitcoin and more, all directly in the browser.\n\n[Enkrypt](https://www.enkrypt.com/?mtm_campaign=Flare%20Wiki%20-%20Getting%20started%20with%20Enkrypt) is a **multichain**, **open-source** and **noncustodial** wallet that tracks no data.\nIt interacts with Polkadot, Ethereum, Bitcoin and more, all directly in the browser.\n\n[Enkrypt](https://www.enkrypt.com/?mtm_campaign=Flare%20Wiki%20-%20Getting%20started%20with%20Enkrypt) is a **multichain**, **open-source** and **noncustodial** wallet that tracks no data.\nIt interacts with Polkadot, Ethereum, Bitcoin and more, all directly in the browser.\n\n[Enkrypt](https://www.enkrypt.com/?mtm_campaign=Flare%20Wiki%20-%20Getting%20started%20with%20Enkrypt) is a **multichain**, **open-source** and **noncustodial** wallet that tracks no data.\nIt interacts with Polkadot, Ethereum, Bitcoin and more, all directly in the browser.",
    "file_name": "files/flare-docs/user/wallets/enkrypt-wallet.md",
    "meta_data": {
      "title": "Enkrypt Wallet"
    },
    "type": "answer"
  },
  {
    "content": "Hardware wallets are considered among the more secure options to manage crypto assets and store private keys.\nYour crypto assets can remain safe, even if your computer or phone is compromised, as long as you keep your recovery phrase safe and review all transaction details before confirming transactions.\n\nHardware wallets are considered among the more secure options to manage crypto assets and store private keys.\nYour crypto assets can remain safe, even if your computer or phone is compromised, as long as you keep your recovery phrase safe and review all transaction details before confirming transactions.\n\nHardware wallets are considered among the more secure options to manage crypto assets and store private keys.\nYour crypto assets can remain safe, even if your computer or phone is compromised, as long as you keep your recovery phrase safe and review all transaction details before confirming transactions.\n\nHardware wallets are considered among the more secure options to manage crypto assets and store private keys.\nYour crypto assets can remain safe, even if your computer or phone is compromised, as long as you keep your recovery phrase safe and review all transaction details before confirming transactions.",
    "file_name": "files/flare-docs/user/wallets/how-to-access-flare-network-with-a-trezor-device.md",
    "meta_data": {
      "title": "Trezor T"
    },
    "type": "answer"
  },
  {
    "content": "The Flare launch included a rather **large airdrop**, a **community vote**, and the deployment of a **novel meritocratic consensus** system.\nBecause of its complexity, it was divided into a series of **sequential phases** with **clearly-defined triggers** that signaled each transition.\n\nThe following information was intended to **remove any confusion around the launch process** by clearly describing the purpose of each phase and what happened in them.\n\n<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"\nviewBox=\"0 0 895 1844\" style=\"background: white; padding: 8px;\">\n  <image width=\"895\" height=\"1844\" xlink:href=\"../../../assets/images/tech/archive/launch-process.png\"></image>\n  <title>Click on a phase to navigate to its description.</title>\n  <a href=\"#private-observation-mode\">\n    <rect x=\"262\" y=\"111\" fill=\"#fff\" opacity=\"0\" width=\"189\" height=\"87\"></rect>\n  </a>\n  <a href=\"#public-observation-mode\">\n    <rect x=\"262\" y=\"297\" fill=\"#fff\" opacity=\"0\" width=\"189\" height=\"87\"></rect>\n  </a>\n  <a href=\"#initial-distribution-period\">\n    <rect x=\"262\" y=\"664\" fill=\"#fff\" opacity=\"0\" width=\"189\" height=\"87\"></rect>\n  </a>\n  <a href=\"#fip01-notice-period\">\n    <rect x=\"262\" y=\"847\" fill=\"#fff\" opacity=\"0\" width=\"189\" height=\"87\"></rect>\n  </a>\n  <a href=\"#fip01-voting-period\">\n    <rect x=\"262\" y=\"1032\" fill=\"#fff\" opacity=\"0\" width=\"189\" height=\"87\"></rect>\n  </a>\n  <a href=\"#regular-operation-beta\">\n    <rect x=\"262\" y=\"1217\" fill=\"#fff\" opacity=\"0\" width=\"189\" height=\"185\"></rect>\n  </a>\n  <a href=\"#regular-operation\">\n    <rect x=\"262\" y=\"1502\" fill=\"#fff\" opacity=\"0\" width=\"189\" height=\"185\"></rect>\n  </a>\n  <a href=\"#regular-non-fip01-operation\">\n    <rect x=\"502\" y=\"1502\" fill=\"#fff\" opacity=\"0\" width=\"189\" height=\"185\"></rect>\n  </a>\n</svg>\n\nThe Flare launch included a rather **large airdrop**, a **community vote**, and the deployment of a **novel meritocratic consensus** system.\nBecause of its complexity, it was divided into a series of **sequential phases** with **clearly-defined triggers** that signaled each transition.\n\nThe following information was intended to **remove any confusion around the launch process** by clearly describing the purpose of each phase and what happened in them.\n\n<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"\nviewBox=\"0 0 895 1844\" style=\"background: white; padding: 8px;\">\n  <image width=\"895\" height=\"1844\" xlink:href=\"../../../assets/images/tech/archive/launch-process.png\"></image>\n  <title>Click on a phase to navigate to its description.</title>\n  <a href=\"#private-observation-mode\">\n    <rect x=\"262\" y=\"111\" fill=\"#fff\" opacity=\"0\" width=\"189\" height=\"87\"></rect>\n  </a>\n  <a href=\"#public-observation-mode\">\n    <rect x=\"262\" y=\"297\" fill=\"#fff\" opacity=\"0\" width=\"189\" height=\"87\"></rect>\n  </a>\n  <a href=\"#initial-distribution-period\">\n    <rect x=\"262\" y=\"664\" fill=\"#fff\" opacity=\"0\" width=\"189\" height=\"87\"></rect>\n  </a>\n  <a href=\"#fip01-notice-period\">\n    <rect x=\"262\" y=\"847\" fill=\"#fff\" opacity=\"0\" width=\"189\" height=\"87\"></rect>\n  </a>\n  <a href=\"#fip01-voting-period\">\n    <rect x=\"262\" y=\"1032\" fill=\"#fff\" opacity=\"0\" width=\"189\" height=\"87\"></rect>\n  </a>\n  <a href=\"#regular-operation-beta\">\n    <rect x=\"262\" y=\"1217\" fill=\"#fff\" opacity=\"0\" width=\"189\" height=\"185\"></rect>\n  </a>\n  <a href=\"#regular-operation\">\n    <rect x=\"262\" y=\"1502\" fill=\"#fff\" opacity=\"0\" width=\"189\" height=\"185\"></rect>\n  </a>\n  <a href=\"#regular-non-fip01-operation\">\n    <rect x=\"502\" y=\"1502\" fill=\"#fff\" opacity=\"0\" width=\"189\" height=\"185\"></rect>\n  </a>\n</svg>",
    "file_name": "files/flare-docs/tech/archive/flare-launch-process.md",
    "meta_data": {
      "og_image": "assets/thumbnails/launch-process-thumb.png",
      "og_description": "The goal of this page is to remove any confusion around Flare's launch process.",
      "search": {
        "boost": 0.5
      },
      "title": "Flare Launch Process"
    },
    "type": "answer"
  },
  {
    "content": "The Flare launch included a rather **large airdrop**, a **community vote**, and the deployment of a **novel meritocratic consensus** system.\nBecause of its complexity, it was divided into a series of **sequential phases** with **clearly-defined triggers** that signaled each transition.\n\nThe following information was intended to **remove any confusion around the launch process** by clearly describing the purpose of each phase and what happened in them.\n\n<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"\nviewBox=\"0 0 895 1844\" style=\"background: white; padding: 8px;\">\n  <image width=\"895\" height=\"1844\" xlink:href=\"../../../assets/images/tech/archive/launch-process.png\"></image>\n  <title>Click on a phase to navigate to its description.</title>\n  <a href=\"#private-observation-mode\">\n    <rect x=\"262\" y=\"111\" fill=\"#fff\" opacity=\"0\" width=\"189\" height=\"87\"></rect>\n  </a>\n  <a href=\"#public-observation-mode\">\n    <rect x=\"262\" y=\"297\" fill=\"#fff\" opacity=\"0\" width=\"189\" height=\"87\"></rect>\n  </a>\n  <a href=\"#initial-distribution-period\">\n    <rect x=\"262\" y=\"664\" fill=\"#fff\" opacity=\"0\" width=\"189\" height=\"87\"></rect>\n  </a>\n  <a href=\"#fip01-notice-period\">\n    <rect x=\"262\" y=\"847\" fill=\"#fff\" opacity=\"0\" width=\"189\" height=\"87\"></rect>\n  </a>\n  <a href=\"#fip01-voting-period\">\n    <rect x=\"262\" y=\"1032\" fill=\"#fff\" opacity=\"0\" width=\"189\" height=\"87\"></rect>\n  </a>\n  <a href=\"#regular-operation-beta\">\n    <rect x=\"262\" y=\"1217\" fill=\"#fff\" opacity=\"0\" width=\"189\" height=\"185\"></rect>\n  </a>\n  <a href=\"#regular-operation\">\n    <rect x=\"262\" y=\"1502\" fill=\"#fff\" opacity=\"0\" width=\"189\" height=\"185\"></rect>\n  </a>\n  <a href=\"#regular-non-fip01-operation\">\n    <rect x=\"502\" y=\"1502\" fill=\"#fff\" opacity=\"0\" width=\"189\" height=\"185\"></rect>\n  </a>\n</svg>\n\nThe Flare launch included a rather **large airdrop**, a **community vote**, and the deployment of a **novel meritocratic consensus** system.\nBecause of its complexity, it was divided into a series of **sequential phases** with **clearly-defined triggers** that signaled each transition.\n\nThe following information was intended to **remove any confusion around the launch process** by clearly describing the purpose of each phase and what happened in them.\n\n<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"\nviewBox=\"0 0 895 1844\" style=\"background: white; padding: 8px;\">\n  <image width=\"895\" height=\"1844\" xlink:href=\"../../../assets/images/tech/archive/launch-process.png\"></image>\n  <title>Click on a phase to navigate to its description.</title>\n  <a href=\"#private-observation-mode\">\n    <rect x=\"262\" y=\"111\" fill=\"#fff\" opacity=\"0\" width=\"189\" height=\"87\"></rect>\n  </a>\n  <a href=\"#public-observation-mode\">\n    <rect x=\"262\" y=\"297\" fill=\"#fff\" opacity=\"0\" width=\"189\" height=\"87\"></rect>\n  </a>\n  <a href=\"#initial-distribution-period\">\n    <rect x=\"262\" y=\"664\" fill=\"#fff\" opacity=\"0\" width=\"189\" height=\"87\"></rect>\n  </a>\n  <a href=\"#fip01-notice-period\">\n    <rect x=\"262\" y=\"847\" fill=\"#fff\" opacity=\"0\" width=\"189\" height=\"87\"></rect>\n  </a>\n  <a href=\"#fip01-voting-period\">\n    <rect x=\"262\" y=\"1032\" fill=\"#fff\" opacity=\"0\" width=\"189\" height=\"87\"></rect>\n  </a>\n  <a href=\"#regular-operation-beta\">\n    <rect x=\"262\" y=\"1217\" fill=\"#fff\" opacity=\"0\" width=\"189\" height=\"185\"></rect>\n  </a>\n  <a href=\"#regular-operation\">\n    <rect x=\"262\" y=\"1502\" fill=\"#fff\" opacity=\"0\" width=\"189\" height=\"185\"></rect>\n  </a>\n  <a href=\"#regular-non-fip01-operation\">\n    <rect x=\"502\" y=\"1502\" fill=\"#fff\" opacity=\"0\" width=\"189\" height=\"185\"></rect>\n  </a>\n</svg>",
    "file_name": "files/flare-docs/tech/archive/flare-launch-process.md",
    "meta_data": {
      "og_image": "assets/thumbnails/launch-process-thumb.png",
      "og_description": "The goal of this page is to remove any confusion around Flare's launch process.",
      "search": {
        "boost": 0.5
      },
      "title": "Flare Launch Process"
    },
    "type": "answer"
  },
  {
    "content": "!!! warning \"Archived content\"\n\n    This is an archived page corresponding to a phased-out version of the FTSO.\n\n    This page is only maintained for historical reasons.\n    You can find the latest version in the [FTSO concept page](../ftso/index.md).\n\nThe **Flare Time Series Oracle** (FTSO) is a smart contract running on the Flare network that **provides continuous estimations for different types of data**. It does so in a **decentralized manner** (no single party is in control of the process) and **securely** (it takes a lot of effort to disrupt the process).\n\nTo achieve a secure, decentralized system, a set of **independent data providers** retrieves data from external sources, like centralized and decentralized exchanges, and supplies the data to the FTSO system. Then, this information is weighted according to each provider's **vote power**, and a **median** is calculated to produce the final estimate.\n\n!!! note \"Important\"\n\n    When FTSOs were initially designed, they supported only cryptocurrency [price pairs](glossary.md#price_pair). Now, they support all types of data. However, contract names and methods still refer to prices and price epochs, and price pairs are used in the following information to show how FTSOs work.\n\nThe following diagram shows how price pairs are submitted to and filtered by the FTSO system.\n\n<figure markdown>\n  ![FTSO summary](ftso-summary.png){ loading=lazy .allow-zoom }\n  <figcaption>FTSO summary.</figcaption>\n</figure>\n\nData providers that supply **useful information**, such as price pairs that are not removed as outliers because they are too far away from the median value, are **rewarded**, and the resulting data estimates are finally **published on-chain**.\n\nThe following information describes:\n\n* [The FTSO workflow](#procedure-overview)\n* [How results are calculated](#how-results-are-calculated)\n* [Vote power](#vote-power)\n* [Delegation](#delegation)\n\n!!! warning \"Archived content\"\n\n    This is an archived page corresponding to a phased-out version of the FTSO.\n\n    This page is only maintained for historical reasons.\n    You can find the latest version in the [FTSO concept page](../ftso/index.md).\n\nThe **Flare Time Series Oracle** (FTSO) is a smart contract running on the Flare network that **provides continuous estimations for different types of data**. It does so in a **decentralized manner** (no single party is in control of the process) and **securely** (it takes a lot of effort to disrupt the process).\n\nTo achieve a secure, decentralized system, a set of **independent data providers** retrieves data from external sources, like centralized and decentralized exchanges, and supplies the data to the FTSO system. Then, this information is weighted according to each provider's **vote power**, and a **median** is calculated to produce the final estimate.\n\n!!! note \"Important\"\n\n    When FTSOs were initially designed, they supported only cryptocurrency [price pairs](glossary.md#price_pair). Now, they support all types of data. However, contract names and methods still refer to prices and price epochs, and price pairs are used in the following information to show how FTSOs work.\n\nThe following diagram shows how price pairs are submitted to and filtered by the FTSO system.\n\n<figure markdown>\n  ![FTSO summary](ftso-summary.png){ loading=lazy .allow-zoom }\n  <figcaption>FTSO summary.</figcaption>\n</figure>\n\nData providers that supply **useful information**, such as price pairs that are not removed as outliers because they are too far away from the median value, are **rewarded**, and the resulting data estimates are finally **published on-chain**.\n\nThe following information describes:\n\n* [The FTSO workflow](#procedure-overview)\n* [How results are calculated](#how-results-are-calculated)\n* [Vote power](#vote-power)\n* [Delegation](#delegation)",
    "file_name": "files/flare-docs/tech/archive/ftso-v1.md",
    "meta_data": {
      "search": {
        "boost": 0.5
      },
      "title": "FTSO v1"
    },
    "type": "answer"
  },
  {
    "content": "!!! warning \"Archived content\"\n\n    This is an archived page corresponding to a phased-out version of the FTSO.\n\n    This page is only maintained for historical reasons.\n    You can find the latest version in the [FTSO concept page](../ftso/index.md).\n\nThe **Flare Time Series Oracle** (FTSO) is a smart contract running on the Flare network that **provides continuous estimations for different types of data**. It does so in a **decentralized manner** (no single party is in control of the process) and **securely** (it takes a lot of effort to disrupt the process).\n\nTo achieve a secure, decentralized system, a set of **independent data providers** retrieves data from external sources, like centralized and decentralized exchanges, and supplies the data to the FTSO system. Then, this information is weighted according to each provider's **vote power**, and a **median** is calculated to produce the final estimate.\n\n!!! note \"Important\"\n\n    When FTSOs were initially designed, they supported only cryptocurrency [price pairs](glossary.md#price_pair). Now, they support all types of data. However, contract names and methods still refer to prices and price epochs, and price pairs are used in the following information to show how FTSOs work.\n\nThe following diagram shows how price pairs are submitted to and filtered by the FTSO system.\n\n<figure markdown>\n  ![FTSO summary](ftso-summary.png){ loading=lazy .allow-zoom }\n  <figcaption>FTSO summary.</figcaption>\n</figure>\n\nData providers that supply **useful information**, such as price pairs that are not removed as outliers because they are too far away from the median value, are **rewarded**, and the resulting data estimates are finally **published on-chain**.\n\nThe following information describes:\n\n* [The FTSO workflow](#procedure-overview)\n* [How results are calculated](#how-results-are-calculated)\n* [Vote power](#vote-power)\n* [Delegation](#delegation)\n\n!!! warning \"Archived content\"\n\n    This is an archived page corresponding to a phased-out version of the FTSO.\n\n    This page is only maintained for historical reasons.\n    You can find the latest version in the [FTSO concept page](../ftso/index.md).\n\nThe **Flare Time Series Oracle** (FTSO) is a smart contract running on the Flare network that **provides continuous estimations for different types of data**. It does so in a **decentralized manner** (no single party is in control of the process) and **securely** (it takes a lot of effort to disrupt the process).\n\nTo achieve a secure, decentralized system, a set of **independent data providers** retrieves data from external sources, like centralized and decentralized exchanges, and supplies the data to the FTSO system. Then, this information is weighted according to each provider's **vote power**, and a **median** is calculated to produce the final estimate.\n\n!!! note \"Important\"\n\n    When FTSOs were initially designed, they supported only cryptocurrency [price pairs](glossary.md#price_pair). Now, they support all types of data. However, contract names and methods still refer to prices and price epochs, and price pairs are used in the following information to show how FTSOs work.\n\nThe following diagram shows how price pairs are submitted to and filtered by the FTSO system.\n\n<figure markdown>\n  ![FTSO summary](ftso-summary.png){ loading=lazy .allow-zoom }\n  <figcaption>FTSO summary.</figcaption>\n</figure>\n\nData providers that supply **useful information**, such as price pairs that are not removed as outliers because they are too far away from the median value, are **rewarded**, and the resulting data estimates are finally **published on-chain**.\n\nThe following information describes:\n\n* [The FTSO workflow](#procedure-overview)\n* [How results are calculated](#how-results-are-calculated)\n* [Vote power](#vote-power)\n* [Delegation](#delegation)",
    "file_name": "files/flare-docs/tech/archive/ftso-v1.md",
    "meta_data": {
      "search": {
        "boost": 0.5
      },
      "title": "FTSO v1"
    },
    "type": "answer"
  },
  {
    "content": "!!! warning \"Archived content\"\n\n    This is an archived page corresponding to a phased-out version of the FTSO.\n\n    This page is only maintained for historical reasons.\n    You can find the latest version in the [FTSO concept page](../ftso/index.md).\n\nThe **Flare Time Series Oracle** (FTSO) is a smart contract running on the Flare network that **provides continuous estimations for different types of data**. It does so in a **decentralized manner** (no single party is in control of the process) and **securely** (it takes a lot of effort to disrupt the process).\n\nTo achieve a secure, decentralized system, a set of **independent data providers** retrieves data from external sources, like centralized and decentralized exchanges, and supplies the data to the FTSO system. Then, this information is weighted according to each provider's **vote power**, and a **median** is calculated to produce the final estimate.\n\n!!! note \"Important\"\n\n    When FTSOs were initially designed, they supported only cryptocurrency [price pairs](glossary.md#price_pair). Now, they support all types of data. However, contract names and methods still refer to prices and price epochs, and price pairs are used in the following information to show how FTSOs work.\n\nThe following diagram shows how price pairs are submitted to and filtered by the FTSO system.\n\n<figure markdown>\n  ![FTSO summary](ftso-summary.png){ loading=lazy .allow-zoom }\n  <figcaption>FTSO summary.</figcaption>\n</figure>\n\nData providers that supply **useful information**, such as price pairs that are not removed as outliers because they are too far away from the median value, are **rewarded**, and the resulting data estimates are finally **published on-chain**.\n\nThe following information describes:\n\n* [The FTSO workflow](#procedure-overview)\n* [How results are calculated](#how-results-are-calculated)\n* [Vote power](#vote-power)\n* [Delegation](#delegation)\n\n!!! warning \"Archived content\"\n\n    This is an archived page corresponding to a phased-out version of the FTSO.\n\n    This page is only maintained for historical reasons.\n    You can find the latest version in the [FTSO concept page](../ftso/index.md).\n\nThe **Flare Time Series Oracle** (FTSO) is a smart contract running on the Flare network that **provides continuous estimations for different types of data**. It does so in a **decentralized manner** (no single party is in control of the process) and **securely** (it takes a lot of effort to disrupt the process).\n\nTo achieve a secure, decentralized system, a set of **independent data providers** retrieves data from external sources, like centralized and decentralized exchanges, and supplies the data to the FTSO system. Then, this information is weighted according to each provider's **vote power**, and a **median** is calculated to produce the final estimate.\n\n!!! note \"Important\"\n\n    When FTSOs were initially designed, they supported only cryptocurrency [price pairs](glossary.md#price_pair). Now, they support all types of data. However, contract names and methods still refer to prices and price epochs, and price pairs are used in the following information to show how FTSOs work.\n\nThe following diagram shows how price pairs are submitted to and filtered by the FTSO system.\n\n<figure markdown>\n  ![FTSO summary](ftso-summary.png){ loading=lazy .allow-zoom }\n  <figcaption>FTSO summary.</figcaption>\n</figure>\n\nData providers that supply **useful information**, such as price pairs that are not removed as outliers because they are too far away from the median value, are **rewarded**, and the resulting data estimates are finally **published on-chain**.\n\nThe following information describes:\n\n* [The FTSO workflow](#procedure-overview)\n* [How results are calculated](#how-results-are-calculated)\n* [Vote power](#vote-power)\n* [Delegation](#delegation)",
    "file_name": "files/flare-docs/tech/archive/ftso-v1.md",
    "meta_data": {
      "search": {
        "boost": 0.5
      },
      "title": "FTSO v1"
    },
    "type": "answer"
  },
  {
    "content": "!!! warning \"Archived content\"\n\n    This is an archived page corresponding to a phased-out version of the FTSO.\n\n    This page is only maintained for historical reasons.\n    You can find the latest version in the [FTSO concept page](../ftso/index.md).\n\nThe **Flare Time Series Oracle** (FTSO) is a smart contract running on the Flare network that **provides continuous estimations for different types of data**. It does so in a **decentralized manner** (no single party is in control of the process) and **securely** (it takes a lot of effort to disrupt the process).\n\nTo achieve a secure, decentralized system, a set of **independent data providers** retrieves data from external sources, like centralized and decentralized exchanges, and supplies the data to the FTSO system. Then, this information is weighted according to each provider's **vote power**, and a **median** is calculated to produce the final estimate.\n\n!!! note \"Important\"\n\n    When FTSOs were initially designed, they supported only cryptocurrency [price pairs](glossary.md#price_pair). Now, they support all types of data. However, contract names and methods still refer to prices and price epochs, and price pairs are used in the following information to show how FTSOs work.\n\nThe following diagram shows how price pairs are submitted to and filtered by the FTSO system.\n\n<figure markdown>\n  ![FTSO summary](ftso-summary.png){ loading=lazy .allow-zoom }\n  <figcaption>FTSO summary.</figcaption>\n</figure>\n\nData providers that supply **useful information**, such as price pairs that are not removed as outliers because they are too far away from the median value, are **rewarded**, and the resulting data estimates are finally **published on-chain**.\n\nThe following information describes:\n\n* [The FTSO workflow](#procedure-overview)\n* [How results are calculated](#how-results-are-calculated)\n* [Vote power](#vote-power)\n* [Delegation](#delegation)",
    "file_name": "files/flare-docs/tech/archive/ftso-v1.md",
    "meta_data": {
      "search": {
        "boost": 0.5
      },
      "title": "FTSO v1"
    },
    "type": "answer"
  },
  {
    "content": "This section archives old information.\n\nSelect one of the topics below:\n\n* [Flare Launch Process](./flare-launch-process.md)\n* [FTSO v1](./ftso-v1.md)",
    "meta_data": {
      "search": {
        "boost": 0.5
      },
      "title": "Archive"
    },
    "file_name": "files/flare-docs/tech/archive/index.md",
    "type": "answer"
  },
  {
    "content": "For details about the Flare Time Series Oracle (FTSO), see [FTSOv2 in the Flare Developer Hub](https://dev.flare.network/ftso/overview).",
    "meta_data": {
      "search": {
        "boost": 2
      },
      "title": "FTSO"
    },
    "file_name": "files/flare-docs/tech/ftso/index.md",
    "type": "answer"
  },
  {
    "content": "const FLARE_CONTRACTS = \"@flarenetwork/flare-periphery-contract-artifacts\";\nconst FLARE_RPC = \"https://coston-api.flare.network/ext/C/rpc\";\nconst ATTESTATION_PROVIDER_URL = \"https://attestation-coston.flare.network\";\nconst VERIFIER_URL = \"https://evm-verifier.flare.network\";\nconst VERIFIER_API_KEY = \"123456\";\nconst FLARE_CONTRACT_REGISTRY_ADDR =\n  \"0xaD67FE66660Fb8dFE9d6b1b4240d8650e30F6019\";\n\n// You should get your private keys from an external source.\n// DO NOT embed them in source code in a production environment!\nconst PRIVATE_KEY =\n  \"0x6607fc65548ffe231ce954018b3ee01fedb242281227e42a30a9bffa759557d7\";\n\nasync function runRetrieveEVMTransaction(network, transactionHashToRetrieve) {\n  const VERIFICATION_ENDPOINT =\n    `${VERIFIER_URL}/verifier/${network.toLowerCase()}` +\n    `/EVMTransaction/prepareRequest`;\n  const ATTESTATION_ENDPOINT =\n    `${ATTESTATION_PROVIDER_URL}/attestation-client/api/proof/` +\n    `get-specific-proof`;\n\n  // 1. Set up\n  const ethers = await import(\"ethers\");\n  const flare = await import(FLARE_CONTRACTS);\n  const utils = await import(\n    `${FLARE_CONTRACTS}/dist/coston/StateConnector/libs/ts/utils.js`\n  );\n  const provider = new ethers.JsonRpcProvider(FLARE_RPC);\n  const signer = new ethers.Wallet(PRIVATE_KEY, provider);\n\n  // 2. Prepare Attestation Request\n  const { encodeAttestationName } = utils;\n  const rawAttestationRequest = {\n    attestationType: encodeAttestationName(\"EVMTransaction\"),\n    sourceId: encodeAttestationName(`test${network.toUpperCase()}`),\n    requestBody: {\n      transactionHash: transactionHashToRetrieve,\n      requiredConfirmations: \"1\", // Must be a string\n      provideInput: true,\n      listEvents: true,\n      logIndices: []\n    },\n  };\n  console.log(\n    \"Preparing attestation request using verifier\",\n    VERIFIER_URL,\n    \"...\"\n  );\n  console.log(\"Request:\", rawAttestationRequest);\n\n  const verifierResponse = await fetch(VERIFICATION_ENDPOINT, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      \"X-API-KEY\": VERIFIER_API_KEY,\n    },\n    body: JSON.stringify(rawAttestationRequest),\n  });\n  const encodedAttestationRequest = await verifierResponse.json();\n  if (encodedAttestationRequest.status !== \"VALID\") {\n    console.log(\"Received error:\", encodedAttestationRequest);\n    return;\n  }\n  console.log(\n    \"  Received encoded attestation request:\",\n    encodedAttestationRequest.abiEncodedRequest\n  );\n\n  // 3. Access Contract Registry\n  const flareContractRegistry = new ethers.Contract(\n    FLARE_CONTRACT_REGISTRY_ADDR,\n    flare.nameToAbi(\"FlareContractRegistry\", \"coston\").data,\n    provider\n  );\n\n  // 4. Retrieve the State Connector Contract Address\n  const stateConnectorAddress =\n    await flareContractRegistry.getContractAddressByName(\"StateConnector\");\n  const stateConnector = new ethers.Contract(\n    stateConnectorAddress,\n    flare.nameToAbi(\"StateConnector\", \"coston\").data,\n    signer\n  );\n\n  // 5. Request Attestation from the State Connector Contract\n  console.log(\"Submitting attestation to State Connector...\");\n  const attestationTx = await stateConnector.requestAttestations(\n    encodedAttestationRequest.abiEncodedRequest\n  );\n  const receipt = await attestationTx.wait();\n  const block = await provider.getBlock(receipt.blockNumber);\n\n  // 6. Calculate Round ID\n  const roundOffset = await stateConnector.BUFFER_TIMESTAMP_OFFSET();\n  const roundDuration = await stateConnector.BUFFER_WINDOW();\n  const submissionRoundID = Number(\n    (BigInt(block.timestamp) - roundOffset) / roundDuration\n  );\n\n  console.log(\"  Attestation submitted in round\", submissionRoundID);\n\n  // 7. Wait for the Attestation Round to Finalize\n  var prevFinalizedRoundID = 0;\n  setTimeout(async function poll() {\n    const lastFinalizedRoundID = Number(\n      await stateConnector.lastFinalizedRoundId()\n    );\n    if (prevFinalizedRoundID != lastFinalizedRoundID) {\n      console.log(\"  Last finalized round is\", lastFinalizedRoundID);\n      prevFinalizedRoundID = lastFinalizedRoundID;\n    }\n    if (lastFinalizedRoundID < submissionRoundID) {\n      setTimeout(poll, 10000);\n      return;\n    }\n\n    // 8. Retrieve Proof\n    const proofRequest = {\n      roundId: submissionRoundID,\n      requestBytes: encodedAttestationRequest.abiEncodedRequest,\n    };\n\n    console.log(\"Retrieving proof from attestation provider...\");\n    const providerResponse = await fetch(ATTESTATION_ENDPOINT, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"X-API-KEY\": VERIFIER_API_KEY,\n      },\n      body: JSON.stringify(proofRequest),\n    });\n    const proof = await providerResponse.json();\n    if (proof.status !== \"OK\") {\n      console.log(\"Received error:\", proof);\n      return;\n    }\n    console.log(\"  Received Merkle proof:\", proof.data.merkleProof);\n\n    // 9. Send Proof to Verifier Contract\n    // Unpacked attestation proof to be used in a Solidity contract.\n    const fullProof = {\n        merkleProof: proof.data.merkleProof,\n        data: {\n            ...proof.data,\n            ...proof.data.request,\n            ...proof.data.response,\n            status: proof.status,\n        }\n    };\n\n    const responseBody = fullProof.data.responseBody;\n\n    console.log(\"Sending the proof for verification...\");\n    const EVMTransactionVerifier = new ethers.Contract(\n      flare.nameToAddress(\"IEVMTransactionVerification\", \"coston\"),\n      flare.nameToAbi(\"IEVMTransactionVerification\", \"coston\").data,\n      signer\n    );\n    const isVerified =\n      await EVMTransactionVerifier.verifyEVMTransaction(fullProof);\n    console.log(\"  Attestation result:\", isVerified);\n\n    // 10. Check response\n    if (isVerified) {\n      console.log(\"Retrieved transaction:\");\n      console.dir(responseBody, { depth: null });\n    } else {\n      console.log(\n        \"Could not retrieve transaction.\"\n      );\n    }\n  }, 10000);\n}\n\nrunRetrieveEVMTransaction(\n  \"eth\",\n  \"0x58d98ffe5f960f63ac55184ef5215f5cf2c1ab1983ac3c11a39e24477299170d\"\n);",
    "meta_data": {},
    "file_name": "files/flare-docs/samples/sc/EVMTransaction.js",
    "type": "code"
  },
  {
    "content": "const FLARE_CONTRACTS = \"@flarenetwork/flare-periphery-contract-artifacts\";\nconst FLARE_RPC = \"https://coston-api.flare.network/ext/C/rpc\";\nconst ATTESTATION_PROVIDER_URL = \"https://attestation-coston.aflabs.net\";\nconst ATTESTATION_PROVIDER_API_KEY = \"123456\";\nconst FLARE_CONTRACT_REGISTRY_ADDR =\n  \"0xaD67FE66660Fb8dFE9d6b1b4240d8650e30F6019\";\n\n// You should get your private keys from an external source.\n// DO NOT embed them in source code in a production environment!\nconst PRIVATE_KEY =\n  \"0x6607fc65548ffe231ce954018b3ee01fedb242281227e42a30a9bffa759557d7\";\n\nasync function runAddressValidity(network, addressToValidate) {\n  const VERIFICATION_ENDPOINT =\n    `${ATTESTATION_PROVIDER_URL}/verifier/${network.toLowerCase()}` +\n    `/AddressValidity/prepareRequest`;\n  const ATTESTATION_ENDPOINT =\n    `${ATTESTATION_PROVIDER_URL}/attestation-client/api/proof/` +\n    `get-specific-proof`;\n\n  // 1. Set up\n  const ethers = await import(\"ethers\");\n  const flare = await import(FLARE_CONTRACTS);\n  const utils = await import(\n    `${FLARE_CONTRACTS}/dist/coston/StateConnector/libs/ts/utils.js`\n  );\n  const provider = new ethers.JsonRpcProvider(FLARE_RPC);\n  const signer = new ethers.Wallet(PRIVATE_KEY, provider);\n\n  // 2. Prepare Attestation Request\n  const { encodeAttestationName } = utils;\n  const rawAttestationRequest = {\n    attestationType: encodeAttestationName(\"AddressValidity\"),\n    sourceId: encodeAttestationName(`test${network.toUpperCase()}`),\n    requestBody: {\n      addressStr: addressToValidate,\n    },\n  };\n  console.log(\n    \"Preparing attestation request using verifier\",\n    ATTESTATION_PROVIDER_URL,\n    \"...\"\n  );\n  console.log(\"Request:\", rawAttestationRequest);\n\n  const verifierResponse = await fetch(VERIFICATION_ENDPOINT, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      \"X-API-KEY\": ATTESTATION_PROVIDER_API_KEY,\n    },\n    body: JSON.stringify(rawAttestationRequest),\n  });\n  const encodedAttestationRequest = await verifierResponse.json();\n  if (encodedAttestationRequest.status !== \"VALID\") {\n    console.log(\"Received error:\", encodedAttestationRequest);\n    return;\n  }\n  console.log(\n    \"  Received encoded attestation request:\",\n    encodedAttestationRequest.abiEncodedRequest\n  );\n\n  // 3. Access Contract Registry\n  const flareContractRegistry = new ethers.Contract(\n    FLARE_CONTRACT_REGISTRY_ADDR,\n    flare.nameToAbi(\"FlareContractRegistry\", \"coston\").data,\n    provider\n  );\n\n  // 4. Retrieve the State Connector Contract Address\n  const stateConnectorAddress =\n    await flareContractRegistry.getContractAddressByName(\"StateConnector\");\n  const stateConnector = new ethers.Contract(\n    stateConnectorAddress,\n    flare.nameToAbi(\"StateConnector\", \"coston\").data,\n    signer\n  );\n\n  // 5. Request Attestation from the State Connector Contract\n  console.log(\"Submitting attestation to State Connector...\");\n  const attestationTx = await stateConnector.requestAttestations(\n    encodedAttestationRequest.abiEncodedRequest\n  );\n  const receipt = await attestationTx.wait();\n  const block = await provider.getBlock(receipt.blockNumber);\n\n  // 6. Calculate Round ID\n  const roundOffset = await stateConnector.BUFFER_TIMESTAMP_OFFSET();\n  const roundDuration = await stateConnector.BUFFER_WINDOW();\n  const submissionRoundID = Number(\n    (BigInt(block.timestamp) - roundOffset) / roundDuration\n  );\n\n  console.log(\"  Attestation submitted in round\", submissionRoundID);\n\n  // 7. Wait for the Attestation Round to Finalize\n  var prevFinalizedRoundID = 0;\n  setTimeout(async function poll() {\n    const lastFinalizedRoundID = Number(\n      await stateConnector.lastFinalizedRoundId()\n    );\n    if (prevFinalizedRoundID != lastFinalizedRoundID) {\n      console.log(\"  Last finalized round is\", lastFinalizedRoundID);\n      prevFinalizedRoundID = lastFinalizedRoundID;\n    }\n    if (lastFinalizedRoundID < submissionRoundID) {\n      setTimeout(poll, 10000);\n      return;\n    }\n\n    // 8. Retrieve Proof\n    const proofRequest = {\n      roundId: submissionRoundID,\n      requestBytes: encodedAttestationRequest.abiEncodedRequest,\n    };\n\n    console.log(\"Retrieving proof from attestation provider...\");\n    const providerResponse = await fetch(ATTESTATION_ENDPOINT, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"X-API-KEY\": ATTESTATION_PROVIDER_API_KEY,\n      },\n      body: JSON.stringify(proofRequest),\n    });\n    const proof = await providerResponse.json();\n    if (proof.status !== \"OK\") {\n      console.log(\"Received error:\", proof);\n      return;\n    }\n    console.log(\"  Received Merkle proof:\", proof.data.merkleProof);\n\n    // 9. Send Proof to Verifier Contract\n    // Unpacked attestation proof to be used in a Solidity contract.\n    const fullProof = {\n        merkleProof: proof.data.merkleProof,\n        data: {\n            ...proof.data,\n            ...proof.data.request,\n            ...proof.data.response,\n            status: proof.status,\n        }\n    };\n\n    const { isValid } = fullProof.data.responseBody;\n\n    console.log(\"Sending the proof for verification...\");\n    const addressVerifier = new ethers.Contract(\n      flare.nameToAddress(\"IAddressValidityVerification\", \"coston\"),\n      flare.nameToAbi(\"IAddressValidityVerification\", \"coston\").data,\n      signer\n    );\n    const isVerified =\n      await addressVerifier.verifyAddressValidity(fullProof);\n    console.log(\"  Attestation result:\", isVerified);\n\n    // 10. Check if Address is Valid\n    if (isVerified) {\n      console.log(\n        isValid\n          ? \"Attestation providers agree that the address is valid.\"\n          : \"Attestation providers agree that the address is invalid.\"\n      );\n    } else {\n      console.log(\n        \"Could not verify attestation. Validity of address is unknown.\"\n      );\n    }\n  }, 10000);\n}\n\nrunAddressValidity(\n  \"btc\",\n  \"tb1p4mdyx3dvgk4dhvv8yv2dtuymf00wxhgkkjheqm7526fu7znnd6msw3qxvj\"\n);",
    "meta_data": {},
    "file_name": "files/flare-docs/samples/sc/AddressValidity.js",
    "type": "code"
  },
  {
    "content": "// This is a snippet useful as reference. It shows:\n// - How to sign transactions both from the browser and Node.js\n// - How to wrap native tokens by sending them to the WNAT contract.\n//\n// Someday this might be turned into a proper tutorial.\n\nconst FLARE_PACKAGE = \"@flarenetwork/flare-periphery-contract-artifacts\";\nconst FLARE_RPC = \"https://coston2-api.flare.network/ext/bc/C/rpc\";\n\n// Get private keys from an external source.\n// DO NOT embed them in source code!\nconst TEST_PRIVATE_KEY = \"\";\n\nasync function Wrap_run(amount) {\n\n    // 1. Setup\n    const ethers = await import(\"ethers\");\n    const flare = await import(FLARE_PACKAGE);\n    var provider, signer;\n    if (typeof window === \"undefined\") {\n        // Node.js\n        provider = new ethers.JsonRpcProvider(FLARE_RPC);\n        signer = new ethers.Wallet(TEST_PRIVATE_KEY, provider);\n    } else {\n        // Browser\n        if (typeof window.tutorialData === \"undefined\") {\n            console.log(\"Wallet is not connected.\");\n            return;\n        }\n        provider = new ethers.BrowserProvider(window.tutorialData.provider);\n        signer = await provider.getSigner();\n    }\n    const account = signer.address;\n\n    // 2. Access the Contract Registry\n    const flareContractRegistry = new ethers.Contract(\n        \"0xaD67FE66660Fb8dFE9d6b1b4240d8650e30F6019\",\n        flare.nameToAbi(\"FlareContractRegistry\", \"coston2\").data,\n        signer);\n\n    // 3. Retrieve the WNat contract\n    const wnatAddr = await\n        flareContractRegistry.getContractAddressByName(\"WNat\");\n    const wnat = new ethers.Contract(\n        wnatAddr,\n        flare.nameToAbi(\"WNat\", \"coston2\").data,\n        signer);\n\n    balance_nat = await provider.getBalance(account)\n    balance_wrapped = await wnat.balanceOf(account);\n    console.log(`Balance of account ${account}:`);\n    console.log(`  ${Number(balance_nat) / 10 ** 18} C2FLR`);\n    console.log(`  ${Number(balance_wrapped) / 10 ** 18} WC2FLR`);\n    console.log(`Wrapping ${amount} C2FLR...`);\n\n    const options = { value: ethers.parseEther(amount) };\n    await wnat.deposit(options);\n    console.log(`Transaction submitted.`);\n}\n\nWrap_run(\"1\");\n",
    "meta_data": {},
    "file_name": "files/flare-docs/samples/tests/wrap.js",
    "type": "code"
  },
  {
    "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\n\nimport {IRelay} from \"@flarenetwork/flare-periphery-contracts/coston/util-contracts/userInterfaces/IRelay.sol\";\nimport {FlareContractsRegistryLibrary} from \"@flarenetwork/flare-periphery-contracts/coston/util-contracts/ContractRegistryLibrary.sol\";\n\ncontract GetRandomNumber {\n    function generateNumber() external view returns (uint256, bool, uint256) {\n        address relayAddress =\n            FlareContractsRegistryLibrary.getContractAddressByName(\"Relay\");\n        IRelay relay = IRelay(relayAddress);\n        (uint256 randomNumber, bool isSecure, uint256 timestamp) =\n            relay.getRandomNumber();\n\n        return (randomNumber, isSecure, timestamp);\n    }\n}",
    "meta_data": {},
    "file_name": "files/flare-docs/samples/ftso/GetRandomNumber.sol",
    "type": "code"
  },
  {
    "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// 1. Import dependencies\nimport \"@flarenetwork/flare-periphery-contracts/flare/util-contracts/userInterfaces/IFlareContractRegistry.sol\";\nimport \"@flarenetwork/flare-periphery-contracts/flare/ftso/userInterfaces/IFtsoRegistry.sol\";\n\ncontract GettingDataFeeds {\n\n    address private constant FLARE_CONTRACT_REGISTRY =\n        0xaD67FE66660Fb8dFE9d6b1b4240d8650e30F6019;\n\n    function getTokenPriceWei(\n        string memory _symbol\n    ) public view returns(\n        uint256 _price, uint256 _timestamp, uint256 _decimals)\n    {\n        // 2. Access the Contract Registry\n        IFlareContractRegistry contractRegistry = IFlareContractRegistry(\n            FLARE_CONTRACT_REGISTRY);\n\n        // 3. Retrieve the FTSO Registry\n        IFtsoRegistry ftsoRegistry = IFtsoRegistry(\n            contractRegistry.getContractAddressByName('FtsoRegistry'));\n\n        // 4. Get latest price\n        (_price, _timestamp, _decimals) =\n            ftsoRegistry.getCurrentPriceWithDecimals(_symbol);\n    }\n\n}",
    "meta_data": {},
    "file_name": "files/flare-docs/samples/ftso/GettingDataFeeds.sol",
    "type": "code"
  },
  {
    "content": "const { expect } = require(\"chai\");\n\ndescribe(\"GettingDataFeeds\", async function () {\n    let contract;\n    beforeEach(async function () {\n        contract = await ethers.deployContract(\"GettingDataFeeds\");\n    });\n    it(\"Should return sensible values\", async function () {\n        const res = await contract.getTokenPriceWei(\"BTC\");\n\n        expect(res._timestamp).to.greaterThan(1695817332);\n        expect(res._decimals).to.within(0, 18);\n        expect(res._price).to.within(0, 1000000 * 10 ** Number(res._decimals));\n    });\n});",
    "meta_data": {},
    "file_name": "files/flare-docs/samples/ftso/TestGettingDataFeeds.js",
    "type": "code"
  },
  {
    "content": "const FLARE_PACKAGE = \"@flarenetwork/flare-periphery-contract-artifacts\";\nconst FLARE_RPC = \"https://flare-api.flare.network/ext/bc/C/rpc\";\n\nasync function runGettingDataFeeds(symbol) {\n    console.log(`Retrieving current price of ${symbol}...`);\n\n    // 1. Import dependencies\n    const ethers = await import(\"ethers\");\n    const flare = await import(FLARE_PACKAGE);\n\n    // Node to submit queries to.\n    const provider = new ethers.JsonRpcProvider(FLARE_RPC);\n\n    // 2. Access the Contract Registry\n    const flareContractRegistry = new ethers.Contract(\n        \"0xaD67FE66660Fb8dFE9d6b1b4240d8650e30F6019\",\n        flare.nameToAbi(\"FlareContractRegistry\", \"flare\").data,\n        provider);\n\n    // 3. Retrieve the FTSO Registry\n    const ftsoRegistryAddr = await\n        flareContractRegistry.getContractAddressByName(\"FtsoRegistry\");\n    const ftsoRegistry = new ethers.Contract(\n        ftsoRegistryAddr,\n        flare.nameToAbi(\"FtsoRegistry\", \"flare\").data,\n        provider);\n\n    // 4. Get latest price\n    const [price, timestamp, decimals] =\n        await ftsoRegistry[\"getCurrentPriceWithDecimals(string)\"](symbol);\n\n    console.log(`${Number(price) / Math.pow(10, Number(decimals))} USD`);\n    console.log(`Calculated at ${new Date(Number(timestamp) * 1000)}`);\n}\n\nrunGettingDataFeeds(\"BTC\");\n",
    "meta_data": {},
    "file_name": "files/flare-docs/samples/ftso/GettingDataFeeds.js",
    "type": "code"
  },
  {
    "content": "const FLARE_CONTRACTS = \"@flarenetwork/flare-periphery-contract-artifacts\";\nconst FLARE_RPC = \"https://coston-api.flare.network/ext/C/rpc\";\nconst FLARE_CONTRACT_REGISTRY_ADDR =\n  \"0xaD67FE66660Fb8dFE9d6b1b4240d8650e30F6019\";\n\nasync function runGetRandomNumber() {\n  // 1. Import Dependencies\n  const ethers = await import(\"ethers\");\n  const flare = await import(FLARE_CONTRACTS);\n  const provider = new ethers.JsonRpcProvider(FLARE_RPC);\n\n  // 2. Access the Contract Registry\n  const flareContractRegistry = new ethers.Contract(\n    FLARE_CONTRACT_REGISTRY_ADDR,\n    flare.nameToAbi(\"FlareContractRegistry\", \"coston\").data,\n    provider\n  );\n\n  // 3. Retrieve the Relay Contract\n  const relayAddress = await flareContractRegistry.getContractAddressByName(\n    \"Relay\"\n  );\n  const relay = new ethers.Contract(\n    relayAddress,\n    flare.nameToAbi(\"IRelay\", \"coston\").data,\n    provider\n  );\n\n  // 4. Get the Random Number\n  const [randomNumber, isSecure, timestamp] = await relay.getRandomNumber();\n  console.log(\"Random Number is\", randomNumber);\n  console.log(\"Is it secure\", isSecure);\n  console.log(\"Creation timestamp is\", timestamp);\n}\n\nrunGetRandomNumber();",
    "meta_data": {},
    "file_name": "files/flare-docs/samples/ftso/GetRandomNumber.js",
    "type": "code"
  },
  {
    "content": "const { expect } = require(\"chai\");\ndescribe(\"Test Random Number\", function () {\n  let contract;\n  beforeEach(async function () {\n    contract = await ethers.deployContract(\"GetRandomNumber\");\n  });\n\n  it(\"RandomNumber\", async function () {\n    const [randomNumber, isSecure, timestamp] = await contract.generateNumber();\n    expect(randomNumber).to.be.at.least(\n      1000000000000000000000000000000000000000n\n    );\n    expect(isSecure).to.be.true;\n    expect(timestamp).to.be.gt(1695817332);\n  });\n});",
    "meta_data": {},
    "file_name": "files/flare-docs/samples/ftso/TestGetRandomNumber.js",
    "type": "code"
  }
]